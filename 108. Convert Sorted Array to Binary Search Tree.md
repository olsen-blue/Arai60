# Step1
- まず、平衡二分木(height-balanced binary search tree)の構築イメージがよくわかなかったので、入力例をよく見る。
- 真ん中のノードを値に決定しているようだった。numsが昇順なので、真ん中のノードが根ノードになりそう。
- 二分木の性質上、根ノードの左右で、値の制約がある。numsの真ん中を根ノードとして決定すると、その左側・右側のノードを使って、左部分木・右部分木を作れば良い。再帰っぽいなとわかる。
- しかも、二分探索っぽいことしてるな、とわかる。下記のように整理してまとめてみる。
   - 前日までの引き継ぎ：師匠から受け継いだ、left ~ right のノードを使って、自分も二分木構造を作ることに協力すれば良いらしい。
   - 本日のやること：真ん中ノードを今日の根ノードとして採用。根ノードの左側ノードで左子部分木、右側ノードで右子部分木を作るように、自分の二人の弟子に依頼する。
   - 終了条件：ノードがなくなったら終わり。つまりleft > rightのとき。
   - middleの制約：平衡二分木を作るので、真ん中のノードでなければならない。
   - 初期値：使えるノードが全て手元にある、二分木構造をまだ何も形成していない状態。

- 下記のように書けた。しっかり整理したのが良かったかもしれない。
- 二分探索と同じ頭の使い方なのが意外だった。
## 解法１：区間における二分探索っぽい再帰：AC
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def index_range_to_BST(left, right):
            if left > right:
                return None
            middle = (left + right) // 2
            node = TreeNode(nums[middle])
            node.left = index_range_to_BST(left, middle - 1)
            node.right = index_range_to_BST(middle + 1, right)
            return node
        return index_range_to_BST(0, len(nums) - 1)
```
# Step2
- PR見てみる。
- ヘルパー関数使ってないもの。使わなくてもスライスでできるんですね〜と、思ったが、スライス作るとコピー発生して、重くなるらしいので採用をやめる。
- https://github.com/SuperHotDogCat/coding-interview/pull/40/files
- https://github.com/SuperHotDogCat/coding-interview/pull/40/files#r1770559848
- その他PRに目を通すが、解法ロジックはとりあえずこれで問題なさそう。
- 関数名だが、呼び出す側の視点で何が返ってくるかが分かれば良い、ということをふと思い出す。まあ、現状のままで良いのではと感じる。
- left, middle, rightは、できればノードではなくてインデックスであることがわかったほうがベターかもしれないが、冗長になるのが嫌・シンプルが好きなので、そのままにする。
- あれ、nodeよりrootの方が良くないか？と気付く。middleで選んでるノードを根ノードにしてるので。
- rootにしている方を発見。私も賛成です。
- https://github.com/kazukiii/leetcode/pull/25/files
## 解法１：区間における二分探索っぽい再帰：AC
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def index_range_to_BST(left, right):
            if left > right:
                return None
            middle = (left + right) // 2
            root = TreeNode(nums[middle])
            root.left = index_range_to_BST(left, middle - 1)
            root.right = index_range_to_BST(middle + 1, right)
            return root
        return index_range_to_BST(0, len(nums) - 1)
```

# Step3
- 再現性の確認。2分で実装。
- index_range_to_BST(0, len(nums) - 1)の呼び出しで、返すものが「root」であるというのが直感的で良いかもと感じた。
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def index_range_to_BST(left, right):
            if left > right:
                return None
            middle = (left + right) // 2
            root = TreeNode(nums[middle])
            root.left = index_range_to_BST(left, middle - 1)
            root.right = index_range_to_BST(middle + 1, right)
            return root
        return index_range_to_BST(0, len(nums) - 1)
```
# Step4
- hroc135さんのコメントが、その通りだと思ったので修正。型ヒントをつける。（いつもありがとうございます。）
- https://github.com/olsen-blue/Arai60/pull/24#discussion_r1934899506

## 解法１：区間における二分探索っぽい再帰：AC
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def index_range_to_BST(left: int, right: int):
            if left > right:
                return None
            middle = (left + right) // 2
            root = TreeNode(nums[middle])
            root.left = index_range_to_BST(left, middle - 1)
            root.right = index_range_to_BST(middle + 1, right)
            return root
        return index_range_to_BST(0, len(nums) - 1)
```
