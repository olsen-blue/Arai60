# Step1
- 累積和を求めたあと、区間を2ポインタで舐めつつ最大値を調べる方法がまず思いついたが、O((num.length)^2)となるので、計算が間に合わなそう。
- その他解法、思いつかず。
- https://discord.com/channels/1084280443945353267/1206101582861697046/1208414507735453747
   - なるほど。ある地点に立っているとする。先頭からの累積和のうち最小値を管理しておいて、最小累積和と現地点までの累積和の差を求めれば良さそう？
   - 「560. Subarray Sum Equals K」と近い考え方かもしれない。
   - 後ろを振り返った時に、最も標高の低い地点との差を求め、その差でmax()の最大値更新を行い続ければ良い。
   - 累積和という表現より、標高で考える方がしっくりくる。
   - これらの理解をもとに実装。
## 解法1:累積和の最小値管理:Accepted
- 標高のイメージを使うので個人的には好きな解法。
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        min_prefix_sum = 0
        prefix_sum = 0
        max_sum = nums[0]
        for num in nums:
            prefix_sum += num
            max_sum = max(max_sum, prefix_sum - min_prefix_sum)
            min_prefix_sum = min(min_prefix_sum, prefix_sum)
        return max_sum
```

- https://github.com/sakupan102/arai60-practice/pull/33/files
   - ほぼ同じコード。変数名とかとりあえずこのままでも良さそう。

# Step2
- 他の解法の選択肢を持ちたい。
- https://github.com/hayashi-ay/leetcode/pull/36/files
   - こちら拝見。なるほど。いわゆる個数無制限ナップザックDP(一行分のみ)に近い処理をしているのでは、と感じた。
   - 何も足さずにその地点の値をそのまま採用 or 左側で計算済みの結果にさらに加算 のうち良い方を選択する、ということですかね。
   - もっと言うと、1次元配列のナップザックDPがより見た目的にも近いのでは？ 蟻本P.60見てみる。やっぱりほぼ同じ遷移の仕方に見える。
- https://github.com/fhiyo/leetcode/pull/33/files
- https://github.com/sakupan102/arai60-practice/pull/33/files
   - Kadaneのアルゴリズムともいうらしい。
- 個人的には個数無制限ナップザックDPのイメージの方が好き。なぜなのか...？
- Kadaneだと「加算継続 or 新規に数列を開始する」というイメージだが、ナップザックDPのイメージは「加算継続 or 何もしない」というイメージで、だいぶ違うのは、なぜ...？
- ああ、シンプルに、「numsの要素使いながら何もないところに新規に構築していく vs DPテーブルが既に用意されている」という違いだけなのでは、と気付く。
## 解法2:ナップザックDPのイメージで書くとKadaneっぽくなる解法:Accepted
- しっくりくるナップザックDPっぽく考えるために、「上から新しくnums[i]が降ってくる」と「左隣の結果に + nums[i] する」というイメージを持つと、スムーズに書けた。
- 結果として書けているのはKadaneなのでは？とか思ったが、解法の名前とかどうでもよくて、自分がしっくりくればそれで良いやと思った。(なので変な解法名になっています。)
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        INITIAL_VALUE = - math.inf
        max_sum_at_index = [INITIAL_VALUE] * len(nums)
        max_sum_at_index[0] = nums[0]
        for i in range(1, len(nums)):
            max_sum_at_index[i] = max(nums[i], max_sum_at_index[i-1] + nums[i])
        return max(max_sum_at_index)
```

# Step3
- それぞれで再現性の確認。
## 解法1:累積和の最小値管理:Accepted
- 3分くらいで実装。
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        prefix_sum = 0
        min_prefix_sum = 0
        max_sum = - math.inf
        for num in nums:
            prefix_sum += num
            max_sum = max(max_sum, prefix_sum - min_prefix_sum)
            min_prefix_sum = min(min_prefix_sum, prefix_sum)
        return max_sum
```

## 解法2:累積和の最小値管理:Accepted
- 2分で実装。
- ナップザックのイメージさえできればこっちの方がスムーズ。(上から降ってくるnums[i]をいつものdp[i]として見ることさえできればですが...)
- 動的計画法は、インデックスを明示してリストを使った遷移式を書くのが、何となく好き。
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        INITIAL_VALUE = - math.inf
        max_sum_at_index = [INITIAL_VALUE] * len(nums)
        max_sum_at_index[0] = nums[0]
        for i in range(1, len(nums)):
            max_sum_at_index[i] = max(nums[i], max_sum_at_index[i-1] + nums[i])
        return max(max_sum_at_index)
```
