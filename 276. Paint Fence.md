# Step1
- ある１つの状態に到達するための最後の１手としては、１色だけ塗る・２色だけ塗るの２つ選択肢ありそう。まずボトムアップ。
## 解法1:ボトムアップ:Accepted
- 0-indexedだと、インデックスとnの値がずれて分かりづらいので、1-indexedとした。読み手が0-indexed か 1-indexed で迷う可能性があるので、この点良くないかもと感じた。
```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k
        if n == 2:
            return k * k
        ways_at_index = [0] * (n+1)
        ways_at_index[1] = k
        ways_at_index[2] = k * k
        for i in range(3, n+1):
            ways_at_index[i] = (k-1) * ( ways_at_index[i-1] + ways_at_index[i-2] )
        return ways_at_index[n]
```
## 解法2:トップダウン(@cache使用):Accepted
- 「@cache」を抜くとTLEとなる。これは再利用できるcount_ways(i)の計算結果を用いないことからくるものであろう、と理解。
- 再利用が必要な理由：下記のように、countWays(5)を計算するとき、計算のダブりが生じるので、同じ計算は避けるべき。
```
total_ways(5)
├── total_ways(4)
│   ├── total_ways(3)
│   │   ├── total_ways(2)
│   │   └── total_ways(1)
│   └── total_ways(2) 
└── total_ways(3)
    ├── total_ways(2) 
    └── total_ways(1)
```

```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        @cache
        def count_ways(i):
            if i == 1:
                return k
            if i == 2:
                return k * k
            return (k-1) * (count_ways(i-1) + count_ways(i-2))
        return count_ways(n)
```

## 解法3:トップダウン（memo化）:Accepted
- 辞書使ってメモ化する。defaultdictだと意図しないキーが呼ばれたときにデフォルト値返せるが、今回は不要？と思い、普通の辞書を使う。
```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        index_to_num_ways = {}
        def count_ways(i):
            if i == 1:
                return k
            if i == 2:
                return k * k
            if i in index_to_num_ways:
                return index_to_num_ways[i]
            index_to_num_ways[i] = (k-1) * (count_ways(i-1) + count_ways(i-2))
            return index_to_num_ways[i]
        return count_ways(n)
```

# Step2
- PR見てみる。
- LRU cacheデコレータ自作している。スゲー。前もどっかの問題で考えるタイミングがあったが、GPTに作ってもらっただけで何も覚えていない。よく聞かれるらしいので書いてみる。
- https://github.com/hayashi-ay/leetcode/pull/17/files
   - 最初特に関数をラップする周辺の処理がよくわからずだったが、調べたり写経したりしつつ理解。正直ゼロから実装できる気はしないが...
- 理解まとめ：同じ引数入力に対して計算結果の再利用をしたいので、引数の入力が、特に大事な値なのではと感じた。
   - cache(辞書)の中では、関数の引数入力(<-今回はタプル)をキー(key)、node オブジェクトを値として、名簿のように管理する。辞書なので検索が高速でO(1)でできる。
   - node 内部のプロパティでは、関数引数入力のキー(key)、関数の戻り値(val)、連結リンク情報(prev, next)を管理している。情報はすべてここに一元化してある。
   - 双方向連結リスト（doubly linked list）として node 構造により、next, prevを設定して、順序の管理も行っている。
       - sentinel を先頭の番兵ノードとして、順序管理する。sentinel の前後(prev, next)で順序更新・追加・削除を行うので計算量が効率化されO(1)になる(?)
       - 使用が最も新しいものを最前(sentinel.next)、最も古いものを最後尾(sentinel.prev)として管理している。
## 解法4: LRU Cache
- 一部変数名など修正したり、**kwargsは使ってないのでなくても良いかなと感じて取ったりしたが、こちらを参考に書いた。
- https://github.com/hayashi-ay/leetcode/pull/17/files
```python
# ノードのクラス
class Node:
    def __init__(self, key=None, value=None, next=None, prev=None):
        self.key = key      #関数の引数入力
        self.value = value  #関数の戻り値
        self.next = next    #後ろのノード
        self.prev = prev    #前のノード

#- キャッシュのクラス
class LRU_Cache:
    def __init__(self, capacity):
        self.capacity = capacity    #最大キャパ
        self.size = 0               #現在のキャッシュサイズ：len()より数値管理の方が効率的
        self.cache = {}             #キャッシュをメイン管理する辞書
        self.sentinel = Node(1, 1)  #先頭の番兵
        self.sentinel.prev = self.sentinel  #最新
        self.sentinel.next = self.sentinel  #もっとも古い

    def get(self, key):
        if key not in self.cache:
            return None
        node = self.cache[key]
        self.remove(node.key)
        self.insert_front(node.key, node.value)
        return node.value
    
    def remove(self, key):
        if key not in self.cache:
            return
        node = self.cache[key]
        node.prev.next = node.next
        node.next.prev = node.prev
        del self.cache[key]
        self.size -= 1

    def insert_front(self, key, value):
        first_node = Node(key, value)
        second_node = self.sentinel.next

        self.sentinel.next = first_node
        first_node.prev = self.sentinel.next
        first_node.next = second_node
        second_node.prev = first_node

        self.size += 1
        self.cache[key] = first_node
        if self.size > self.capacity:
            last_node = self.sentinel.prev
            self.remove(last_node.key)

# デコレータを呼ぶ時の流れ
# - @my_lru_cache(maxsize=1000) は my_lru_cache(1000) を実行する
#   - → decorating_function が返される
# - その decorating_function に numWays が渡される
#   - → _my_lru_cache_wrapper(numWays, 1000) を実行  
# - _my_lru_cache_wrapper の戻り値 wrap に numWays が置き換えられる
#   - → numWays = wrap となる（キャッシュ機能付きに変わる！） 
# - （まとめ）全体的には「numWays = my_lru_cache(maxsize=1000)(numWays)」という処理をしている。２段処理構造になっている。numWays は wrap に置き換わる。


def my_lru_cache(maxsize=1):
    def decorating_function(func):
        nonlocal maxsize
        if maxsize <= 0:
            maxsize = 1
        return _my_lru_cache_wrapper(func, maxsize)
    return decorating_function

def _my_lru_cache_wrapper(func, maxsize):
    cache = LRU_Cache(maxsize)
    def wrap(*args):                # * をつけることで複数入力がタプルにまとまり、タプルが複数入力に分割展開される。つまり -1 をかけるようなスイッチ的な操作ができる。
        result = cache.get(args)
        if result is not None:
            return result
        result = func(*args)
        cache.insert_front(args, result)
        return result
    return wrap

class Solution:
    def numWays(self, n: int, k: int) -> int:
        @my_lru_cache(maxsize=1000)
        def count_ways(i):
            if i == 1:
                return k
            if i == 2:
                return k * k
            return (k - 1) * ( count_ways(i-1) + count_ways(i-2) )
        return count_ways(n)
```
 - フィボナッチ数列や行列の開放もあるようだったが、お腹いっぱいになってしまった。
 - SWEの常識に該当する他の解法があれば見てみたいので、あれば教えていただけると嬉しいです。

## 解法1:ボトムアップ:Accepted
- ほぼStep1のまま。num_waysに修正。num_waysで良いか少し戸惑う。動的計画法のDP配列・テーブルには、頻繁にdp[i]という変数名をつけていた弊害です。
```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k
        if n == 2:
            return k * k
        num_ways = [0] * (n+1)
        num_ways[1] = k
        num_ways[2] = k * k
        for i in range(3, n+1):
            num_ways[i] = (k-1) * ( num_ways[i-1] + num_ways[i-2] )
        return num_ways[n]
```
# Step3
## 解法1:ボトムアップ:Accepted
- もっとも自然に感じた解法で再現性の確認。3分くらいで実装。
```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k
        if n == 2:
            return k * k
        num_ways = [0] * (n+1)
        num_ways[1] = k
        num_ways[2] = k * k
        for i in range(3, n+1):
            num_ways[i] = (k-1) * (num_ways[i-1] + num_ways[i-2])
        return num_ways[n]
```
