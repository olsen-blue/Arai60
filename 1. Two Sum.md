# Step1
- 解法は、２重ループが一番シンプルで計算も、numsの長さ的にギリギリ間に合いそう。でも、辞書の検索はもっと速そう。
- 辞書の解法は、「141. Linked List Cycle」のset()を用いた１パスループ解法＋和を構成する補数を探す、という方針でいけそう？
- 下記でAC。該当インデックスがない時の出力は[]で良いのか、エラーメッセージを返した方が良いのか・・・？

#解法１：２重ループ
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(1, len(nums)):
            for j in range(0, i):
                if nums[j] + nums[i] == target:
                    return [i, j]
        return []
```

#解法２：辞書
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        num_to_index = defaultdict(int)
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in num_to_index:
                return [num_to_index[complement], i]
            num_to_index[nums[i]] = i
        return []
```

# Step2
- まず、公式solution見てみる。
- ２重ループは、そのままだった。
- 辞書の解法は２パスもあるようだが、「hashmap[complement] != i」の条件式が、自分の場合失念する可能性大なので、１パスの方がこの考慮が不要・シンプルで好きだなという感想。
https://leetcode.com/problems/two-sum/solutions/127810/two-sum/   

- このodaさんのコメントが気になる。
https://github.com/tarinaihitori/leetcode/pull/11
- 「return []」では、受け取ったユーザーが「？」となるな、と思い、Exception投げる必要性を感じる。
- Exceptionについて、理解が不足しているので、ドキュメントを見てみる。
- 今回、Exceptionを投げるとしたら、「ValueError」らしい。「347. Top K Frequent Elements」の時と同じだ。
- ValueErrorのドキュメントの説明：「Raised when an operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception such as IndexError.」なるほど。
- 「ん？、Exceptionには「"より"詳細("more" precise)」なものと「”より”曖昧」なものがあるのか？」と気になる。
- というのも、用途が全てはっきりと決まっている、とばかり思っていたため...調べてみる。
  
- （例）
- 「詳細」：
  - IndexError：リストや配列、タプルなどのシーケンス型で、範囲外のインデックスにアクセスしようとした場合に発生する。
      - ➡️dpの遷移時にインデックスの値域をミスしたとき、などにかなりお世話になっているエラー。なるほど、これなら原因が分かりやすいので、すぐにコードを修正したりできる。
  - KeyError：辞書（dict）で存在しないキーにアクセスしようとした場合に発生します。
      - ➡️あ、そういえばこれを避けるために、defaultdict(型名)を使ってるんだった。と思い出す。起きても何のエラーか具体的でわかりやすい。
- 「曖昧」：
  - Exception：最も一般的で抽象的なエラー。すべてのエラーの基底クラスであり、エラーの具体的な種類に関係なく、何か予期しないエラーが発生したことを示す。
      - ➡️え、いくら何でも意味が広すぎる...！エラー出ても、何のエラーか分からなそうだが、未知のものに対しては、これを使うしかなさそう。
  - ValueError：引数が不正な値であるが、型そのものは正しい場合に発生する。型に問題があるわけではなく、値に問題があるということを示します。
      - ➡️これは「型は正しいんだけど...値が惜しいんですよね...」っていう比較的主張の弱い微妙なニュアンスを表現していることがわかった。だから曖昧寄りなのか。納得。
- (まとめ) ということで、エラーは適切に使い分けなければならないと分かった。

- 個人的に、解法２が比較的速くて好きなので、これにExceptionを追記してみる。

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        num_to_index = defaultdict(int)
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in num_to_index:
                return [num_to_index[complement], i]
            num_to_index[nums[i]] = i
        raise ValueError("The target value cannot be achieved by using the given nums.")
```

# Step3：再現性の確認をしました。（Step2と同じ認識）
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        num_to_index = defaultdict(int)
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in num_to_index:
                return [num_to_index[complement], i]
            num_to_index[nums[i]] = i
        raise ValueError("The target value cannot be achived by using given nums.")
```
