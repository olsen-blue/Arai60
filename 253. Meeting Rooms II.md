# Step1
## 解法1:累積和:AC
 - 前問同様、累積和。累積和の瞬間最大和をカバーできる最小キャパを用意すればOK。
 - 5分で実装してAC。うれしい。
```py
class Solution:
    MAX_RANGE = (10 ** 6) + 1
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        start_end_times = [0] * Solution.MAX_RANGE
        for start_time, end_time in intervals:
            start_end_times[start_time] += 1
            start_end_times[end_time] -= 1
        
        prefix_sum = 0
        min_rooms = 0
        for index in range(len(start_end_times)):
            prefix_sum += start_end_times[index]
            min_rooms = max(min_rooms, prefix_sum)
        return min_rooms
```

# Step2
 - PR見ていく
 - https://github.com/hayashi-ay/leetcode/pull/62/files#r1538488410
 - https://github.com/Mike0121/LeetCode/pull/28/files
   - Step1の解法1は、これらの解法と近いですね。一旦リストに情報を全て集約してソートしたのち取り出しているのか。なるほど。
   - ちょっと実装が重めかも。解法1の方が軽くてシンプルで好きですね。
 - https://github.com/shining-ai/leetcode/blob/main/arai60/54-60_others/56_253_Meeting%20Rooms%20II/level_5.py
   - heap 使う解法が意外とある。(本当に必要なのだろうか...) あとこれ、if分岐の意図、[0]を取得している意図がよくわからずだった。
 - https://github.com/Mike0121/LeetCode/pull/28/files
   - これもヒープだ。あ〜、終わる時間が最小(最も早い)ものと干渉しなければ、会議室を増やすことにはつながらないという訳ですね。なるほど。でも少し複雑ではと感じる。
 - https://github.com/Mike0121/LeetCode/pull/28/files#r1636837838
   - ヒープが推奨されているわけではなさそう。うむ。シンプルな方が好きなので今の解法のままでいいかも。
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/61/files#diff-40324090ced987d17a7e896bb2ee269c2808e535833f6b829834ea9836adb651R19-R20
   - Step1の解法1と同じ考え方ですね。機械的に数値に落とし込むのが一番シンプルだと思います。
 - https://github.com/Ryotaro25/leetcode_first60/pull/61/files#diff-2ebe61ca7df24fc3af88af5a96446e22ce53121907edf39198c3c8dd32372720R37
   - 「制約的にOKでも、intervalsが空であるかどうかは判定しないと不安です」 <- してなかった...
   - https://github.com/Mike0121/LeetCode/pull/28/files#diff-98fb288092e93d2ccbbd5257f188be11755b51d4a2261d80f93363938a99889fR32-R33
       - こんな感じでやりましょうか。
## 解法1':累積和:AC
# - intervalsが空かどうかのチェックを追記
```py
class Solution:
    MAX_RANGE = (10 ** 6) + 1
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        start_end_times = [0] * Solution.MAX_RANGE
        for start_time, end_time in intervals:
            start_end_times[start_time] += 1
            start_end_times[end_time] -= 1
        
        prefix_sum = 0
        min_rooms = 0
        for index in range(len(start_end_times)):
            prefix_sum += start_end_times[index]
            min_rooms = max(min_rooms, prefix_sum)
        return min_rooms
```

# Step3
 - 再現性の確認。Step1に引き続きスムーズにスラスラと書けた。
 - for start_time, end_time in intervals: は冗長なので下記のように start/end に修正して書いた。start_end_times というリストの名前にしてるし、これで十分伝わりそう。
 - min と max が混在しているのがなんだかよくない気がするが、これしかないのでは。う～ん。
```py
class Solution:
    MAX_RANGE = 10 ** 6 + 1
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        start_and_end_times = [0] * Solution.MAX_RANGE
        for start, end in intervals:
            start_and_end_times[start] += 1
            start_and_end_times[end] -= 1
        
        min_num_rooms_required = 0
        prefix_sum = 0
        for i in range(len(start_and_end_times)):
            prefix_sum += start_and_end_times[i]
            min_num_rooms_required = max(min_num_rooms_required, prefix_sum)
        return min_num_rooms_required
```
