# Step1
 - DPの項に入ってから、ナップザックDPという言葉を何回使ったか分からないが、これこそがナップザックDPですね。
 - https://qiita.com/drken/items/a5e6fe22863b7992efdb
   - この辺の図がわかりやすいのではと思います。
## 解法1:ボトムアップ2次元DP(ナップザック):AC
 - ちなみに今回は、個数無制限のナップザックDP。縦軸が使えるコイン(index増加に伴い積算で種類追加していく)、横軸が合計値、2次元テーブルの値が最小枚数。
 - r行目で使えるコインアイテムは coins[r] ではなく coins[r-1]、最後の出力は解なしの場合 -1 を出力すること、の修正をしてAC。
```py
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        num_rows = len(coins) + 1
        num_cols = amount + 1
        min_num_coins = [[math.inf] * num_cols for _ in range(num_rows)]
        min_num_coins[0][0] = 0
        for r in range(1, num_rows):
            for c in range(num_cols):
                if c < coins[r-1]:
                    min_num_coins[r][c] = min_num_coins[r-1][c]
                else:
                    min_num_coins[r][c] = min(min_num_coins[r-1][c], min_num_coins[r][c - coins[r-1]] + 1)
        if min_num_coins[-1][-1] != math.inf:
            return min_num_coins[-1][-1]
        else:
            return -1
```

## 解法2:ボトムアップ1次元DP(ナップザック):AC
 - 1次元にしたら、メモリを少なくできる。
 - coin取り出しもforでシンプルになる。2次元より良いですね。
 - とはいえ、2次元のイメージが前提として頭にないと自信を持って書けない...遷移のイメージは2次元の方が好きなので
```py
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        min_num_coins = [math.inf] * (amount + 1)
        min_num_coins[0] = 0
        for coin in coins:
            for c in range(amount + 1):
                if c < coin:
                    continue
                else:
                    min_num_coins[c] = min(min_num_coins[c], min_num_coins[c - coin] + 1)

        if min_num_coins[-1] != math.inf:
            return min_num_coins[-1]
        else:
            return -1
```

# Step2
 - PRみてみる。BFSとDFSの解法もありそう。
 - DFSは突き進んだり、塗りつぶしたりが得意な子ですが、この問題にはそのバイヴスやにおいが感じられない。
 - BFSではcoinの枚数を、最短距離として見ると直感的ですね。
 - https://github.com/TORUS0818/leetcode/pull/42/files#r1904169457
   - DFSは無駄な処理が起こるらしい。じゃあBFSの方はやっておくか。
 - https://github.com/fhiyo/leetcode/pull/41/files#r1679585050
   - DFS or BFS で迷った時のTIPS(?)　なるほどです。
 - https://github.com/TORUS0818/leetcode/pull/42/files#r1904160562
   - 根つき構造のBFSですね。
 - https://github.com/olsen-blue/Arai60/pull/26/files
   - この辺り思い出して書く。
 - 今回は以前の実装と比較して、2つの点を考慮する必要がありそう。
   - 今回は、if next_amount > amount:のときスキップする考慮(<- これしないと、2重forで次のパスを樹形図的に無尽蔵に生成し続けてしまう)
   - 同じ値に2回目以降到達した際は1回目の到達よりも、その場所の根つき構造の深さが浅くなる(最短距離が短くなる)ということはないので、スキップする考慮
 - 根つき木構造のBFSのアルゴリズムは、好きなところはたくさんある...!(かなり好き)
   - 根つき木の図的イメージが浮かぶところ(これがでかい)
   - 2リスト用意することで階層別に探索ノードを分離できるところ
   - 外部に管理変数としておいている depth(今回は num_coins)で俯瞰的に深さを管理できるところ。
       - なんかついでに、このアルゴリズムに人格と愛着を感じたので、言語化しておく。下向きに伸びるビルを建設中の工事現場が見えてきました。
       - while の中の色々な処理は、建物を1段大きくする工程。全体のことは見えず必死に次の階層を構築するための工事をしている。
       - で、工事中に「もうゴールですか?(amountに等しい?)」「今って深さどこまで来てたっけ？」「次作ろうとしてるものって既出ですか？」みたいな要確認事項を外部変数(amount, num_coins, visited_amounts)に聞いてる。
       - 外部変数たちは、建物の外にいて全体を俯瞰で見て管理している現場監督ニキ。こいつらは作業しない。
## 解法3:根つき木BFS:AC
```py
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0
        amounts = [0]
        visited_amounts = set()
        num_coins = 1
        while amounts:
            next_amounts = []
            for amount_ in amounts:
                for coin in coins:
                    next_amount = amount_ + coin
                    if next_amount == amount:
                        return num_coins
                    if next_amount > amount:
                        continue
                    if next_amount in visited_amounts:
                        continue
                    visited_amounts.add(next_amount)
                    next_amounts.append(next_amount)
            amounts = next_amounts
            num_coins += 1
        return -1
```
 - https://github.com/nittoco/leetcode/pull/38/files#r1845466688
   - 配る/貰う遷移の由来はこれか。
 - https://github.com/TORUS0818/leetcode/pull/42/files
   - ボトムアップは、indexの名前をつけてあげるべき?
   - r,cたくさん出てくる解法1でそれやると逆に文字量増えて見づらいかなあ。
   - 解法2は r, c の対称性ないので、c 単独使用はちょっとダメかもなあという気持ち。かといって良い案が思いつかない。index はなるべく短くしたい...
   - 意味づけとしては amount の各値という感じなのですが...
   - あ、そもそもデフォで与えられている amount と表現が衝突してるので、こっちを target_amount にしてしまえという修正でお茶を濁しました。
## 解法2:ボトムアップ1次元DP(ナップザック):AC
```py
class Solution:
    def coinChange(self, coins: List[int], target_amount: int) -> int:
        min_num_coins = [math.inf] * (target_amount + 1)
        min_num_coins[0] = 0
        for coin in coins:
            for amount in range(1, target_amount + 1):
                if amount < coin:
                    continue
                else:
                    min_num_coins[amount] = min(min_num_coins[amount], min_num_coins[amount - coin] + 1)

        if min_num_coins[-1] != math.inf:
            return min_num_coins[-1]
        else:
            return -1
```

# Step3
 - 解法2、解法3がしっくりきたのでこれを繰り返し書いて、再現性確認。
## 解法2:ボトムアップ1次元DP(ナップザック):AC
 - 繰り返し書く中で感じたこと : 
 - 行インデックスのことを神経質に考えなくて済む for coin in coins: という書き方ができたのが直感的で良い。
   - if amount < coin: のところも自然言語的に自然なコードになっている。
 - とはいえ、脳内にイメージとして描いているのは、2次元DPです。
 - イメージは2次元DPで持ちつつ、実装は1次元でやるのが、個人的には両者の良いとこどりをした、最高の書き方かもと感じた。
 - 最終的には4分くらいで実装。
```py
class Solution:
    def coinChange(self, coins: List[int], target_amount: int) -> int:
        min_num_coin = [math.inf] * (target_amount + 1)
        min_num_coin[0] = 0
        for coin in coins:
            for amount in range(1, target_amount + 1):
                if amount < coin:
                    continue
                else:
                    min_num_coin[amount] = min(min_num_coin[amount], min_num_coin[amount - coin] + 1)
        if min_num_coin[target_amount] != math.inf:
            return min_num_coin[target_amount]
        else:
            return -1
```

## 解法3:根つき木BFS:AC
 - 繰り返し書く中で感じたこと : 
 - やっぱり好きな解法。諸々の機能や処理が適切に分離されているのがやっぱ良い。
 - これを書くときは、軽くで良いので図を書くと実装がスムーズだと感じた。
 - 5分くらいで最終的に実装。
```py
class Solution:
    def coinChange(self, coins: List[int], target_amount: int) -> int:
        if target_amount == 0:
            return 0
        amounts = [0]
        num_coins = 1
        visited_amounts = set()
        while amounts:
            next_amounts = []
            for amount in amounts:
                for coin in coins:
                    next_amount = amount + coin
                    if next_amount == target_amount:
                        return num_coins
                    if next_amount > target_amount:
                        continue
                    if next_amount in visited_amounts:
                        continue
                    visited_amounts.add(next_amount)
                    next_amounts.append(next_amount)
            amounts = next_amounts
            num_coins += 1
        return -1
```
