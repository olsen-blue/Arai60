# Step1
- どう解くべきかよく分からないので問題文のExampe1で実験して、動きのシミュレーションをしてみた。手元の紙に書くなどしたが、本番はこんなことできない気がする。。。
  - preorder の中からノードを先頭から順番に取り出して根ノードを考える感じっぽい。(ある index で指定)  
  - preorder から取り出したノードが inorder のどこにあるか見つける。発見した位置が大事っぽい。（-> node_to_index みたいな辞書を使いそう？）
  - inorder の中の、発見位置から左のノードを用いて左子部分木を作り、発見位置から右のノードを用いて右子部分木を作ればよさそう？
  - inorder は二分探索の引き継ぎみたいにノードの範囲を絞っていくイメージだろうか。
  - 新しい処理が発生するときは、「index += 1」の更新が必要そう。indexは木構造全体に対して１つだけ変数として与えて管理する感じが良さそう。根つき構造BFSで、木構造全体に対してdepthを１変数のみ与えるのと同じ感覚。
- 上記を踏まえて、自分で実装にトライしてみる。
- ネストされた関数があるとき、外側の関数内で宣言した変数を内側の関数で使用したいときは、「nonlocal preorder_index」と宣言(?)してやる必要があるらしい。また、「nonlocal preorder_index += 1」みたいには書けないらしい。nonlocalの使い方だけ知らなくて調べた。他は書くことができた！うれしいです。
   - （参考）ちなみに関数の外にある（グローバルスコープの）変数を関数内から変更したいときは「global preorder_index」とするらしい。
- 「98. Validate Binary Search Tree」や「108. Convert Sorted Array to Binary Search Tree」でも使った、二分探索のように引き継ぎしながら区間を絞っていく考え方がここでも活きた気がする。
  - 「349. Intersection of Two Arrays」のときに、odaさんに指導いただきつつ二分探索の理解を深めておいて良かったです。ありがとうございました。
- 時間計算量：O(n)
  - 辞書作るのにO(n)、辞書検索はO(1)、再帰の処理回数はノードの数の分だけ行うのでO(n)、全体としてはO(n)になる。
- 空間計算量：
  - 辞書がO(n)の容量、再帰スタックは最悪のダンゴ状に繋がったノードの場合O(n)・平衡二分木のような最良の場合O(logN)の容量、全体としてはO(n)になる。
- これまで計算量については、トライした解法がTLEになってしまうなど、それを考える必要が生じた際にだけ考えてきたが、他の方のPRには結構書いてあるので、自分も毎回考えてみる方が良いかもと感じた。
- (多重ループとかしない限りは...)シンプルかつ直感的に感じる解法ならば、計算量も間に合うのではという思いもあったが、主観・直感に過ぎないので、毎度検証すべきかもと感じた。
## 解法1:辞書:Accepted
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        node_to_inorder_index = {}
        for index, node in enumerate(inorder):
            node_to_inorder_index[node] = index

        preorder_index = -1
        def helper(left: int, right: int):
            if left > right:
                return None
            nonlocal preorder_index
            preorder_index += 1 #helperを呼ぶときに更新する（今回、親->子に値を引き継ぐ感じではないので、関数の引数で与えるのではなく、関数外部で管理。）
            node = TreeNode(preorder[preorder_index])
            inorder_index = node_to_inorder_index[node.val]
            node.left = helper(left, inorder_index - 1)  # preorder の順序的には、left 先で right 後という順番で処理が必要。
            node.right = helper(inorder_index + 1, right)
            return node
        return helper(0, len(inorder) - 1)

```

# Step2
- まず、セルフでコメントしてみる。
- helperより、もっといい関数名ないのか？前問同様、関数名に悩む。
   - bulid_tree_from_inorder_range とかだろうか？木構造の構築には、inorder内のノードに対してインデックス範囲を絞りながら作ってる感覚があったためです。 
- 「preorder_index」の初期値「-1」は、「末尾」だと理解されかねない。しかし「2. Add Two Numbers」で番兵を用意したのと同じ感覚で、最初の要素を特別扱いせずに済むようにするため、苦肉の策として「-1」としていた。
   - 「-1」は「末尾」ではなく、「初期インデックス」であることを示すように「INITIAL_VALUE」などとすれば良いのでは？
- ざっとPR見てみる。
- https://github.com/hayashi-ay/leetcode/pull/43/files
   - 綺麗に書いてある。
   - あ、 preorder_indexの更新タイミングずらすだけで、-1 使わなくて済むじゃん、と気づく。
  - 「preorder_index = 0」なら、「INITIAL_VALUE」とかやる必要ないな、と感じる。

## 解法1:辞書:Accepted
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        node_to_inorder_index = {}
        for index, node in enumerate(inorder):
            node_to_inorder_index[node] = index

        preorder_index = 0
        def bulid_tree_from_inorder_range(left: int, right: int):
            if left > right:
                return None
            nonlocal preorder_index
            node = TreeNode(preorder[preorder_index])
            preorder_index += 1
            inorder_index = node_to_inorder_index[node.val]
            node.left = bulid_tree_from_inorder_range(left, inorder_index - 1)
            node.right = bulid_tree_from_inorder_range(inorder_index + 1, right)
            return node
        return bulid_tree_from_inorder_range(0, len(inorder) - 1)

```

## 解法2:inorder.index(根ノード値)の利用:Accepted
- https://github.com/hayashi-ay/leetcode/pull/43/files
   - 「inorder.index(根ノード値)」というのを使えるのを知らなかったが、これ知ってたらこれで書いてしまう気がする。
   - 辞書は計算量O(1)だったが、これはリスト舐めていくのでこの検索方法だとO(n)に変わる。

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        preorder_index = 0
        def bulid_tree_from_inorder_range(left: int, right: int):
            if left > right:
                return None
            nonlocal preorder_index
            node = TreeNode(preorder[preorder_index])
            preorder_index += 1
            inorder_index = inorder.index(node.val)
            node.left = bulid_tree_from_inorder_range(left, inorder_index - 1)
            node.right = bulid_tree_from_inorder_range(inorder_index + 1, right)
            return node
        return bulid_tree_from_inorder_range(0, len(inorder) - 1)

```

## 解法3:ヘルパー関数なし、元の関数で再帰
- https://github.com/hayashi-ay/leetcode/pull/43/files
- https://github.com/TORUS0818/leetcode/pull/31/files
   - 全く思いつかなかったが、元の関数で再帰＋スライスでも解けるらしい。
- スライスのインデックスを、間違えそうになるのが怖くてソワソワする。スライスって、便利だけど怖くないですか...？
- preorder の中の構造は、[根親ノード1個, 左子ノードたち, 右子ノードたち]になるらしいが、まあ、inorderの中でinorder_split_indexで真っ二つにする方が、直感的だなと感じてしまった。
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None
        root_val = preorder[0]
        inorder_split_index = inorder.index(root_val)
        root = TreeNode(root_val)
        root.left = self.buildTree(preorder[1 : 1 + inorder_split_index ], inorder[: inorder_split_index ])
        root.right = self.buildTree(preorder[1 + inorder_split_index :], inorder[inorder_split_index + 1:])
        return root
```

# Step3
- https://github.com/TORUS0818/leetcode/pull/31/files
   - 解法3でTORUSさんがやっていた「inorder_split_index」って変数名良いなと感じる。実際引き継ぐときにinorderを２つに分けるので。
- あと、node よりも root の方が良いかもと感じる。
- 上記2点の、細かい微修正をしつつ、Step2の解法1と2で再現性の確認。
- Step3の書き方がしっくりときて、何度書いても同じコードになった。
## 解法1:辞書:Accepted
- 最終的には5分ほどで実装。
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        node_val_to_inorder_index = {}
        for index, node_val in enumerate(inorder):
            node_val_to_inorder_index[node_val] = index

        preorder_index = 0
        def build_tree_from_inorder_index(left: int, right: int):
            if left > right:
                return None
            nonlocal preorder_index
            root = TreeNode(preorder[preorder_index])
            preorder_index += 1
            inorder_split_index = node_val_to_inorder_index[root.val]
            root.left = build_tree_from_inorder_index(left, inorder_split_index - 1)
            root.right = build_tree_from_inorder_index(inorder_split_index + 1, right)
            return root
        return build_tree_from_inorder_index(0, len(inorder) - 1)
```

## 解法2:inorder.index(根ノード値)の利用:Accepted
- 「はい、解いてね。」って忘れた頃に急に言われたら、おそらくこっちになるので、こちらも練習。4分くらいで実装。
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        preorder_index = 0
        def build_tree_from_inorder_index(left: int, right: int):
            if left > right:
                return None
            nonlocal preorder_index
            root = TreeNode(preorder[preorder_index])
            preorder_index += 1
            inorder_split_index = inorder.index(root.val)
            root.left = build_tree_from_inorder_index(left, inorder_split_index - 1)
            root.right = build_tree_from_inorder_index(inorder_split_index + 1, right)
            return root
        return build_tree_from_inorder_index(0, len(inorder) - 1)
```

## おまけ
- 処理内容的に、下記のように空行を空けたくなった。
- が、確かスタイルガイド的には、空行は一行以内まで「Method definitions inside a class should be surrounded by a single blank line.」だった気がする。(ので、おまけに追加した。)
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        preorder_index = 0
        def build_tree_from_inorder_index(left: int, right: int):
            if left > right:
                return None

            nonlocal preorder_index
            root = TreeNode(preorder[preorder_index])
            preorder_index += 1
            
            inorder_split_index = inorder.index(root.val)
            root.left = build_tree_from_inorder_index(left, inorder_split_index - 1)
            root.right = build_tree_from_inorder_index(inorder_split_index + 1, right)
            return root
        return build_tree_from_inorder_index(0, len(inorder) - 1)

```
