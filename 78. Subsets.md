# Step1
 - ビット全探索(競プロ用語かもしれない)なのでは？
 - 15分くらいで自力実装。嬉しい。
 - forが進むたびに、subsetリセットされるので、all_subsets.append(subset.copy())でなくて良い。
 - bit_maskって変数名、良いのか？
   - https://github.com/hayashi-ay/leetcode/pull/63/files
   - 良いかもしれない。気が合いますね。
## 解法1:ビット全探索:AC
```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        all_subsets = []
        for bit_mask in range(1 << len(nums)):
            subset = []
            for i in range(len(nums)):
                if bit_mask & (1 << i):
                    subset.append(nums[i])
            all_subsets.append(subset)
        return all_subsets
```

## 解法2:バックトラック再帰:AC
 - 前問で、pop()後に、再度子分に対して再帰すれば、解けそう？わからん。
 - https://github.com/hayashi-ay/leetcode/pull/63/files
   - こう解くのか。シンプルに一方向に舐めてみていけばよいのか。
 - 前問に引き続き、一回の再帰では、1粒選ぶことしかしない。
   - これ、意外と大事な視点かも。再帰関数がやってることは意外とシンプル。
   - https://www.nii.ac.jp/event/shimin/2018/report-6.html#:~:text=%E3%81%BE%E3%81%9A%E3%80%81%E5%B2%A9%E7%94%B0%E5%8A%A9%E6%95%99%E3%81%AF%E3%80%81%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%80%8C%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F%E3%81%9F%E3%82%81%E3%81%AE%E6%89%8B%E9%A0%86%E3%80%8D%E3%81%A8%E8%BF%B0%E3%81%B9%E3%80%81%E3%80%8C%E5%B0%8F%E5%AD%A6%E6%A0%A1%E3%81%A7%E7%BF%92%E3%81%86%E7%AD%86%E7%AE%97%E3%82%82%E3%80%81%E5%AE%9F%E3%81%AF%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E4%B8%80%E3%81%A4%E3%81%A7%E3%81%99%E3%80%82%E6%8E%9B%E3%81%91%E7%AE%97%E3%82%92%E4%B9%9D%E4%B9%9D%E3%81%BE%E3%81%A7%E3%81%97%E3%81%8B%E8%A6%9A%E3%81%88%E3%81%A6%E3%81%84%E3%81%AA%E3%81%8F%E3%81%A6%E3%82%82%E3%80%81%E7%AD%86%E7%AE%97%E3%82%92%E4%BD%BF%E3%81%88%E3%81%B0%E3%80%81%E4%BD%95%E6%A1%81%E3%81%AE%E6%8E%9B%E3%81%91%E7%AE%97%E3%81%A7%E3%82%82%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%80%81%E5%8D%98%E7%B4%94%E3%81%AA%E8%A8%88%E7%AE%97%E3%81%97%E3%81%8B%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E6%A9%9F%E6%A2%B0%E3%81%A7%E3%82%82%E3%80%81%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%82%92%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E4%BD%BF%E3%81%88%E3%81%B0%E3%80%81%E8%A4%87%E9%9B%91%E3%81%AA%E8%A8%88%E7%AE%97%E3%81%8C%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E5%90%8C%E3%81%98%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F%E3%81%AE%E3%81%AB%E3%82%82%E3%80%81%E4%BD%BF%E3%81%86%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E5%BF%85%E8%A6%81%E3%81%AA%E8%A8%88%E7%AE%97%E6%99%82%E9%96%93%E3%81%8C%E5%A4%A7%E3%81%8D%E3%81%8F%E7%95%B0%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%8F%E3%82%8B%E3%81%AE%E3%81%A7%E3%81%99%E3%80%8D%E3%81%A8%E8%AA%AC%E6%98%8E%E3%81%97%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82
   - こういうことを思うたびに、この筆算と掛け算の例を思い出しますね。再帰関数がやってるのは掛け算なんだなあと。
   - アルゴリズムと聞くとなんか大層なことやっているように聞こえなくもないが、1つ処理は、1粒選んで引き継ぐ、みたいにすごくシンプルなんですよね。
       - それでいて、マクロ的には複雑なことを達成できる二面性が、なんか良いと思います。

```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        all_subsets = []
        def traverse_nums(index: int, subset: List[int]):
            if index == len(nums):
                all_subsets.append(subset.copy())
                return
            subset.append(nums[index])
            traverse_nums(index + 1, subset)
            subset.pop()
            traverse_nums(index + 1, subset)
        traverse_nums(0, [])
        return all_subsets
```

## 解法2':バックトラック再帰:AC
 - 試しに下記のようにコードを書き換えてみる。子分への受け渡しの順序を入れ替えた。AC。
 - あれ...？ 下記のコードで、なぜ pop() が必要なのかわからなくなってしまった。(上のコードは、追加しない場合も試す必要があるのでpop()の必要性については納得なのだが...)
 - (ここからGPTを質問攻めにしたり、サーバーを漁りまくる長い格闘が始まる...)
 - https://discord.com/channels/1084280443945353267/1196472827457589338/1199999311791001671
 - https://github.com/hayashi-ay/leetcode/pull/63/files
   - この辺りにたどり着いてようやく理解した。
   - リストのようなミュータブルなオブジェクトを再帰関数の引数に渡すと、たくさん発生する関数呼び出し(再帰スタックツリー)の間で、同じ1つのリストオブジェクトを参照してしまうのが原因のようだった。怖すぎる副作用だ。
   - (!直感的整理!)深いところまで探索すると、リストを深い状態まで連れてきて更新してしまうので、深いところの探索が終了して浅いところに戻る際に、pop()みたいなバックトラックの処理が必要なのね。
   - 対応策 :
       - 関数の引数に渡すと、同じ1つのリストオブジェクトが複数の再帰関数から参照されることがわかりづらいので、hayashiさんのコードのように関数の外部変数としてリストをおいておく方が自然な感じ・明示的・デバッグもしやすそうで良い。これがベストかも。
       - https://discord.com/channels/1084280443945353267/1196472827457589338/1200798108259450940
           - あるいは、こんな感じで再帰関数に処理を渡すときに、新規にリストオブジェクトを生成して関数の引数に渡すのでも、一応良さそう。
               - メリット : 引数にミュータブルなリストを渡しているのにバックトラックが不要。(複数の関数呼び出し(再帰スタックツリー)のに対して、それぞれ個別にリストオブジェクトを生成するため。)
               - デメリット : 再帰関数呼び出しごとの、新規生成分のメモリ量が無駄。
 - 一方で、intのようなイミュータブルなオブジェクトが関数の引数に渡されるときの整理 :
    - 関数が呼ばれた際には、同一オブジェクトに紐づく変数名(名前空間)のみ複製コピーが行われて関数呼び出し元/関数内部の両方において、別々の名前空間(変数名)から同じオブジェクトを参照している。(ここはリストオブジェクトの場合などと同様。)
    - しかし、関数内部で代入などの処理が行われると、整数型オブジェクトはイミュータブルなので、関数内部の方の名前空間(変数名)は、元々のオブジェクトへの紐付きバインドから解放されて、代入処理の右辺の評価によって新たに生成された別の整数オブジェクトに対して、新しく紐づいてバインドされるという処理がなされる。(一方で、関数呼び出し元の変数名のバインドはそのままの状態になる。)
    - つまり、たくさん発生する関数呼び出し(再帰スタックツリー)の間で同じオブジェクト参照をすることなく、関数の呼び出しごとの単位で、別々で独立に整数オブジェクトを管理できそう。
    - 実装面では、バックトラックが不要になるので考慮しなくて良さそう。ありがたいですね...
    - https://leetcode.com/problems/path-sum/
       - この問題で、helper 関数の引数に total 渡していた時はこんなこと考えずに書いてしまっていたが、内部ではこういうことが起きるおかげでうまくいっていたのか...
```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        all_subsets = []
        subset = []
        def traverse_nums(from_index):
            if from_index == len(nums):
                all_subsets.append(subset.copy())
                return
            traverse_nums(from_index + 1)
            subset.append(nums[from_index])
            traverse_nums(from_index + 1)
            subset.pop()
        traverse_nums(0)
        return all_subsets
```
        
 - 書いてみた後の感想:
   - subset は再帰関数間で共有参照されるので、関数外部にあっても良いかなと感じて書いたが、書いてみると、2回目の traverse_nums(from_index + 1) の意図が伝わりづらいと感じた。
   - subset が関数の引数にあった方が、subset を変更した上で別の種類の再帰呼び出しをしていることが明示的になると感じた。
   - う〜ん、必ずしも、複数の再帰関数から共有参照されるリストを、関数外部に配置することがベストではないのかもしれないです...
 - 総合的に良いのは解法2のコードなのではと感じる。2回目の traverse_nums(index + 1, subset) の意図もわかりやすいし、pop()を最後ではなく先にする方がより直感的なので。
   - (pop()については先でも最後でもsubset.pop()でバックトラックしなきゃなので必ず必要ではあるのですが...)

# Step2
 - PR見ていく。
## 解法3:スタック:AC
 - https://github.com/hayashi-ay/leetcode/pull/63/files
   - スタックでも書こうか。 
 - https://discord.com/channels/1084280443945353267/1233603535862628432/1238707903196565546
   - やっぱり、このイメージが的確で分かりやすい。
```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        all_subsets = []
        stack = [([], 0)]
        while stack:
            subset, index = stack.pop()
            if index == len(nums):
                all_subsets.append(subset)
                continue
            stack.append((subset, index + 1))
            stack.append((subset + [nums[index]], index + 1))
        return all_subsets
```

 - https://github.com/Ryotaro25/leetcode_first60/pull/55/files#r1986237801
   - 私はforがない方が好きかも。なぜそのタイミングで追加して良いのかの理由が、読めない。
       - https://github.com/fhiyo/leetcode/pull/51/files
       - 「indexが末尾に到達する前にyieldしているのが個人的には分かりにくい。」
           - 同じ感情です。
   - forも再起呼び出しも、動いていたものがある地点で止まるということが起こるので、ここはなるべくシンプルな構成になしたい。
   - あと、選ぶ/選ばないで、再起呼び出しを分岐して行うのが対称性があって好きというのもありますね。等価なものは同じ粒で揃えて書きたいです。
 - https://github.com/fhiyo/leetcode/pull/51/files#r1688238102
   - yield、処理の途中で出力して、再度途中から処理を再開する、ということなのでしょうが、同じくちょっと読みづらいと感じた。 
 - https://github.com/nittoco/leetcode/pull/19/files#r1644763510
   - 「全ての再帰関数は、同じロジックを用いたまま、ループで書き直すことができます。」
   - え、マジですか？結構衝撃。書けるんだ。「この再帰もループで書けるはず」と思うことで、選択肢を広げることができそうだと感じる。 
 - https://github.com/hayashi-ay/leetcode/pull/63/files
   - これの、3rd、どうなってるんだ。わからん。多分本番では書けない。シンプルなのですが、直感に反しすぎるものは書けない気がする...

# Step3
 - 再現性の確認をする。どの方法でやろうかな。
 - ビット全探索は、自然に書けたし今回はいいかな。
 - バックトラックへの意識を練習するには、解法2より解法2'の方が良いので、解法2'でやる。
 - 解法3のスタックのループ処理も書く。
## 解法2':バックトラック再帰:AC
 - 次の問題も見ている影響か、追加バージョンの再起呼び出しのインデックスを index で書いてミスが起きた。今回は足踏み不要なので index + 1 で書けばよろしい。
 - やっぱり、等価な場合分けをして2回に分けて再起呼び出しするのが、対称性があって好きですね。見た目も綺麗だし、頭にもスッと入りますね。親分視点から二人の弟子がいる景色が見えていい感じです。
```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
            all_subsets = []
            def traverse_nums(index, subset):
                if index == len(nums):
                    all_subsets.append(subset.copy())
                    return
                traverse_nums(index + 1, subset)
                subset.append(nums[index])
                traverse_nums(index + 1, subset)
                subset.pop()
            traverse_nums(0, [])
            return all_subsets
```

## 解法3:スタック:AC
 - index + 1 と書くと、変数にバインドしてないものの、ああ、ここで、新しいミュータブルな整数オブジェクトを生成しているんだなあという気持ちになった。(しみじみ)
 - リストを連結するので、+ [nums[index]] と書くことが必要。+ nums[index]はダメ。
```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        all_subsets = []
        stack = [(0, [])]
        while stack:
            index, subset = stack.pop()
            if index == len(nums):
                all_subsets.append(subset)
                continue
            stack.append((index + 1, subset))
            added_subset = subset + [nums[index]]
            stack.append((index + 1, added_subset))
        return all_subsets
```
