# Step1
- アドレスを、固有キーアドレスに変換して、集合で管理すれば良さそう。「49. Group Anagrams」と似た考え方。
- 文字列の末尾への文字追加方法と、「"文字列".find()」メソッドを、忘れてしまったので調べる。それ以外は何とか自分で書けた。
- findメソッドのドキュメントを見てみた。
https://docs.python.org/3/library/stdtypes.html#str.find

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        key_address_set = set()
        for address in emails:
            key_address = ""
            for char in address:
                if char == '@':
                    break
                if char == '+':
                    break
                if char == '.':
                    continue
                key_address += char         #-文字列の末尾への文字追加は「+=」。
            index_of_atmark = address.find('@')
            key_address += address[index_of_atmark:]
            key_address_set.add(key_address)
        
        return len(key_address_set)
```

# Step2
- PRを色々見てみる。
- 「.split()」「.replace()」を使う解法、正規表現などがあるようだった。
- 「.split()」「.replace()」のドキュメント読んでみる。便利だ。
https://docs.python.org/3/library/stdtypes.html#str.split
https://docs.python.org/3/library/stdtypes.html#str.replace

- このコードがわかりやすい。一行ずつ段階に分けて、変数名を変えながら、順に必要な処理をしている。こう書くと何をしているかが追いやすいのではと感じた。
https://github.com/tarinaihitori/leetcode/pull/14/files

- 変数名、key_addressだと、キーから辞書を連想するのではと思い、unique_addressとかの方が良いかなと感じる。

## 解法１：「.split()」「.replace()」利用
```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_address = set()
        for address in emails:
            local_name, domain_name = address.split('@')
            plus_ignored_local_name = local_name.split('+', maxsplit=1)[0]  #返り値は、分割されたリスト。
            #plus_ignored_local_name, _ = local_name.split('+', maxsplit=1)　はRE。「+」が存在しない時にも、２要素をアンパックしようとしてしまうため。
            dot_removed_local_name = plus_ignored_local_name.replace('.', '') #replace('変更前', '変更後')
            unique_address.add(dot_removed_local_name + '@' + domain_name)  #集合への追加はadd
        return len(unique_address)
```

## 解法２：正規表現
#正規表現について、何も知らなかったのでドキュメントなど色々見てみる。           
https://docs.python.org/ja/3/library/re.html#re.sub
- 「r'~~~'」はPythonに生のテキスト(生文字列)を渡したい時に使う。（これをしないと「\」を特別な文字(エスケープ文字)として扱ってしまう。例：「\n」で改行など）
- 一方で、正規表現内では、「.」は直前の0回以上の繰り返し、「+」は直前の1回以上の繰り返し、という特別な意味がある。今回それぞれを純粋な文字として扱いたいので「\」を使う。
- 正規表現内で「.」は「任意の1文字」という意味、「.*」は「任意の文字（.）が0回以上（*）繰り返される」という意味で、つまり、「任意の文字列」という解釈になる。
```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_address_set = set()
        for address in emails:
            local, domain = address.split('@')
            plus_ignored_local = re.sub(r'\+.*', '', local) #「+」以降の文字列を丸ごと、空文字''にする。つまり「+」以降を削除。
            dot_removed_local = re.sub(r'\.', '', plus_ignored_local)   #「.」を空文字''に変換。つまり「.」を削除。
            unique_address_set.add(dot_removed_local + '@' + domain)
        return len(unique_address_set)
```

# Step3
- 解法１と解法２で練習して再現性の確認
- 記述量は、どっちも同じくらい。甲乙つけ難いが、個人的には、解法１の方が組み込み関数利用しているし、オーソドックスなのではということで、なんとなく好み。
## 解法１：「.split()」「.replace()」利用：AC：2分半くらい
```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_address_set = set()
        for mail in emails:
            local, domain = mail.split('@')
            plus_ignored_local = local.split('+', maxsplit=1)[0]
            dots_removed_local = plus_ignored_local.replace('.', '')
            unique_address_set.add(dots_removed_local + '@' + domain)
        return len(unique_address_set)
```

## 解法２：正規表現：２分くらい
```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_address_set = set()
        for mail in emails:
            local, domain = mail.split('@')
            plus_ignored_local = re.sub(r'\+.*', '', local)
            dots_removed_local = re.sub(r'\.', '', plus_ignored_local)
            unique_address_set.add(dots_removed_local + '@' + domain)
        return len(unique_address_set)
```
