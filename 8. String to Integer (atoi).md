# Step1
 - ぱっと見どういう問題なのかよくわからなかった(国語力)。string sを読み込んで数値に変換する感じなのかな。
 - 今まで解いたことがない問題という感触で、方針が立たないので解法見てしまった。
 - https://github.com/hayashi-ay/leetcode/pull/69/files
 - https://github.com/hayashi-ay/leetcode/pull/69#discussion_r1548093970
   - https://discord.com/channels/1084280443945353267/1340120243506384917/1343412529337991213
   - なるほど。将棋AI個人開発で、盤面の状態を表すSFEN文字列を、"パース"して、盤面をセットする、ということをしていたが、これと近いことをやってそう。
 - あ、問題文に書いてある1.～4.に沿って、順に実装していけばよいのか。実は丁寧な誘導がついてくれていた。
 - 符号処理は数値の構築とは分離して最後にするのでも良いのではと思ったが、値の正負によって丸めの閾値が違うので、数値を構築するときに符号処理も同時並行でやった方が良さそうかもしれないと感じた。
   - https://github.com/hayashi-ay/leetcode/pull/69/files#diff-f2b395d63173ac2f2d3c547e8f9e8e07c9acfbeb6b5da935bb28d83d8bcc7a04R99
   - 同じようなコメントが書いてあった。 
## 解法1:indexを進めていく:AC
```py
class Solution:
    def myAtoi(self, s: str) -> int:
        # 1.Whitespace
        index = 0
        while index < len(s) and s[index] == " ":
            index += 1
        if index == len(s):
            return 0
        
        # 2. Signedness
        sign = 1
        if s[index] == "-" or s[index] == "+":
            if s[index] == "-":
                sign *= -1
            index += 1
        if index == len(s):
            return 0

        # 3. Conversion
        MAX_INT = 2 ** 31 - 1
        MIN_INT = - 2 ** 31
        while index < len(s) and s[index] == "0":
            index += 1
        num = 0
        while index < len(s) and s[index].isdigit():
            num = num * 10 + sign * int(s[index])
        # 4. Rounding    
            if num > MAX_INT:
                return MAX_INT
            if num < MIN_INT:
                return MIN_INT
            index += 1

        return num
```
- 参考PR：
 - https://github.com/shining-ai/leetcode/tree/main/arai60/54-60_others/59_8_String%20to%20Integer%20(atoi)
 - https://github.com/hayashi-ay/leetcode/pull/69/files
 - https://github.com/Ryotaro25/leetcode_first60/pull/64
 - https://github.com/philip82148/leetcode-arai60/pull/6
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/64
 - https://github.com/fhiyo/leetcode/pull/57
 - https://github.com/Mike0121/LeetCode/pull/23

# Step2
 - https://github.com/hayashi-ay/leetcode/pull/69/files#diff-f2b395d63173ac2f2d3c547e8f9e8e07c9acfbeb6b5da935bb28d83d8bcc7a04R55
   - 「32-bits環境だと（1 << 31)をした時点でオーバーフローする」
   - これは怖いですね。MAX_INTはギリギリの値なんだなあと。
 - https://github.com/hayashi-ay/leetcode/pull/69/files#diff-f2b395d63173ac2f2d3c547e8f9e8e07c9acfbeb6b5da935bb28d83d8bcc7a04R138
   - 「`ord(s[pos]) - ord('0')`の代わりに`int(s[pos])`とかも選択肢としてあり。とはいえこれをするんだったら`int(s[index:])`みたいにやっていいじゃんという気持ちにもなるので、この問題的にはint使わない方が空気が読めてそう。」
   - https://docs.python.org/3/library/functions.html#ord
   - https://note.nkmk.me/python-chr-ord-unicode-code-point/#unicode-ord
       - Unicodeポイント = 文字に一意に割り当てられた整数ID
       - 1文字を変換して、1整数を返すのが、ord()という子なのですね。
       - digit = ord(s[pos]) - ord('0')という形で、数値を取得できるのは、Unicodeポイントが差1の等差数列になっていて、数字としての文字列が1増えると、Unocodeポイントも1だけ増えるように、増加量が一致しているかららしい。
   - https://docs.python.org/3/library/functions.html#int
       - int()の方は、 文字列を数値として解析していて、空白チェックや入力が str かどうかチェックしていたりするので、汎用的に広い処理をしているようだった。
       - 便利・汎用すぎるので、確かに今回の問題で使うのは空気が読めてない感じがあるのは納得した。
   - https://github.com/fhiyo/leetcode/pull/57/files#r1738608010
       - 「大した理由は無くint()でも全然良いんですが、'0'-'9'のUnicode文字1つを数字に直すならこっちの方が多少自然かな？と思ったからですね。」
       - ここでも同じようなことが言われている。やっぱそうですよね。
   - https://github.com/Ryotaro25/leetcode_first60/pull/64/files#diff-4d65a16d7dcb4ddd736f444c1721b5dc53e97518dd7101cfbcc4a81453dab075R37-R38
       - C++は int() 使えないらしい。他の言語の仕様も考えると、ord()使って Unicode にする方が無難なのではと感じた。
 - https://github.com/shining-ai/leetcode/tree/main/arai60/54-60_others/59_8_String%20to%20Integer%20(atoi)
 - https://github.com/fhiyo/leetcode/pull/57/files
   - 個人的には関数でおくよりも、処理ごとに(空行開けるなどして)ブロックに分けて index を動かして行った方が、工場の流れ作業感があって、見通しが良い気がする。
 - https://github.com/fhiyo/leetcode/pull/57/commits/981cf81c9c82ed22dcc53f6d17e8a2364b32bc92#diff-894cc3001733b95624e0b4f683c9bd643d1f76648a0a2799a0184bd2c2d869a6R12-R13
   - 「[0-9]以外もTrueにするやつがいくつかあったと思うので使うのを止めておいた」
   - 「`ord('0') <= ord(c) <= ord('9')` とする方が列挙せず済むので目に優しいか 」
   - isdigit()の副作用があるらしい。ここの数値判定でも、ord()使うのが無難そうかも。
 - https://docs.python.org/3/library/stdtypes.html#bytearray.lstrip
   - lstrip という便利なものもあるのか。でも今回は、int()同様、素朴な方法でやりたい気がする。
 - https://github.com/Mike0121/LeetCode/pull/23/files#diff-09d4316283c7e0d346129061debcf5f22dd7dccc2ef39c5e7f5cd9e5b35efd25R59-R60
   - 各変数の宣言の位置ですが、個人的にはそれが必要になった直前の地点で宣言したいですね。
 - https://github.com/Mike0121/LeetCode/pull/23/files#diff-09d4316283c7e0d346129061debcf5f22dd7dccc2ef39c5e7f5cd9e5b35efd25R71
   - 符号は、代入でもいいんですが、-1 かけて反転させる方が直感的かもしれないと感じた。
 - https://github.com/Mike0121/LeetCode/pull/23/files#diff-09d4316283c7e0d346129061debcf5f22dd7dccc2ef39c5e7f5cd9e5b35efd25R78
 - https://github.com/hayashi-ay/leetcode/pull/69/files#diff-f2b395d63173ac2f2d3c547e8f9e8e07c9acfbeb6b5da935bb28d83d8bcc7a04R128
   - digit 使う方が丁寧かもしれない。 

## 解法1:indexを進めていく:AC
 - 桁の数字計算とisdigit()の代用として、ord()を使う。
 - digitという変数を使う。
 - 縦に長いので、コメントが欲しいと思った。

```py
class Solution:
    def myAtoi(self, s: str) -> int:
        index = 0
        #1. Whitespace
        while index < len(s) and s[index] == " ":
            index += 1
        if index == len(s):
            return 0

        #2. Signedness
        sign = 1
        if s[index] == "+" or s[index] == "-":
            if s[index] == "-":
                sign *= -1
            index += 1
        if index == len(s):
            return 0
        
        # 3. Conversion
        MAX_INT = 2 ** 31 - 1
        MIN_INT = -2 ** 31
        num = 0
        while index < len(s) and ord('0') <= ord(s[index]) <= ord('9'):
            digit = ord(s[index]) - ord('0')
            num = num * 10 + digit * sign
            # 4. Rounding
            if num > MAX_INT:
                return MAX_INT
            if num < MIN_INT:
                return MIN_INT
            index += 1
        return num
```

# Step3
 - 再現性の確認
 - https://github.com/hayashi-ay/leetcode/pull/69/files#diff-f2b395d63173ac2f2d3c547e8f9e8e07c9acfbeb6b5da935bb28d83d8bcc7a04R183
 - https://peps.python.org/pep-0020/#:~:text=Flat%20is%20better%20than%20nested.
   - 符号処理はこう書く方がいいかも。ネストさせない方がいいですね。
 - 今回は、while の中で index の len(s)未満チェックをしたが、個人的に範囲外インデックスのエラーが多めなので、こういったことを書くことは習慣にしたい。
```py
class Solution:
    def myAtoi(self, s: str) -> int:
        index = 0
        #1. skip whitespace
        while index < len(s) and s[index] == " ":
            index += 1
        if index == len(s):
            return 0
        
        #2. decide sign(+/-)
        sign = 1
        if s[index] == "+":
            index += 1
        elif s[index] == "-":
            sign *= -1
            index += 1

        # 3. conversion to integer
        num = 0
        MAX_INT = 2 ** 31 - 1
        MIN_INT = -2 ** 31
        while index < len(s) and ord('0') <= ord(s[index]) <= ord('9'):
            digit = ord(s[index]) - ord('0')
            num = num * 10 + sign * digit
            # 4. rounding
            if num > MAX_INT:
                return MAX_INT
            if num < MIN_INT:
                return MIN_INT
            index += 1
        return num

```
