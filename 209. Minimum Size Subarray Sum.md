# Step1
 - 前問のように、連続部分列の問題は Sliding Window と相性が良さそう。伸び縮みさせてくぞ〜
 - [left, right]と区間をセットする。和が target になるまで、right を右に進める。
 - 和が target と同じになったら min_length の更新をする。
 - 和が target より大きくなったら、min_length の更新をしつつ、left を進めて、貪欲に min_length の更新にトライする。
 - 自力で10分くらいで実装でき、ACになった。うれしい。
 - 実装中に詰まって自己修正したポイント:
   - 最初書いたときは、while よりも if を先に書いていたが。WAになった。
   - そこでテストケース(case1)を脳内シミュレーションしたら、while 抜けた後にも、prefix_sum == target になることがあり、ここでも if チェックすべきだと気づいたので、if を後にする形で順番を入れ替えた。
   - 例のごとく、return 0 の時の処理を失念していたので、追記した。
 - min_length は0以上の整数なので、番兵的なイメージで初期値を sys.maxsize にした。
## 解法1:Sliding Window:AC
```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        prefix_sum = 0
        min_length = sys.maxsize

        for right in range(len(nums)):
            prefix_sum += nums[right]
            while prefix_sum > target:
                min_length = min(min_length, right - left + 1)
                prefix_sum -= nums[left]
                left += 1
            if prefix_sum == target:
                min_length = min(min_length, right - left + 1)

        if min_length != sys.maxsize:
            return min_length
        else:
            return 0
```

 - これを、GPTに添削してもらう。
## 解法1:Sliding Window:AC
 - いや、whileの条件式を >= にすればifいらないじゃん。前問と同じように行けるとこまで削ればOK。
   - (!個人的重要ポイント!)prefix_sum >= target みたいな欲しい条件をキャッチするのは if の専売特許のイメージだったが、whileもこれカバーしてるじゃん、と今更ながら理解した。しつこい if というイメージが良いかも。これまで、if と while を全くの別物という変な見方をしていた気がする。
   - min_length の更新をして良いのは、prefix_sum >= target が保証されている時なので、while の直下に更新の処理を書いてあげる。
   - あと、今考えている部分累積和が target に等しい時は、そのときの left においては、最適解の長さになっているので、もう left の固定解除して次の最適解を探しに行ってOKなときですね。二変数関数みたいだ。
```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        prefix_sum = 0
        min_length = sys.maxsize

        for right in range(len(nums)):
            prefix_sum += nums[right]
            while prefix_sum >= target:
                min_length = min(min_length, right - left + 1)
                prefix_sum -= nums[left]
                left += 1

        if min_length != sys.maxsize:
            return min_length
        else:
            return 0
```
 - 考えているのが部分的な累積和なので、prefix_sum よりも sub_prefix_sum とかの方が読みやすいだろうか。どっちでも良いか。
# Step2
 - PR見ていく。
 - https://github.com/hayashi-ay/leetcode/pull/51/files
   - 4thのコードとほぼ同じだった。良い感じかも。
   - あ、min_lengthの初期値、len(nums)で良いのかも。
       - https://github.com/olsen-blue/Arai60/pull/44/files
       - 私って、初期値の設定が適当がちな傾向あるかも。気をつけたい。 
   - ん？やっぱダメでは？ target = 4, nums = [1, 1, 1]のとき、len(nums)=3を返すが、これは0を返さなければならないはず。
   - あ、早期returnが必要になるのか。う〜ん、なら初期値 sys.maxsize でいいのかも。
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/43/files
   - 「tailを基準にして、headをwhileで動かすようにすればよかった」 
   - 同じ感覚かも。for で right 固定して、while で left を削るイメージ。前問のコードも、このイメージで書くのが好きでした。
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/43/files
   - NOT_FOUND = sys.maxsize とやるべきなのだろうか。個人的には、math.inf や sys.maxsize がマジックナンバーでないと感じる派です。最適化前の初期値というイメージがある。とはいえ、周囲にこの認識がなければ、適切な名前をセットすべきだと感じる。
 - https://github.com/fhiyo/leetcode/pull/49/files#r1685369428
   - 「math.inf など"明らかにおかしいもの"で初期化しておくとよさそうに思いました。」
       - そうですね。僕も敢えてわかりやすい異物を突っ込んでる感覚あります。
   - 「math.inf, 型がfloatなのがちょっと気になるんですよね...使うメリットはあるので選択肢としてありだとは思いますが。」
       - この辺りわかる。とりあえず sys.maxsize にすれば良いのでは。
   - 左端をforで回す解法、直感的でない。
       - right 固定して、ギリギリまで left 詰める、というのが自然言語的に最も自然に感じる。
   - 累積和、今回はインデックス不要なのではと思う。[left, right] の区間部分の和なので。インデックス使うとややこしい気がする。
## 解法2:二分探索(bisect_left):AC
 - https://github.com/hayashi-ay/leetcode/pull/51/files
 - https://github.com/fhiyo/leetcode/pull/49/files
 - https://github.com/Mike0121/LeetCode/pull/22/files
   - 二分探索あるのか。やりたい。
   - そうか、累積和の配列作れば、問題設定的に単調増加なので、二分探索いけますね。
   - numsの先頭要素も、累積和の差で求められるようにするには、prefix_sums を 1-indexed にして、prefix_sums[0] = 0が必要。
       - nums と prefix_sums のインデックスがずれてるのがややこしい。う〜ん、ちょっと嫌だが仕方がない。
       - でも、prefix_sums を構築してしまえば、あとは nums のこと考えずに済んでるから、問題ないか...！
 - bisect_leftの挿入位置が、配列(prefix_sums)のケツ(リスト範囲外)のときは、それ以上 from_index を右に進める必要がないので、breakで良い。
   - https://docs.python.org/3/library/bisect.html#bisect.bisect_left
```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        prefix_sums = [0] * (len(nums) + 1)
        for i in range(1, len(nums) + 1):
            prefix_sums[i] = prefix_sums[i-1] + nums[i-1]

        min_length = sys.maxsize
        for from_index in range(len(prefix_sums)):
            target_sum = prefix_sums[from_index] + target
            target_index = bisect.bisect_left(prefix_sums, target_sum)
            if target_index == len(prefix_sums):
                break
            min_length = min(min_length, target_index - from_index)

        if min_length == sys.maxsize:
            return 0
        return min_length
```
 - https://github.com/hayashi-ay/leetcode/pull/51/files
   - 二分探索のコードは、色々みたが、これが一番しっくりきた。
       - 強いてコメントするなら、target_prefix_sum = target + prefix_sums[i] よりも target_prefix_sum = prefix_sums[i] + target　と書きたい。
           - new_A = A + dA みたいな感じが好きなので。
       - あと、math.infよりは、sys.maxsize の方が、min_length の型が伝わるので、良いと感じる。

## (おまけ)解法3:辞書+ループ:WA
 - https://leetcode.com/problems/subarray-sum-equals-k/description/
   - これと同じノリでも解けるのでは。位置が大事なので、頻度ではなくインデックスを辞書管理かな。
   - と、思ったが、これはピッタリ差が target になるものを求めてしまっている。テストケースのみ通ったが、WAだった。(書き終わってから気づいた。)
```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        prefix_sum_to_index = {}
        prefix_sum_to_index[0] = -1
        prefix_sum = 0
        min_length = sys.maxsize
        for i in range(len(nums)):
            prefix_sum += nums[i]
            complement_prefix_sum = prefix_sum - target
            if complement_prefix_sum in prefix_sum_to_index:
                complement_index = prefix_sum_to_index[complement_prefix_sum]
                min_length = min(min_length, i - complement_index)
            prefix_sum_to_index[prefix_sum] = i
        
        if min_length == sys.maxsize:
            return 0
        return min_length
```

# Step3
 - 再現性の確認。
## 解法1:Sliding Window:AC
 - 前問と同じ感想ですが、right を固定して、left で削ってなるべく小さくする感覚がしっくりくるのが好き。
   - 前問のようにset()とか考えない分こちらの方がシンプル。削ると累積和が小さくなるのが直感的。
   - https://github.com/goto-untrapped/Arai60/pull/40/files#r1685435343
       - ここまで書いて、numsに負の数があると、大丈夫ではないことがわかった。削れば小さくなるぜ、というのが通用しなくなる。
       - 解法2でも、累積和の単調増加の性質が前提なので、大丈夫じゃなさそうですねえ...
 - while にも、if みたいな欲しい条件をキャッチするという機能があることを意識すると、気分よく while と min_length の更新式を書くことができた。
   - これがないと、多分 if 文を書き始めてしまうことになる。
   - if と違ってしつこくキャッチし続けるのが while の違い。
 - 最終的に3分くらい実装。
```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        prefix_sum = 0
        min_length = sys.maxsize
        for right in range(len(nums)):
            prefix_sum += nums[right]
            while prefix_sum >= target:
                min_length = min(min_length, right - left + 1)
                prefix_sum -= nums[left]
                left += 1
        if min_length == sys.maxsize:
            return 0
        return min_length
```

## 解法2:二分探索(bisect_left):AC
 - 初見の時は、nums と prefix_sums のインデックスが 0-indexed vs 1-indexed とでずれていて違和感があったが、prefix_sums を構築してしまえば、あとは nums のこと考えずに prefix_sums の世界だけで話が完結してくれるのがありがたいと感じるようになった。
   - ただし、prefix_sums[0] が 0 になるようにする必要がある。(累積和の値が 0 の番兵)
 - 今回の bisect_left は、リストの値をキーとして挿入位置を求めるので、key=がいらない。
   - https://github.com/olsen-blue/Arai60/pull/43/files
       -　これも復習しておこう。
 - 4分くらいで実装。
```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        prefix_sums = [0] * (len(nums) + 1)
        for i in range(1, len(nums) + 1):
            prefix_sums[i] = prefix_sums[i-1] + nums[i-1]
        
        min_length = sys.maxsize
        for from_index in range(len(prefix_sums)):
            target_sum = prefix_sums[from_index] + target
            target_index = bisect.bisect_left(prefix_sums, target_sum)
            if target_index == len(prefix_sums):
                break
            min_length = min(min_length, target_index - from_index)
        if min_length == sys.maxsize:
            return 0
        return min_length
```
