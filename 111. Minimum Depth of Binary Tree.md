# Step1
- 前問同様、まずDFSを検討。
## 解法１：DFS：WA
- case2の一直線状の連結ノードのときにWAになっている。片方のみの子ノード（left or right）が１つのみ存在するときがうまく考慮できていないと分かった。
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        node = root
        if not node.left and not node.right:
            return 1
        return 1 + min(self.minDepth(node.left), self.minDepth(node.right))
```
## 解法１：DFS：AC
- 修正してAC。
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        node = root
        if not node:
            return 0
        
        if not node.left and not node.right:
            return 1
        elif not node.left and node.right:
            return 1 + self.minDepth(node.right)
        elif node.left and not node.right:
            return 1 + self.minDepth(node.left)
        else:
            return 1 + min(self.minDepth(node.left), self.minDepth(node.right))
```
## 解法２：BFS：AC
- 自力AC。BFSだと、ほぼ前問と同じ頭の使い方で解けるとわかった。
- 階層深さごとにノードを見ていき、子ノードが２つとも持たないノードが発見され次第、その時点での深さを返せば（return depthすれば）良いため。
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        node = root
        depth = 0
        nodes_depth = [node]
        while nodes_depth:
            depth += 1
            nodes_next_depth = []
            for node in nodes_depth:
                if not node.left and not node.right:
                    return depth
                elif node.left and not node.right:
                    nodes_next_depth.append(node.left)
                elif not node.left and node.right:
                    nodes_next_depth.append(node.right)
                else:
                    nodes_next_depth.append(node.left)
                    nodes_next_depth.append(node.right)
            nodes_depth = nodes_next_depth
```
# Step2
- PR見てみる。前問同様、解法ロジックは同じようにBFS、DFSが多かった。
- depth使って良いのか自信がなかったが、書いている人がいらっしゃった。いくらか安心した。
- https://github.com/tarinaihitori/leetcode/pull/22/files
## 解法１：DFS：AC
- これでも良いのですが、なんか、場合分け多くて好みではないなという感覚。BFSの方が直感的。
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        node = root
        if not node:
            return 0

        if not node.left and not node.right:
            return 1
        elif node.left and not node.right:
            return 1 + self.minDepth(node.left)
        elif not node.left and node.right:
            return 1 + self.minDepth(node.right)
        else:
            return 1 + min(self.minDepth(node.left), self.minDepth(node.right))
```

## 解法２：BFS：AC
- 「node_in_next_depth」という変数名に修正。
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        node = root
        depth = 0
        nodes_in_depth = [node]
        while nodes_in_depth:
            depth += 1
            nodes_in_next_depth = []
            for node in nodes_in_depth:
                if not node.left and not node.right:
                    return depth
                elif node.left and not node.right:
                    nodes_in_next_depth.append(node.left)
                elif not node.left and node.right:
                    nodes_in_next_depth.append(node.right)
                else:
                    nodes_in_next_depth.append(node.left)
                    nodes_in_next_depth.append(node.right)
            nodes_in_depth = nodes_in_next_depth
```

# Step3
- 再現性の確認。3分ほどで書けた。
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        node = root
        if not node:
            return 0

        if not node.left and not node.right:
            return 1
        elif node.left and not node.right:
            return 1 + self.minDepth(node.left)
        elif not node.left and node.right:
            return 1 + self.minDepth(node.right)
        else:
            return 1 + min(self.minDepth(node.left), self.minDepth(node.right))
```
## 解法２：BFS：AC
- 4分ほどで書けた。
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        depth = 0
        nodes_in_depth = [root]
        while nodes_in_depth:
            depth += 1
            nodes_in_next_depth = []
            for node in nodes_in_depth:
                if not node.left and not node.right:
                    return depth
                elif node.left and not node.right:
                    nodes_in_next_depth.append(node.left)
                elif not node.left and node.right:
                    nodes_in_next_depth.append(node.right)
                else:
                    nodes_in_next_depth.append(node.left)
                    nodes_in_next_depth.append(node.right)
                nodes_in_depth = nodes_in_next_depth
        return depth
```
