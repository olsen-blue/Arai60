# Step1
- 直感的にはDFSの挙動。なのでDFSで解きたい。
- OKの基底条件は、両方の子ノードがない時。この時に targetSum と等しいかどうか確認すればOK。
- 今回は、DFSの関数に、引数としてカウント累積用の変数を持たせる必要がありそう。
- トップダウンの再帰であること、再起スタックを意識して書く。
- NGの場合の基底条件も必要ですね。
- 「total == targetSum」を、andで繋げるか、２つifを用意するかが悩ましかった。
- 少しくらいならネストが深くなることをあんまり悪いことだと思っておらず（とはいえ浅いほうがベター）、逆に and 続けて条件式が横長になることの方が好きになれない感覚がある。

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        def is_valid_path(node, total) -> bool:
            if not node:
                return False
            total += node.val
            if not node.left and not node.right:
                if total == targetSum:
                    return True
            return is_valid_path(node.left, total) or is_valid_path(node.right, total)
        return is_valid_path(root, 0)
```

# Step2
- total不要・関数1個で済むという、targetSumを引き算する解法発見。同じことを実現するならよりシンプルな方が好きなので、惹かれる。
   - https://github.com/hayashi-ay/leetcode/pull/30/files
   - https://github.com/Ryotaro25/leetcode_first60/pull/27/files
- あ、でも、targetSum っていうのは、目標の数値という意味がありそうなので、これは変数ではなく、固定値であって欲しいという気持ちが湧いてきた。
- かなり悩ましいが、ここの違和感と、totalを積み重ねて大きくなりながら突き進むDFSの挙動が好き(個人的感情)なので、今のままでも良いかなと感じる。
- 「return total == targetSum」って書けば if いらないことに気づく。ただ、「return False」と「return True」を併記する対称性が崩れることに関してだけは、後ろ髪を引かれる。最終的には、ここの対称性へのこだわりよりも、ネスト軽くするほうが(僅差で)魅力的に感じた。
- あ、再帰の深さ考えてなかった。。。sys.setrecursionlimit(5009)します...
- ノードが団子上に一直線になる最悪の場合を想定して5000、若干のバッファーをもたせて「5009」とした。
   - https://github.com/SuperHotDogCat/coding-interview/pull/37/files#r1661773635
- BFSで解いている解法もあったが、個人的に、この問題に対しては直感的でないので、別の機会とする。
- (＊気づき＊)早期returnの基底条件は、「最初から抜け漏れなく基底条件揃えなきゃ！」という気分よりも、「あ、ここで必要だな」と思ったタイミングで書くと、スムーズに自然と書けるということに気づいた。変数を、必要なタイミングの直前になって用意するのと同じ感覚でしょうか。
```python
import sys
sys.setrecursionlimit(5009)
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        def is_valid_path(node, total) -> bool:
            if not node:
                return False
            total += node.val
            if not node.left and not node.right:
                return total == targetSum
            return is_valid_path(node.left, total) or is_valid_path(node.right, total)
        return is_valid_path(root, 0)
```

# Step3
- 再現性の確認。最終的に2分で実装。
- 「is_valid_path」と書けば、返り値が bool であることは伝わるのではと感じ、「-> bool」」は省略してみた。
```python
import sys
sys.setrecursionlimit(5009)
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        def is_valid_path(node, total):
            if not node:
                return False
            total += node.val
            if not node.left and not node.right:
                return total == targetSum
            return is_valid_path(node.left, total) or is_valid_path(node.right, total)
        return is_valid_path(root, 0)
```
