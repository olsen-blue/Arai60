# Step1
 - max_amount[i]を、0~i地点の家までで盗める最大値とする。
 - 配るのではなく貰う遷移にするのが直感的かなと感じる。
 - これこそナップザックDPっぽい。max_amount[i]に至る場合分けのうち、最も良い結果を採用する。
   - nums[i]を使うかどうかで場合分け。
## 解法1:ボトムアップDP:AC
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]
        max_amount = [0] * len(nums)
        max_amount[0] = nums[0]
        max_amount[1] = max(nums[1], nums[0])

        for i in range(2, len(nums)):
            max_amount[i] = max(max_amount[i - 2] + nums[i], max_amount[i - 1])
        return max_amount[-1]
```

 - トップダウンの解法も直感的で良さそうに感じる。
 - nums[i]でお金が配置されている家が並んでいる。最終的には、[len(nums)-1]の位置の結果が知りたい。知りたいことをまず get_max_amount[len(nums)-1] って叫んで宣言してしまおう。
 - get_max_amount[len(nums)-1]の結果を知るためには、その直前(1個前 & 2個前)の結果を聞いて、利用すれば良い。トップダウンの再帰。
## 解法2:トップダウンDP:AC
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        @cache
        def get_max_amount(i: int)-> int:
            if i == 0:
                return nums[0]
            if i == 1:
                return max(nums[0], nums[1])
            return max(get_max_amount(i - 2) + nums[i], get_max_amount(i - 1))
        return get_max_amount(len(nums) - 1)
```
 - これ、cacheなしの時の計算量どうなるんだ。
 - https://github.com/hroc135/leetcode/pull/33/files
 - https://github.com/olsen-blue/Arai60/pull/33
   - この時の odaさんのコメントを思い出す。
 - とりあえず図を書いてみる。
```
helper(5)
 ├─ helper(4)
 │    ├─ helper(3)
 │    │    ├─ helper(1)
 │    │    └─ helper(2)
 │    │         ├─ helper(1)
 │    │         └─ helper(0)
 │    └─ helper(2)
 │         ├─ helper(1)
 │         └─ helper(0)
 └─ helper(3)
      ├─ helper(1)
      └─ helper(2)
           ├─ helper(1)
           └─ helper(0)
```
 - 請求書の枚数(葉ノードの数) : 8枚 (<- helper(0)とhelper(1)の数。今回は、フィボナッチ数列の計算結果に一致。)
   - https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0#cite_note-algo-3
       - 一般項を見ると、nが十分大きければ、f(n) ≒ 1.6^n で見積もれそう。
 - ホチキスの数() : 8-1 = 7枚 (<- 1ホチキスで末端ノードが融合して1減って最終的に根ノード1個のみになる。つまり、請求書 - 1 で求められる。)
 - 全体計算量は、ノードの数。
 - 請求書の枚数 + ホチキスの数 = 1.6^n * 2 - 1 ≒ O(1.6^n)  ...? 
 - (この計算量の見積もり、合ってますか...?)
 - 
 - 動的計画法についてある程度まとまっているドキュメント発見
 - https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems
 - 基底条件が if (i < 0)なのわかりづらいが、ざっと選択肢としては、こんなものがありそう。
 - トップダウン vs ボトムアップという構図で、これらについて直感や感情メインで考えてみる。
   - トップダウン：まず最初に、理想やビジョンを宣言して、それから手下ども(他の関数)に指示を出したり、必要なことを逆算して行うイメージ。
       - 目的に向かって全体を動かす感じ？企業戦略とかこっちですかね。縦割り組織という感じ。
       - そういう意味では、関数名 get_max_amount は、先にやりたいこと宣言する感じで、意外といいのかもしれない。
       - https://github.com/fhiyo/leetcode/pull/36/files#r1667320512
           - トップダウンは再帰と相性が良さそう。
       - 「ワガママお嬢様と召使いたち」というイメージでも面白いかもです。
   - ボトムアップ：これは１人の孤独な人間(アスリートとか職人のイメージ？)が無の状態から始めて、地道に努力・善い行いを継続して、最終的に何か大きなことを達成するイメージ。
       - 他の人(他の関数)を巻き込んで幅広にやるのではなく、孤独な感じがする。ずっと同じdpテーブルに向き合ってらっしゃる。勝手にシンパシーを感じる。
# Step2
 - PR見てみる。
 - あ、メモ化トップダウンもある。書く。
## 解法3:トップダウンDP(memo化):AC
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        memo = {}
        def get_max_amount(i) -> int:
            if i == 0:
                return nums[0]
            if i == 1:
                return max(nums[0], nums[1])
            if i in memo:
                return memo[i]
            memo[i] = max(get_max_amount(i - 2) + nums[i], get_max_amount(i - 1))
            return memo[i]
        return get_max_amount(len(nums) - 1)
```

 - https://github.com/Mike0121/LeetCode/pull/47/files
   - 基底条件は return max(nums, default=0)と書くと、まとめて書けちゃいそう。めちゃ良い。
   - https://docs.python.org/ja/3/library/functions.html#max
       - max の default 引数、イテラブルが空の時 default 引数に与えたオブジェクトを返せる。
 - https://github.com/hroc135/leetcode/pull/33/files
   - DPをテーブルではなく変数でやるの、慣れていない。しかしメモリの節約になる。
       - 変数でおくと、何個前の結果を使っているのかが、若干ブラックボックスになってしまう感じがあまり好みではなく、食わず嫌いしてる気がする。
       - https://github.com/olsen-blue/Arai60/pull/30#issuecomment-2676095025
           - まあでも、ここでもコメントいただいていたし、書いてみましょう。
## 解法4:ボトムアップDP(2変数):AC
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums, default=0)
        two_before_max = nums[0]
        one_before_max = max(nums[0], nums[1])
        max_amount = max(nums[2] + nums[0], nums[1])
        for i in range(2, len(nums)):
            max_amount = max(nums[i] + two_before_max, one_before_max)
            two_before_max = one_before_max
            one_before_max = max_amount
        return max_amount
```

 - 2変数で書くときは、forの中の更新順に気をつける必要がありますね。あと、初期値は index 2まで進んだ時の値に設定することも必要でしょうか。若干気をつけることが増えている？
 - あと、変数名でおくと、どうしても長くなるのでdpテーブルより、見づらいかもしれない。
 - これらのデメリットとメモリ節約のメリットを天秤にかけて状況に応じて判断する形でしょうか。
   - https://github.com/hroc135/leetcode/pull/33/files#r1912949487
   - おっしゃる通りかもしれない。結局私はdpテーブル派かも。

 - https://github.com/goto-untrapped/Arai60/pull/36/files#r1676989063
   - odaさん「場合分けが、網羅しているようでないといけないですね。」
       - なるほど...! 現在の位置に至る際の場合分けは、現在の位置の家に入るかどうかで、確かに網羅できていそう。
           - ナップザックDPも、そのマスに至る際に、その行の品物を使うかどうかで、網羅するということですね。
       - もっと言うと、遷移元で場合分けって、樹形図的に考えることが発散してしまい、すごく大変そうです...
       - 一方で、現在地の選択による場合分けは、考えることが少なくなり、”網羅”の状態に到達しやすいのだと、何となく感じました。確かにほとんどのDPの遷移式ってそうなっている気がする。
       - そもそも、なんで +nums[i] で場合分けするのか？について、ここでより納得できた気がする。(これが一番網羅しやすいからなのでは?という理解)

 - Step1で書いたコードを見てみる。
## 解法1:ボトムアップDP:AC
 - 基底条件は、要素2個まで全部まとめてやるのが早期returnで良いと思い、修正。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums, default=0)
        max_amount = [0] * len(nums)
        max_amount[0] = nums[0]
        max_amount[1] = max(nums[1], nums[0])

        for i in range(2, len(nums)):
            max_amount[i] = max(max_amount[i - 2] + nums[i], max_amount[i - 1])
        return max_amount[-1]
```

## 解法2:トップダウンDP:AC
 - 上記踏まえて、nums[i]で場合分けして網羅してることを意識すると、nums[i]を先にして、nums[i] + get_max_amount(i - 2) と書きたくなりました。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        @cache
        def get_max_amount(i: int)-> int:
            if i == 0:
                return nums[0]
            if i == 1:
                return max(nums[0], nums[1])
            return max(nums[i] + get_max_amount(i - 2), get_max_amount(i - 1))
        return get_max_amount(len(nums) - 1)
```

# Step3
 - 解法1と解法2で再現性チェック
## 解法1:ボトムアップDP:AC
 - 1分半で実装。
 - 基底条件をコンパクトに書けた点、nums[i]で場合分けをやるんやで、という気持ちで書くとスムーズに書けた。しっかり納得するとスムーズですね。
 - 多分この納得がないと、「あれ、3手前は考えなくて良いんだっけ？」みたいな余計なことを考え始めてしまい、思考が脱線しちゃう可能性あるかもと感じた。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums, default=0)
        max_amount = [0] * len(nums)
        max_amount[0] = nums[0]
        max_amount[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            max_amount[i] = max(nums[i] + max_amount[i - 2], max_amount[i - 1])
        return max_amount[-1]
```

## 解法1:トップダウンDP:AC
 - 最終的に2分半で実装。
 - トップダウンの再帰、やっぱり後先考えないワガママなお嬢様みたいですね。なんか人情味があります。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        @cache
        def get_max_amount(i: int) -> int:
            if i == 0:
                return nums[0]
            if i == 1:
                return max(nums[0], nums[1])
            return max(nums[i] + get_max_amount(i - 2), get_max_amount(i - 1))
        return get_max_amount(len(nums) - 1)
```
