# Step1
 - Sliding Windowというアルゴリズムをそもそも知らない。興味がある。
 - https://github.com/hayashi-ay/leetcode/pull/47/files
 - left/rightのポインタ2つおいてその範囲を窓として、中に重複がないように窓を伸び縮みさせるのか。面白い挙動だ。(伸び縮みさせる際の判断基準が違うだけで、動き方はしゃくとり法に似てるかもしれない。)
 - ポイント : 右ポインタで示す文字が既に窓内に存在する場合、重複を解消するために、左ポインタを右に動かして、窓から重複している文字を取り除く。重複がなくなるまでこの操作を繰り返す。
## 解法1:Sliding Window(set利用):AC
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = 0
        max_length = 0
        seen_char = set()

        for right in range(len(s)):
            while s[right] in seen_char:
                seen_char.remove(s[left])
                left += 1
            max_length = max(max_length, right - left + 1)
            seen_char.add(s[right])
        return max_length
```

## 解法2:Sliding Window(dict利用):AC
 - https://github.com/hayashi-ay/leetcode/pull/47/files
   - なるほど。seen_char_to_index = {}という辞書で、charをキーにすれば存在有無が確認できて、値でindexを取り出せば、index　+ 1の位置にジャンプできる。こっちの方が効率良さそうで良いですね。
 - defaultdictは、使うのが怖い。キーがない時は、ifチェックの時に何もありませんという結果になってほしい。
 - left = seen_char_to_index[s[right]] + 1 だと、"abba"のような場合に、left ポインタが後退（左に戻る）してしまう。
   - left ポインタが後退するのって、Windowの範囲 [left, right] の範囲の外、すでに探索したところに left が飛んでいっちゃうということなのか。(これは、いけない(某首相風)。)
   - left = max(left, seen_index + 1) とすることが必要。 leftは左に戻さない。
 - 解法1の方がシンプルで好きかも。実務の中などで速さを求めるのであれば、解法2を選択したい。
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        seen_char_to_index = {}
        max_length = 0
        left = 0
        for right in range(len(s)):
            if s[right] in seen_char_to_index:
                left = max(left, seen_char_to_index[s[right]] + 1)
            max_length = max(max_length, right - left + 1)
            seen_char_to_index[s[right]] = right
        return max_length
```

# Step2
 - PR見ていく。
 - https://github.com/Ryotaro25/leetcode_first60/pull/52/files
   - もう少し試行錯誤すべきだったかも。Sliding Windowがどういうものかへの興味が勝ってしまった。
 - https://github.com/fhiyo/leetcode/pull/48/files
   - if の中に left <= seen_char_to_index[s[right]] 書いた方が max_length = max(max_length, right - left + 1) って書くより直感的で良いな。
## 解法2':Sliding Window(dict利用):AC
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        seen_char_to_index = {}
        max_length = 0
        left = 0
        for right in range(len(s)):
            if s[right] in seen_char_to_index and left <= seen_char_to_index[s[right]]:
                left = seen_char_to_index[s[right]] + 1
            max_length = max(max_length, right - left + 1)
            seen_char_to_index[s[right]] = right
        return max_length
```
## 解法3:全探索:TLE
 - set(イテラブル)で、集合を作れる。
   - https://docs.python.org/3/library/stdtypes.html#set
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        max_length = 0
        for begin in range(len(s)):
            for end in range(begin + 1, len(s) + 1):
                if len(set(s[begin:end])) == end - begin:
                    max_length = max(max_length, end - begin)
        return max_length
```

 - https://github.com/Ryotaro25/leetcode_first60/pull/52/files
   - 自分もset()使うのが好みだった。
# Step3
 - 解法1, 2'で再現性確認。
## 解法1:Sliding Window(set利用):AC
 - これが一番好き。重複無くなるまで Window 縮めて削るのが直感的・シンプルに感じるので。
 - こういう挙動が Sliding ということなのではという名前的にもしっくりくるのも良い。
   - (雑談ですが、ザコシショウの玉⚪︎浩二のモノマネの動きがかなりSliding Windowな感じで笑いました。)
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = 0
        seen_char = set()
        max_length = 0
        for right in range(len(s)):
            while s[right] in seen_char:
                seen_char.remove(s[left])
                left += 1
            max_length = max(max_length, right - left + 1)
            seen_char.add(s[right])
        return max_length
```

## 解法2':Sliding Window(dict利用):AC
 - left <= last_char_to_index[s[right]] が抜けそうなのが書いていて怖い。この考慮が必要なのが、解法1と比較するとあまり直感的でないのが気に入らない。
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = 0
        last_char_to_index = {}
        max_length = 0
        for right in range(len(s)):
            if s[right] in last_char_to_index and left <= last_char_to_index[s[right]]:
                left = last_char_to_index[s[right]] + 1
            max_length = max(max_length, right - left + 1)
            last_char_to_index[s[right]] = right
        return max_length
```

# Step4
## 解法2:Sliding Window(dict利用):AC
 - https://github.com/olsen-blue/Arai60/pull/49#discussion_r2005295464
   - なるほど。
   - https://docs.python.org/3/library/stdtypes.html#dict.get
       - 今まで、dict.get()使うメリットを理解しきれていなかったが、今回のように場合分けを回避できるのか。すごい。 
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = 0
        last_char_to_index = {}
        max_length = 0
        for right in range(len(s)):
            left = max(left, last_char_to_index.get(s[right], -1) + 1)
            max_length = max(max_length, right - left + 1)
            last_char_to_index[s[right]] = right
        return max_length
```
