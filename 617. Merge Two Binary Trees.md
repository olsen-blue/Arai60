# Step1
- やることのイメージは、さくらんぼ構造の合体、と大まかに理解。
- 根ノードから開始して再帰スタックが積み重なり、逆に根から遠い末尾の葉のほうから、木構造が確定し始めて、最終的に求めたい木構造が確定する。（トップダウン型の再帰？）
- と、文字情報だけでは理解不足感がありましたが、下記の、再帰スタックの図は作用順序がイメージしやすいと感じました。なぜ再帰”スタック”なのかがようやく分かった気がします。
- https://qiita.com/ryo2132/items/4bedeec846d0427f1ac7
- （これまでのDFSは、再起スタックをあまり意識せずに「１手先でDFS」ということのみ意識していた．．．）
- 入力破壊型か、入力非破壊型のどっちにするか迷ったが、特別な理由がなければ、入力非破壊の方が良いのではと感じ、非破壊で書く。
## 解法１：非破壊DFS：AC
```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        node1 = root1
        node2 = root2
        if not node1 and not node2:
            return None
        if node1 and not node2:
            return node1
        if not node1 and node2:
            return node2
        
        new_value = node1.val + node2.val
        new_node = TreeNode(new_value)
        new_node.left = self.mergeTrees(node1.left, node2.left)
        new_node.right = self.mergeTrees(node1.right, node2.right)
        return new_node
```

# Step2
- 「root」を「node」という変数に置き直すことについて考える。「部分木の根」という解釈ができるので、「root」のままでも良いのではと、考えが変わる。
- 「new_value」「new_node」と2回も言うの、くどいなと感じる。1回で十分ではと感じる。
- いくつか他の方のPRを拝見する。
- ほぼ同じ感じのコード。
- https://github.com/tarinaihitori/leetcode/pull/23/files
- 下記のように基底条件はもう少しコンパクトにできそう。
- https://github.com/TORUS0818/leetcode/pull/25/files
- ifの書き方、かなり意見が分かれている模様...
- 個人的にはif３つ書くのが良い。（基底条件として起こるパターンを（くどいかもしれないが）網羅しているのを良いと感じた。）
- https://github.com/TORUS0818/leetcode/pull/25/files#r1685087564
- https://github.com/TORUS0818/leetcode/pull/25/files#r1685178888
- https://github.com/TORUS0818/leetcode/pull/25/files#r1685268627
- BFS（スタック + whileループ）の解法もあったが、２つの木構造を扱うのが、頭がこんがらがりそう...たぶん最適な解法ではないと感じる。（とか言いつつ、Step2でBFSの解法も試しました。）
- （木構造が１つなら、BFSは自然な気がする。）

## 解法１：非破壊DFS：AC
- if条件の記述を軽くする、node 使わずに root のままにしてみる、「new_value」は省略する、という修正をする。よりコンパクトになった。
- 特別な理由がなければ、入力非破壊の方が良いのではと感じる。
- あと、趣味の範囲だが、非破壊の方が「root1」と「root2」を対称的に扱うのが綺麗だと感じる。（非対称性に意味があるのではと思う人も、もしかするといるかもしれない...）
```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        if not root2:
            return root1
        if not root1:
            return root2

        new_root = TreeNode(root1.val + root2.val)
        new_root.left = self.mergeTrees(root1.left, root2.left)
        new_root.right = self.mergeTrees(root1.right, root2.right)
        return new_root
```

## 解法２：破壊DFS：AC
- 入力破壊の方法は、確かにメモリの節約になりそう。
- https://github.com/tarinaihitori/leetcode/pull/23/files
- 入力破壊して問題ない状況なら、メモリ節約のために、こっちで書くのかもしれない。あと、若干記述が少なくなったのも良いポイントかもしれない。
```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        if not root2:
            return root1
        if not root1:
            return root2

        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        return root1
```
## 解法３：DFS（スタック）：AC
- やっぱり、別の解法も見ておきたい。PR見る中では、スタック使っているものが印象的だった。
- GPTの力を借りて叩き台を作ってもらい、修正した。
- なるほど、「stack.pop()」で、後入れ先出し(Last In, First Out)にすれば、DFSになると理解。
```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        if not root1:
            return root2
        if not root2:
            return root1

        stack = [(root1, root2)]
        while stack:
            node1, node2 = stack.pop()
            node1.val += node2.val
            if node1.left and node2.left:
                stack.append((node1.left, node2.left))
            if not node1.left:
                node1.left = node2.left

            if node1.right and node2.right:
                stack.append((node1.right, node2.right))
            if not node1.right:
                node1.right = node2.right
        return root1
```
## 解法４：BFS（スタック）：AC
- 解放３で解くと、「stack を deque にするだけでDFSがBFSになるのでは？」と気付き、書いてみる。
- 多分BFSになった（はず）。データ構造を変えるだけで解法が変わるのが驚きだった。
- 結局、BFSでも解いてしまった。
```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        if not root1:
            return root2
        if not root2:
            return root1

        queue = deque([(root1, root2)])
        while queue:
            node1, node2 = queue.popleft()
            node1.val += node2.val
            if node1.left and node2.left:
                queue.append((node1.left, node2.left))
            if not node1.left:
                node1.left = node2.left

            if node1.right and node2.right:
                queue.append((node1.right, node2.right))
            if not node1.right:
                node1.right = node2.right
        return root1
```

# Step3
- 再現性の確認。個人的に好み・最もしっくりきた、非破壊DFSで書く。2分で実装。
## 解法１：非破壊DFS：AC
```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        if not root1:
            return root2
        if not root2:
            return root1
        
        new_root = TreeNode(root1.val + root2.val)
        new_root.left = self.mergeTrees(root1.left, root2.left)
        new_root.right = self.mergeTrees(root1.right, root2.right)
        return new_root
```
