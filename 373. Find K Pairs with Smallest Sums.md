# Step1
- データ管理は、{合計, {num1, num2}}を、プライオリティキューにいれていけば良さそう。
- 探索の進め方だが、num1とnum2をの組み合わせを全探索すると、これらの配列長さ(それぞれ10^5オーダー)的に、間に合わない。
- たしか以前解いた時に、プライオリティキュー＋ダイクストラ法っぽい考え方で誰かが鮮やかに解いていたのをおぼろげに思い出す。書いてみる。
- 最初「if j+1 < len(nums):」の考慮をすっ飛ばしていてエラー。その他細かいエラーを修正して、AC。
- 書くのに時間がかかったが、探索ロジックを覚えていられたのが、うれしい。解法が鮮やかで印象的に感じた、からでしょうか。そうでないものは忘れてしまいがちなので...
- 「ij_index_sorted_by_sum」や「visited_ij_values」の変数名は、「ij_coordinates_index_sorted_by_sum」や「visited_ij_coordinates_values」と迷ったが、ijにすでに座標っぽい意味があるのではないかと思い、「coordinates」抜きの短めの方を採用した。

- コードが複雑になるほど、変数の宣言は、その変数をメインで使い始める直前にするのが大事なのではと体感的に感じた。

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:

        ij_index_sorted_by_sum = []
        for i in range(len(nums1)):
            total = nums1[i] + nums2[0]                        #sumは組build-inにあり、良くないので、total。
            heapq.heappush(ij_index_sorted_by_sum, (total, (i, 0)))
            if len(ij_index_sorted_by_sum) > k:
                break
        
        visited_ij_values = []
        while len(ij_index_sorted_by_sum) > 0 and len(visited_ij_values) < k:
            min_sum_ij = heapq.heappop(ij_index_sorted_by_sum)
            i, j = min_sum_ij[1]
            visited_ij_values.append((nums1[i], nums2[j]))

            if j + 1 < len(nums2): 
                new_total = nums1[i] + nums2[j+1]
                heapq.heappush(ij_index_sorted_by_sum, (new_total ,(i, j+1)))

        
        return visited_ij_values
```

# Step2：
- 直近のPR、公式solutionなどを見てみる。ロジックは同じ感じのものが多い印象を受けた。
- このsolutionのように遷移方向が２つの方がわかりやすいかもだが、記述を軽量化したいので、１方向遷移とする。
- https://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3399718/find-k-pairs-with-smallest-sums
- （！質問！）動的計画法に関して、dpテーブルも、2次元の方が遷移が直感的にわかりやすいが、１次元の方が実装ラク・空間計算量少なめですよね。ここのトレードオフのバランスは、どう取るのが良いのでしょうか？大規模なプロダクトへの実装を考えれば、やっぱり１次元の方が適しているのでしょうか？

- キュー追加に関数使っているものを発見、なるほど。書く量が減ってありがたそう。heapナントカって書くの間違えそうだし、結構大変なので。
- また、「あれ、今ってインデックスを格納してるんだっけ？それとも値だっけ？」的なことを、関数名の工夫次第で考えずに済む、というメリットもあると感じた。
- https://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/84550/slow-1-liner-to-fast-solutions

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        ij_index_sorted_by_sum = []
        def push_total_and_ij_index(i, j):
            if i < len(nums1) and j < len(nums2):
                total = nums1[i] + nums2[j]
                heapq.heappush(ij_index_sorted_by_sum, (total, (i, j)))

        for i in range(len(nums1)):
            push_total_and_ij_index(i, 0)
            if len(ij_index_sorted_by_sum) > k:
                break
        
        visited_ij_values = []
        while ij_index_sorted_by_sum and len(visited_ij_values) < k:
            _, (i, j) = heapq.heappop(ij_index_sorted_by_sum)
            visited_ij_values.append([nums1[i], nums2[j]])
            push_total_and_ij_index(i, j+1)
            
        return visited_ij_values
```


# Step3(Step2のまま、という認識)
- 再現性の確認をする。５〜6分くらいで書けるようになりました。
- 今回のヒープ追加のように、何回もやる処理を関数化するとコードが短くなって書きやすくてGOOD、という経験を得ました。
- 良さげな工夫を、(このくらいの長さのコードであれば...)すぐに実装・検証できるのが、良いですね。結果、改善できると尚嬉しいです。

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        ij_index_sorted_by_sum = []

        def push_total_and_ij_index(i, j):
            if i < len(nums1) and j < len(nums2):
                total = nums1[i] + nums2[j]
                heapq.heappush(ij_index_sorted_by_sum, (total, (i, j)))

        for i in range(len(nums1)):
            push_total_and_ij_index(i, 0)
            if len(ij_index_sorted_by_sum) > k:
                break
        
        visited_ij_values = []
        while ij_index_sorted_by_sum and len(visited_ij_values) < k:
            _, (i,j) = heapq.heappop(ij_index_sorted_by_sum)
            visited_ij_values.append([nums1[i], nums2[j]])
            push_total_and_ij_index(i, j+1)

        return visited_ij_values
```
