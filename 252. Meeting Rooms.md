# Step1
## 解法1:累積和:AC
 - +1/-1の組み合わせのポイントが複数ある、累積和の問題なのでは。
 - 全区間において、累積和の値が0 or 1であれば、OK。一瞬でも2以上になる瞬間があるとNG。
 - 3分で実装。自力で書けて嬉しい。
```py
class Solution:
    MAX_RANGE = 10 ** 6 + 1
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        start_end_times = [0] * Solution.MAX_RANGE
        for start_time, end_time in intervals:
            start_end_times[start_time] += 1
            start_end_times[end_time] -= 1
        
        prefix_sum = 0
        for index in range(len(start_end_times)):
            prefix_sum += start_end_times[index]
            if prefix_sum >= 2:
                return False
        return True
```

# Step2
 - PR見ていく。
## 解法2:区間スケジューリング問題っぽい解法:AC
 - https://github.com/hayashi-ay/leetcode/pull/59/files
   - https://qiita.com/uniTM/items/0dbd7ec962186c005c08
   - 区間スケジューリング問題(競プロ用語かもしれない)っぽくいけるのか。
       - 多分今回はどっちでも良いんですけど、たしか、参加できる会議数の最大化を貪欲法で求めるのであれば、開始時刻ではなく終了時刻が早いものを貪欲的に部分最適を達成しながら選択していけばよかったはずなので、これ意識するなら終了時刻の方に注目しておきたいかも。この辺は、趣味の範囲でしょうか。
 - https://qiita.com/nagataaaas/items/531b1fc5ce42a791c7df
 - https://docs.python.org/3/glossary.html#term-lambda:~:text=lambda-,%C2%B6,-An%20anonymous%20inline
   - ラムダ式ってPythonにもあるのか。便利ですね。
```py
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        sorted_intervals = sorted(intervals, key=lambda x: x[1])
        last_meeting_end_time = - 1
        for start_time, end_time in sorted_intervals:
            if start_time < last_meeting_end_time:
                return False
            last_meeting_end_time = end_time
        return True
```

 - https://github.com/shining-ai/leetcode/blob/main/arai60/54-60_others/55_252_Meeting%20Rooms/level_1.py#L1
   - Step1は、この解法と近いですね。ですが、start ~ endを毎度全て舐めるより+1/-1を全て配置して最後に累積和で回収する方が無駄がないかと思います。
 - https://github.com/Ryotaro25/leetcode_first60/pull/60/files#diff-0956f4d4069768a55174260fc0ff72970be11fd086f605ee5dc20450b42170f0R29-R43
   - ソートの解法が多そう。なるほど。
 - https://github.com/Mike0121/LeetCode/pull/27/files#r1633298146
   - 私も、入力を破壊せずに済むならその方が良いと思って、解法2, 2'ではsortedを選択していました。
 - https://github.com/Ryotaro25/leetcode_first60/pull/60/files#r2003975631
   - あ、解法1って、入力値の時間が整数でないと動かないな...欠点を見つけてしまった。

# Step3
 - 再現性の確認。
## 解法1:累積和:AC
 - ソート不要なのと、作業が分離されている感じがなんか好みなので、解法1の方が好きですね。
 - あ、「=>」と書くとエラー(SyntaxError: invalid syntax)になった。「>=」でなければいけないらしい。日本語の読み方(大なりイコール)通りに書けば良さそうですね。
   - 「=<」もエラー(SyntaxError: invalid syntax)になる。同じく、「<=」でなければならないらしい。
 - 今更だが、MAX_RANGE という変数名と、置く場所はこれでよかったのだろうか。UPPER_LIMIT とかでも良かったかも。
```py
class Solution:
    MAX_RANGE = 10 ** 6 + 1
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        start_end_times = [0] * Solution.MAX_RANGE
        for start_time, end_time in intervals:
            start_end_times[start_time] += 1
            start_end_times[end_time] -= 1
        
        prefix_sum = 0
        for i in range(len(start_end_times)):
            prefix_sum += start_end_times[i]
            if prefix_sum >= 2:
                return False
        return True
```

## 解法2':区間スケジューリング問題っぽい解法:AC
 - end ではなく ended の過去分詞にした方が、すでに終わった感が出てより良いのでは感じた。
 - lambdaの x って、これで良いのかなあ。item とかにした方が良いのか。あんまり書いたことがないのでわからずでした。for i in range():の i と同じノリで許されるのでしょうか...?
```py
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        sorted_intervals = sorted(intervals, key=lambda x: x[1])
        last_ended_meeting_time = - 1
        for next_start_time, next_end_time in sorted_intervals:
            if next_start_time < last_ended_meeting_time:
                return False
            last_ended_meeting_time = next_end_time
        return True
```
