# Step1
 - わからん。手で書き出すなら樹形図かな。バックトラックって、何？
 - 前項の Sliding Window 同様、知らないアルゴリズム言われると早く知りたくなってしまう。
 - https://github.com/hayashi-ay/leetcode/pull/57/files
 - 我慢できず解法見る。あまりピンとこないので今まで解いたことのないタイプの問題かも。組み合わせって他の問題と違ってストーリーが見出せづらそうなので苦手かもしれない。
   - https://atcoder.jp/contests/joi2009yo/tasks/joi2009yo_d
       - あ、バックトラックって、この問題で、探索済みだったら他の探索パスが通れるように足元の氷を修復していたのと同じかも。
   - あ、将棋AIで、指し手を盤面に適用(do_move)して最善手を返した後に、指し手をする前の状態に戻す(undo_move)処理してたのと同じかも。こっちの方が今回のケースに近いかな。
 - 普通の DFS って、猪突猛進で突き進んだ後に、"探索跡"をそのまま放置していた。(諺 : 後は野となれ山となれ)
   - この猪突猛進感が好き。
 - バックトラックは"探索跡"をそのまま残すのではなく、後から試したい他の探索パスに対して干渉したり邪魔にならないように、"探索跡"を消して元の状態に戻してあげるのか。(諺 : 立つ鳥跡を濁さず)
   - バックトラック、奥ゆかしい子ですね。他の探索パスの可能性を尊重しているのが良い。
 - https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/
   - 1粒だけ選んで次に引き継ぐのはこれに似ている。
       - 今回は選んだ1粒をバックトラックで消去するのか。
## 解法1:バックトラック再帰:AC
```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        permutations = []
        def generate_permutations(permutation, remain_nums):
            if len(permutation) == len(nums):
                permutations.append(permutation[:])
                return
            for index, num in enumerate(remain_nums):
                permutation.append(num)
                generate_permutations(permutation, remain_nums[:index] + remain_nums[index + 1:])
                permutation.pop()
        generate_permutations([], nums)
        return permutations
```
 - 完全に理解できていない感覚があったので、次とその次の問題も見てみたり、サーバー漁る中で感じたが、リストのようなミュータブルなオブジェクトを関数の引数に渡すときは、複数呼ばれる再帰関数の間で、同じリストオブジェクトが共有されることは注意が必要ということがわかった。
 - これ副作用っぽいし、直感に反するし、認知負荷高いのでは？
 - ん？いや、リストが再帰関数間で共有されることが最初からわかっているんだったら、関数の外部に置くのが自然なのでは、と感じる。
   - remain_nums は1個除去して結合、みたいなことするので、毎回オブジェクト新規生成する感じでとりあえずは良いかな。
## 解法1':バックトラック再帰(permutationを外部変数に置く):AC
```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []
        permutation = []
        def generate_permutaions(remain_nums: List[int]):
            if len(permutation) == len(nums):
                all_permutations.append(permutation.copy())
                return
            for index, remain_num in enumerate(remain_nums):
                permutation.append(remain_num)
                generate_permutaions(remain_nums[:index] + remain_nums[index + 1:])
                permutation.pop()
        generate_permutaions(nums)
        return all_permutations
```

## 解法2:再帰(バックトラックなし):AC
 - https://discord.com/channels/1084280443945353267/1196472827457589338/1200798108259450940
   - 使用メモリ(空間計算量)が増えるが、再帰関数を呼ぶ時の引数に、新規に生成したオブジェクトを渡せば、1つの同一オブジェクトを複数の再帰関数呼び出しから参照することが防げるので、バックトラックが不要になる。
       - all_permutations.append(permutation) も all_permutations.append(permutation.copy()) でなくても良くなる。
   - 良いか悪いかは置いておいて、今までの感覚の延長で書きたいのであれば下記のように書くんだろうな、と感じる。
```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []
        def generate_permutations(permutation, remain_nums):
            if len(permutation) == len(nums):
                all_permutations.append(permutation)
                return
            for index, remain_num in enumerate(remain_nums):
                new_permutation = permutation + [remain_num]
                new_remain_num = remain_nums[:index] + remain_nums[index + 1:]
                generate_permutations(new_permutation, new_remain_num)
        generate_permutations([], nums)
        return all_permutations
```
## 解法3:スタック:AC
 - https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0#heading=h.xe8lirtynkse
   - この辺り見る。
   - https://discord.com/channels/1084280443945353267/1233603535862628432/1238707903196565546
       - 「再帰をスタックに直すときにどうするかというので、箱に「これからしなきゃいけない内容の書かれた紙」を入れていって箱が空になったら終わりという説明をしたことがあります。」
       - わかりやすい。てか、再帰でもこの考え方使えそうだ。1粒だけ選んで子分にタスクを預けている。
 - for文の中の、new_~~~ の変数は for が進むたびに新規に宣言されるので、起こしたくない余計な参照を防ぐことができる。
   - permutaion, remain_nums は、一定の状態で保持すべき。(ここを起点にforで変化させるので)
       - permutaion.append()とかやってはいけない。
```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []
        stack = [([], nums)]
        while stack:
            permutation, remain_nums = stack.pop()
            if len(permutation) == len(nums):
                all_permutations.append(permutation)
                continue
            for index, remain_num in enumerate(remain_nums):
                new_permutation = permutation + [remain_num]
                new_remain_nums = remain_nums[:index] + remain_nums[index + 1:]
                stack.append((new_permutation, new_remain_nums))

        return all_permutations
```

# Step2
 - とりあえずやりたい試行錯誤はやったのでPR見る。
   - 次とその次の問題も含めて、バックトラックとは何かを理解したく色々試行錯誤していたら結構お腹いっぱいになった。
   - 次とその次の問題もとりあえず、バックトラックで解けそうというのがわかったのは良かった。
 - https://github.com/hayashi-ay/leetcode/pull/57/files
   - 計算量:
       - 時間計算量: 1回の再帰関数呼び出しでO(n)、再起呼び出しが、n!回ありそうなので、O(n * n!)ということか。
       - 空間計算量: 出力の数が空間計算量になる。これはまさに順列組み合わせの数なので、O(n!)ですね。
 - https://github.com/Mike0121/LeetCode/pull/14/files
   - https://docs.python.org/3/library/itertools.html#itertools.permutations
   - itertools permutationsというのがあるらしい。
       - この内部実装、読めない。特にcyclesの意味がわからない。1引いてそれがjになるってどういうことなのか。GPTに聞いてもわからんので諦める。
       - 薄々感じていたが、数値計算苦手かも...DPとかDFS/BFSとか二分探索とかの方が直感が生きる感じ・ストーリーを見出せる感じがするので好きですね。
 - https://github.com/Mike0121/LeetCode/pull/14/files#r1597645797
   - あ、remain は動詞だった。rest_nums とかの方が良いかも。
 - 個人的に、しっくり来て覚えられそうな解法がバックトラック再帰とスタックしかなかった(敗北)
## 解法1':バックトラック再帰(permutationを外部変数に置く):AC
 - 変数名の修正を行う。
```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []
        permutation = []
        def generate_permutaions(rest_nums: List[int]):
            if len(permutation) == len(nums):
                all_permutations.append(permutation.copy())
                return
            for index, rest_num in enumerate(rest_nums):
                permutation.append(rest_num)
                generate_permutaions(rest_nums[:index] + rest_nums[index + 1:])
                permutation.pop()
        generate_permutaions(nums)
        return all_permutations
```

## 解法3:スタック:AC
 - 変数名の修正を行う。
```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []
        stack = [([], nums)]
        while stack:
            permutation, rest_nums = stack.pop()
            if len(permutation) == len(nums):
                all_permutations.append(permutation)
                continue
            for index, rest_num in enumerate(rest_nums):
                new_permutation = permutation + [rest_num]
                new_rest_nums = rest_nums[:index] + rest_nums[index + 1:]
                stack.append((new_permutation, new_rest_nums))

        return all_permutations
```

# Step3
 - 再現性の確認。最終的に4分くらい時で実装。
 - permutationのリストオブジェクトは、どうせ再帰関数に渡しても複数の再帰関数呼び出しから参照されるので、関数外部に置くのが好き。こう書くことで、なぜcopy()でなければならないのか、なぜバックトラックが必要なのかもスムーズに納得できる。
 - generate_permutations(next_rest_nums)の処理が最奥まで進むと、最奥まで到達したときの状態のpermutationの魚拓をcopy()により、取って保存できる。
 - DFSで深いところまで探索すると、permutationのリストオブジェクトを深いところまで連れてきて更新してしまうので、探索が済んだら浅い階層に戻すのに、pop()のバックトラックが必要となる。
## 解法1':バックトラック再帰(permutationを外部変数に置く):AC
 - returnを忘れないようにしたい。if書いたらすぐ書くべきかも、絶対に上から順番に書かなければならないということではないと思うし。
```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []
        permutation = []
        def generate_permutation(rest_nums):
            if len(permutation) == len(nums):
                all_permutations.append(permutation.copy())
                return
            for index, rest_num in enumerate(rest_nums):
                permutation.append(rest_num)
                next_rest_nums = rest_nums[:index] + rest_nums[index + 1:]
                generate_permutation(next_rest_nums)
                permutation.pop()
        generate_permutation(nums)
        return all_permutations
```

## 解法3:スタック:AC
 - https://discord.com/channels/1084280443945353267/1233603535862628432/1238707903196565546
   - やっぱり、このイメージが的確で分かりやすい。
 - continueを忘れないようにしたい。（if書いたらすぐ書くべきかも、絶対に上から順番に書かなければならないということではないと思うし。）
 - 最終的に4分半くらいで実装
 - 再帰関数の方が直感的で好きかなあ。
```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutaions = []
        stack = [([], nums)]
        while stack:
            permutaion, rest_nums = stack.pop()
            if len(permutaion) == len(nums):
                all_permutaions.append(permutaion)
                continue
            for index, rest_num in enumerate(rest_nums):
                next_permutaion = permutaion + [rest_num]
                next_rest_nums = rest_nums[:index] + rest_nums[index + 1:]
                stack.append((next_permutaion, next_rest_nums))
        return all_permutaions
```
