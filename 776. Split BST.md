# Step1
 - さっぱりわからん。Exampe1の3のノードが、上に上がってくるのどうやって処理するのかが分からず(ナンダコレハ)。解法見る。
 - https://github.com/hayashi-ay/leetcode/pull/53/files
   - あ、そもそも、関数の出力は、BSTを大小に分割した時の、小さい方のBSTの根(小)と、大きい方のBSTの根(大)を、return [根(小), 根(大)]で出力するのか。(Example1の出力で書かれている、Output: [[2,1],[4,3,6,null,null,5,7]] がよくわかっていなかった。根ノードだけ返せばこうなるのか。)
       - こういう根のセットの出力が、子分からも得られるということを想定すれば再帰で書けそう。
   - 理解した。
   - 根にいる親分がまず根の値のチェックをすると、BSTの性質により根の前後のどちらかが探索不要になる。つまり、親分には子分が二人いるが、片方は用済みになり、もう片方の探索が必要になる。
   - 探査が必要なほうの子分に対して命令をして、その子分の視点から、child_smaller, child_largerを受け取り、これを別々に用いるイメージ。
 - 例 : root.val <= target:の時
```
    小
   / \
  小   大
```
 - 左半分探索不要。根(小)が root で確定。
 - 子分(root.right)の視点で、child_smaller, child_largerを返させる
 - root.right = child_smaller として、すでにtarget以下の値のノードしか含まないことが確定しているBSTの根ノードである root の子ノード(右)として繋げてマージしてあげる。
   - BSTの性質上、child_smaller を根にもつBSTのノード値は全て、root の値より大きいので、child_smaller を root の右子ノードにする形でマージしてあげれば良い。
 - 最終出力としては、return [root, child_larger]を返せば良い。
## 解法1:トップダウン再帰(関数):AC
 - より明示性が欲しいと思い、変数名を修正した。
 - right_child_smaller_root, right_child_larger_root とかにしようかなと一瞬思ったけど、流石に長すぎる。あと、self.splitBST(root.right, target)に right であることは含まれているのと、if / else　で表記を一貫した方が見やすい気もするので、これはやめました。
```py
class Solution:
    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
        if not root:
            return [None, None]
        
        if root.val <= target:
            child_smaller_root, child_larger_root = self.splitBST(root.right, target)
            root.right = child_smaller_root
            return [root, child_larger_root]
        else:
            child_smaller_root, child_larger_root = self.splitBST(root.left, target)
            root.left = child_larger_root
            return [child_smaller_root, root]
```

# Step2
 - PR見る。
 - https://github.com/Ryotaro25/leetcode_first60/pull/50/files#r1912380341
   - 変数名は、Step1のもので良いのかも。
 - https://github.com/goto-untrapped/Arai60/pull/54/files#r1759974931
   - コードの直感的理解は、これとほぼ同じイメージなので問題なさそう。
 - https://github.com/goto-untrapped/Arai60/pull/54#discussion_r1780641914
   - 私も具体例の考慮ができていない気がする。上記のような直感的イメージだけで書き始めてしまっていた。
   - 「プログラムが書けてからでも、これくらいの「こうでなくてはいけない」の理解の精度があるかは確認してみてはいかがでしょうか。」書けてからでも考えることが必要なのか。
   - Step1のような直感的イメージや日本語としての理解ができていれば良いのでしょうか??
## 解法2:ボトムアップ(whileループ):AC
 - https://github.com/Ryotaro25/leetcode_first60/pull/50/files
   - whileループでも書いておくか。
       - whileループ、縦長になり、何をしているのかがパッと見分からんので、再帰と比べると若干忌避感がある。
   - 一方、再帰関数はワガママお嬢様の如く欲しい宣言を真っ先にできるから好き。再帰の深さに注意ですが...
       - あと、再帰関数は、関数の出力定義すると、子分からその出力を受け取れるという、ある種の抽象化のような仮定をした上で引き継ぎの処理に集中できるという点も良い。
 - 実装して感じたこと :
   - 最初に作るノード smaller_root, larger_root は、番兵なんですね。
       - https://github.com/olsen-blue/Arai60/pull/5#discussion_r1901275473
       - これと同じで、最初のノードを特別処理せずに済みそう。
   - BSTの性質上、smaller_rootの左半分、larger_rootの右半分にはすでにノードが存在していて、smaller_rootの右半分、larger_rootの左半分にはまだノードがない、という認識が必要だが、ここがちょっと直感的でなく、認知負荷がある気がする。
   - あと、ポインタを2つ考える必要があるのもややこしい。
   - リンクを切るのは、次の探索対象の root の位置が、大きい方のBST or 小さい方のBSTのどちらに接続されるのかが今のroot時点では、分からないからなのか...!
   - 全体的に、今回のボトムアップwhileループの解法、やることが多すぎる...!
   - トップダウン再帰の方がシンプル。同じこと実現するなら、シンプルで直感的な方が好き。
   - 名前空間について整理してみる:
       - smaller_root, smaller_node 別々の名前空間で存在しており、初期化時は同じオブジェクトを参照している。
       - 探索の中で、smaller_node = smaller_node.right と更新され、smaller_node の変数名に紐づくオブジェクトの更新がなされていく。
       - 一方で、smaller_root は smaller_node とは別の名前空間に存在する変数名で初期化時のオブジェクトノードをずっと保存保管してあり、ダミー的な番兵ノードとして機能する。
```py
class Solution:
    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
        smaller_root = TreeNode()
        smaller_node = smaller_root
        larger_root = TreeNode()
        larger_node = larger_root
        while root:
            if root.val <= target:
                smaller_node.right = root
                smaller_node = smaller_node.right
                root = root.right
                smaller_node.right = None
            else:
                larger_node.left = root
                larger_node = larger_node.left
                root = root.left
                larger_node.left = None
        
        return [smaller_root.right, larger_root.left]
```
                

# Step3
 - 再現性の確認
## 解法1:トップダウン再帰(関数):AC
 - 最終的に、2分くらいで実装。
 - Step1のような図が手元にあると、書きやすい。
```py
class Solution:
    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
        if not root:
            return [None, None]
        if root.val <= target:
            child_smaller_root, child_larger_root = self.splitBST(root.right, target)
            root.right = child_smaller_root
            return [root, child_larger_root]
        else:
            child_smaller_root, child_larger_root = self.splitBST(root.left, target)
            root.left = child_larger_root
            return [child_smaller_root, root]
```

## 解法2:ボトムアップ(whileループ):AC
 - 変数多くて大変。解法1で書きたい。最終的に3分ほどで実装。
 - 繰り返し書く中で見えたイメージ:
   - smaller_sentinel, larger_sentinel は、盆栽の土台部分の器のイメージに見えてきました。
   - smaller, largerはそれぞれの盆栽の植物の成長点のイメージに見えてきました。なんか可愛く見えてきました。
       - https://www.ihi.co.jp/iat/shibaura/schoolyard/glossary/cat3-sa/seichouten.html
```py
class Solution:
    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
        smaller_sentinel = TreeNode()
        smaller = smaller_sentinel
        larger_sentinel = TreeNode()
        larger = larger_sentinel

        while root:
            if root.val <= target:
                smaller.right = root
                smaller = smaller.right
                root = root.right
                smaller.right = None
            else:
                larger.left = root
                larger = larger.left
                root = root.left
                larger.left = None

        return [smaller_sentinel.right, larger_sentinel.left]
```
