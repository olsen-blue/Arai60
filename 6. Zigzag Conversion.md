# Step1
## 解法1:サイクルの規則性の利用:AC
 - 自力で解いてみる。とりあえずAC。
 - 認知負荷の塊みたいなコード、読みづらすぎる。(もう書きたくない...)
 - WAを出しながら、途中から読みづらいことに気づきながらも意地になって書いていた(最後の問題だし)。
 - j ループの中の処理が特に大変だった、手元にベクトルっぽい図とかを書いてどうにか実装した。
```py
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1 or numRows >= len(s):
            return s
        table = [[] for _ in range(numRows)]
        cycle = 2 * (numRows - 1)
        for pos in range(0, len(s), cycle):  # 1サイクル(cycle)の先頭 pos
            table[0].append(s[pos])
            for i in range(pos + 1, pos + numRows):  # 下がれるところまで下がる
                if i < len(s):
                    table[i % cycle].append(s[i])
            for j in range(pos + numRows, pos + cycle):  # 次のposの直前まで上がる
                if j < len(s):
                    table[cycle - (j % cycle)].append(s[j])
        result = ""
        for i in range(numRows):
            result += "".join(table[i])
        return result
```

## 解法2:UP/DOWN の利用
 - 流石にもっといい解法あるだろと思ってGPT先生にヘルプ。出してもらったものを整える。
 - 読みやすすぎる。UP/DOWN をフラグでやるのか。賢い。
 - あ、でも上下に移動するのは、解法1と同じなのでは。
 - is_going_downの初期値が False なのは、最初の要素を特別扱いせずに、他の要素と同様に一般的に扱えるようにするためなのか。
   - https://github.com/olsen-blue/Arai60/pull/5/files#diff-c655c7f146b306e01c4b8ca0d6739d1fcc21f08b78456fb0dbf415fca6864c5aR4
   - これを思い出した。
```py
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1 or numRows >= len(s):
            return s
        
        rows = [""] * numRows
        row_position = 0
        is_going_down = False

        for ch in s:
            rows[row_position] += ch
            if row_position == 0 or row_position == numRows - 1:
                is_going_down = not is_going_down
            if is_going_down:
                row_position += 1
            else:
                row_position -= 1
        return "".join(rows)
```

# Step2
 - https://github.com/hayashi-ay/leetcode/pull/71/files
   - 上から下へ移動 -> 上へ移動 という考え方は一緒だった。
 - https://github.com/hayashi-ay/leetcode/pull/71/files
   - かなり解法2に近いですね、step +1/-1でもいいですね。コメントで対応されているが、値だけみると、マジックナンバーになっているかもと感じた。
   - 個人的には、is_going_down の主張・意図が強い感じが気に入っていて bool のフラグ値の方が好きかも。
   - あと、boolにすることで、2値に限られることも。意図が伝わりやすいのではと感じる。
   - https://github.com/Ryotaro25/leetcode_first60/pull/66/files#diff-a4f3bd89612b46b1ffd9cd067947b06c78f2993e41e8d0d2a997c2eb7aac2af1R19-R22
       - boolですね。is_downforward でもいいかも？
 - https://github.com/shining-ai/leetcode/blob/main/arai60/54-60_others/60_6_Zigzag%20Conversion/level_4.py
   - hayashiさんとほぼ同じですね。個人的には、direction の反転処理は、1つの if チェックで済ませたいかもしれない。
   - あ、でも分けた方が、端のどっちで　+1/-1のどっちの値になるのかがわかりやすいな。
   - でも、not や -1 かけて反転させるのもなんか自然言語的に自然で良いんですよね。ベクトルを反転させるような感覚。ただ、端のどっちで+1/-1どちらの値になるのかがちょっとわかりづらい。どっちにも良さがありそう。
   - https://github.com/katsukii/leetcode/pull/7/files#r1909061275
       - 分けた方が素直かも...
   - https://github.com/fhiyo/leetcode/pull/58/files#r1730297436
       - 反転させる派の人もいる...
   - https://github.com/fhiyo/leetcode/pull/58/files#r1731534558
       - 「反転させるやり方だと今のdirectionがどっちなのか一応意識しないとダメかなと思って選ばなかった感じでした。」
       - これは本当にそう思いますね。反転でなく、代入で書いてみようかなあ。
   - 結局、bool値で書きたいのは変わらなかった。
 - https://github.com/Ryotaro25/leetcode_first60/pull/66/files#r2024988787
 - https://github.com/katsukii/leetcode/pull/7/files#diff-a8a8cf60869f235e2ecb676f792b407c753fec4ac3fbbe31372cb2a73c5dd557R60
   - rows　で良さそう。
 - https://discord.com/channels/1084280443945353267/1196472827457589338/1200081854301225011
   - リストを2次元リストにしている人もいた。上記の b のような例に気をつけたい。そもそも b みたいな書き方をすることがあるのだろうか？活用イメージがわからなかった。(2次元のリスト作る時は、内包表記で良いと感じる。)

## 解法1:サイクルの規則性の利用:AC
 - https://github.com/katsukii/leetcode/pull/7/files#diff-a8a8cf60869f235e2ecb676f792b407c753fec4ac3fbbe31372cb2a73c5dd557R174
   - 解法1の方向性でよりわかりやすく書かれていますね。これ見ながら直してみよう。
 - だいぶ見やすくなった。for 1個で済んでいるのが良い。コメントも1つで済んでいる。
 - しかし、以前として直感的でないのは変わらないなあ。
 - https://github.com/katsukii/leetcode/pull/7/files#diff-a8a8cf60869f235e2ecb676f792b407c753fec4ac3fbbe31372cb2a73c5dd557R208-R211
   - 「1は人間にとって直感的だが条件分岐が2より多い」
   - 「2の場合、計算のみで行番号を決定できるため方向の制御が不要になる。ただし計算が間接的なため人間が理解するには1よりも理解が少し難しくなる」
   - 「結論、パフォーマンスを重視する場合は2で問題なさそうだが、処理の規模が小さい場合は1で良さそうと感じた」
       - 同じ感情を持ちました。
```py
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if len(s) <= numRows or numRows == 1:
            return s
        rows = [""] * numRows
        cycle = 2 * numRows - 2
        for i in range(len(s)):
            row_index = i % cycle
            if row_index >= numRows: # 上昇部分にある時
                row_index = cycle - i % cycle
            rows[row_index] += s[i]
        return "".join(rows)
```
 - rows = [] * numRows にすると範囲外エラー。あれ、なぜだろう。
   - Pythonでは、リストに対して整数との乗算を行うと、そのリスト内の各要素を、指定した回数分「連結」した新しいリストが返される。
   - L = [1, 2, 3] -> print(L * 3)  # 結果: [1, 2, 3, 1, 2, 3, 1, 2, 3]
   - L_ = [] -> print(L_ * 3) # 結果: [] 
       - 「空リストを3回連結する」操作となるけど、空リスト同士を連結しても中身がないから、結果は依然として空リスト [] になる！(なるほど)

## 解法2:UP/DOWN の利用
 - 反転ではなく、代入で書いてみる。
 - いつ、True/False のどちらになるのかがわかりやすくなった。こっちの方が良きですね。
```py
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1 or len(s) <= numRows:
            return s
        
        row = 0
        is_going_down = False
        rows = [""] * numRows
        for ch in s:
            rows[row] += ch

            if row == 0:
                is_going_down = True
            if row == numRows - 1:
                is_going_down = False
            
            if is_going_down:
                row += 1
            else:
                row -= 1
        return "".join(rows)
```

# Step3
 - 直感的でしっくりきている(覚えられそうな)解法2で再現性の確認。
## 解法2:UP/DOWN の利用
 - https://github.com/olsen-blue/Arai60/pull/58/files#diff-0fa674be955a983fbef3f0f1952784256410e7cd97ff5fa05b6d6b5cfa09d3c0R3
 - https://github.com/olsen-blue/Arai60/pull/55/files#diff-c279761355f0309f5c503a5494a18ea73bb072d26d7f39a4b951d76ba74a1a43R7
   - 何度も書いていて気づきましたが、今回の row って、Selectionソートに出てくる、配置・挿入用のポインタインデックスみたいなイメージですね。
   - (コードは変わってないですが) 同じ考え方で頭の中での見通しが、より良くなった気がする。嬉しい。
```py
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if len(s) <= numRows or numRows == 1:
            return s
        
        row = 0
        rows = [""] * numRows
        is_going_down = False
        for ch in s:
            rows[row] += ch
            if row == 0:
                is_going_down = True
            if row == numRows - 1:
                is_going_down = False
            
            if is_going_down:
                row += 1
            else:
                row -= 1
        return "".join(rows)

```
