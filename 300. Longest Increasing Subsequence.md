# Step1
- あ、蟻本の動的計画法の項にこの問題載ってた気がする、が詳細を忘れた。良い機会なので思い出して書いてみる。
- numsリストのある位置インデックスを i として、iより左のインデックスを j とする。
- nums[j] < nums[i]だったら、jの位置の値に+1できる。その中で最大になるものをiの位置の値として採用すればよい。
- 値を求めるには、前の計算結果を使うので、動的計画法だなとわかる。
- 自分で実装できた。うれしい。
- 本当は、AtCoderとかでよくある dp[i] みたいな書き方が慣れている・短く書けるので書きたくもなったが、これ以上ないぐらいの略語なのと、何が入っているリストなのかもよく分からないので勿論やめる。
## 解法1:2重ループ
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        length_at_index = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(0, i):
                if nums[j] < nums[i]:
                    length_at_index[i] = max(length_at_index[i], length_at_index[j] + 1)
        return max(length_at_index)
```

# Step2
- PR見てみる。
- Step1で書いたコードの変数名、max_lengthsとかの方が良い気がしてきた。コンパクトだし意味もよりわかりやすいので、まあこれで良いのでは。
## 解法1:2重ループ
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        max_lengths = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(0, i):
                if nums[j] < nums[i]:
                    max_lengths[i] = max(max_lengths[i], max_lengths[j] + 1)
        return max(max_lengths)
```

 - 他の選択肢を持ちたい。PR見る。
 - 二分探索（bisect_left）で解けるらしい。どういうこと？思いつきもしなかったので知りたい。O(NlogN)らしいのでもっと速いし。
 - 今回は綺麗に単調増加する nums が与えられているわけではないのに、なぜ二分探索？という感情。
 - https://github.com/fhiyo/leetcode/pull/32/files
   - この二分探索のコードスッキリしていて良いな。
 - しかし、ソースコードみたが、最終的な LIS としてあり得ないはずのリスト(lis)に対しても、最後にlen(lis)で求める、というパターンが含まれて良い理由がわからず。
 - 手元で実験：「1, 98, 99, 100, 2, 4」
```
    1 ─ 98 ─ 99 ─ 100 
      └─ 2 ─  4
```
 - あ、なるほど。数字を差し替えても長さ変わらないし、筋の良さげなルートをキープしておいて、未来において、より長いLISが作れる可能性を最大化しましょうということなのね、と理解。
 - なんか、鞍替えの準備をしっかり進めていて、抜け目がなくて、用意周到ですねぇ。一途ではなく浮気的とも言えるかもしれません。(感情の備忘として敢えてこう書きました。感情を持った方が頭に残ることが多いため。)
 - 「1, 98, 99, 100, 2, 4」に対して、仮に「5, 6」と続いたら、キープしておいたルートが生きるわけですね。恐れ入りました。
```
    1 ─ 98 ─ 99 ─ 100 
      └─ 2 ─  4 -  5 -  6
```
 - (言うまでもないが、末尾にどんどん追加できる場合は、「はい。そのままスクスク成長してくださいね。」でOK。)
 - 局所最適解を貪欲法的に積み上げた結果、全体最適につながる、という点では貪欲法っぽいのかもしれない。
   - https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/
   - たしかこの問題とかそうだった気がする。
 - 以上のことを考えて、ようやく納得できたので実装。
 - bisect_leftって C++ の lower_bound と一緒なのねと今更気づいた。インデックスを返すかイテレータを返すかどうかの違いくらいで多分ほぼ同じかも。
 - https://github.com/kazukiii/leetcode/pull/32/files#r1790191654
   - なお、セグメント木はSWEの常識には含まれず、とのことなのでスキップ。上のことを考えてもう若干お腹いっぱいなのもある。
## 解法2:二分探索(bisect_left)
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        lis = [] # Longest Increasing Subsequence
        for num in nums:
            insert_index = bisect_left(lis, num)
            if insert_index <= len(lis) - 1: # 差し替えの場合
                lis[insert_index] = num
            else:                            # 末尾追加の場合
                lis.append(num)
        return len(lis)
```

## 解法3:二分探索(bisect_leftを自分で実装)
 - あ、bisect_leftは前に整理したなぁ。久しぶりに手元で図を書いたが、探索打ち切り区間の定義で全て決まるので、ここだけは絶対に間違えずに覚えておきたい。
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def bisect_left_func(list_: List[int], insert_value: int) -> int:
            left = 0
            right = len(list_)
            while left < right:
                middle = (left + right) // 2
                if insert_value <= list_[middle]:
                    right = middle
                else:
                    left = middle + 1
            return left
        
        lis = [] # Longest Increasing Subsequence
        for num in nums:
            insert_index = bisect_left_func(lis, num)
            if insert_index <= len(lis) - 1:
                lis[insert_index] = num
            else:
                lis.append(num)
        return len(lis)
```
# Step3
- 一番タメになりそうな、解法3で現性の確認にトライ。5分で実装できた。
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def bisect_left_func(list_: List[int], value: int) -> int:
            left = 0
            right = len(list_)
            while left < right:
                middle = (left + right) // 2
                if value <= list_[middle]:
                    right = middle
                else:
                    left = middle + 1
            return left
        
        lis = []
        for num in nums:
            insert_index = bisect_left_func(lis, num)
            if insert_index <= len(lis) - 1:
                lis[insert_index] = num
            else:
                lis.append(num)
        return len(lis)
```
 - 感想。
 - 二分探索って汎用性が高いなと改めて実感。
 - 困った時は手元で実験が大事。
 - 区間を絞る二分探索の考え方の復習になってよかった。BSTの時もかなりこの考え方使ったしすごく汎用的だなと感じる。
