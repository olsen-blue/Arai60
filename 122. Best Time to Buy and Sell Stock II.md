# Step1
 - その日のうちに売買ができるのは、前問ではなくこっちの問題ですね。
 - その日のうちに、買い->売りはマジで何の意味もないが、売り->買いは意味があるぞコレ。
 - 株が保有できるのか。まあ、考え方によっては保有してたことにすれば良いのかも?
 - 株保有有無の情報管理が必要？ dpテーブルのindexを１つ増やして、スイッチ機能を持たせるのが素直かなぁ。
   - https://atcoder.jp/contests/joi2011yo/tasks/joi2011yo_e
   - テーブルにスイッチ機能を持たせる例
 - あ、受験数学の確率漸化式の遷移式っぽいというかほぼ同じ？ pnとかqnとか出てきて、繋ぐ矢印に×(1/3)とか×(1/2)とか書く感じのやつです。
 - 買ったらSTOCK状態になって手持ち金額が減る。売ったらNON_STOCK状態になって手持ち金額が増える。
## 解法1:ボトムアップDP(状態切り替えdpテーブル):AC
 - 実装にトライ。AC。うれしい。
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        HOLD_STOCK = 1
        NOT_HOLD_STOCK = 0
        profits = [[0] * 2 for _ in range(len(prices))]
        profits[0][HOLD_STOCK] = - prices[0]
        profits[0][NOT_HOLD_STOCK] = 0
        for i in range(1, len(prices)):
            profits[i][HOLD_STOCK] = max(profits[i - 1][HOLD_STOCK], 
                                         profits[i - 1][NOT_HOLD_STOCK] - prices[i])
            profits[i][NOT_HOLD_STOCK] = max(profits[i - 1][NOT_HOLD_STOCK], 
                                             profits[i - 1][HOLD_STOCK] + prices[i])

        return max(profits[len(prices) - 1][HOLD_STOCK],
                   profits[len(prices) - 1][NOT_HOLD_STOCK])
```
# Step2
 - 他の解法知りたい。PR見る。
 - https://github.com/hroc135/leetcode/pull/36/files
   - 貪欲法っぽくやっている。なるほど。
 - これまで一連のDPの問題を解いて、思ったのは、細かく刻まれた、例えば今日の選択肢を最適化するという方法が結構多いと感じる。
   - Longest Increasing Subsequence と Maximum Subarray がそうかな。いや2問だけじゃん。それぐらい印象的だったということでしょう。
   - Maximum Subarray とやってること近くないか?
   - https://github.com/olsen-blue/Arai60/pull/32#discussion_r1973532829
       - これとかそう。
 - 今回の問題も、prices を地点ごとの標高だと思うと、時系列的に、(1)低い地点 -> (2)高い地点 を逐一決めていき、(1)(2)の上昇成分をたくさん稼げば稼ぐほど良い。
 - なら、発生し得る上昇成分を全部回収できたらそれが最適解ということですね。標高で例えると上り坂の部分ですね。
 - 現実世界の株売買(自分興味ないですが...)では、「いや、ここでは売らずにまだ寝かしておいた方が、さらなるビックウェーブが明日にでも来るかもしれねェ...」みたいな気持ちにもなりそうですが、これがこの解法を理解することのハードルになっていた気がする。
   - prices = [1,2,3,4,5] のケースとかそう。右肩上がりのビックウェーブ来てますが、毎日淡々と上昇成分回収(作業ゲー)すればそれでOKなんですね。
   - 今回は、prices は全部モロバレしているわけである。完全リーク。上昇成分を全て回収すればOK。
 - 標高のイメージは odaさんの受け売りですが、汎用的に使える考え方で気に入っています。
## 解法2:2変数DP:AC
 - この問題は普段よく使うdpテーブルではなくて、2変数の方が直感的だと感じた。yesterday / today の対比で書けるのが良いと感じたからかも。
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        yesterday_price = prices[0]
        for i in range(1, len(prices)):
            today_price = prices[i]
            if yesterday_price < today_price:
                max_profit += today_price - yesterday_price
            yesterday_price = today_price
        return max_profit
```
 - 面白そうな解法発見。
 - https://github.com/hayashi-ay/leetcode/pull/56/files
 - https://github.com/TORUS0818/leetcode/pull/40/files
   - 標高曲線を舐めていって、谷と山頂(<- 3次関数とかの極値のイメージ)を発見 -> 差をとって加算 -> 山頂の次からまた谷&山頂を探す -> ...
   - 自然言語ですんなり表現できる。すごく素直な直感的な解法。直感的な解法、数学的な処理ではなくストーリーとして頭に残ってくれるので好きですね。
   - 起点となるindexは、文字通り from_index にするとわかりやすいなぁ。
## 解法3:標高曲線を舐めて谷(bottom)&山頂(top)を発見する解法:AC
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/53/files#r1730194725
   - この+αの問いに対する解になるのが、この解法3なのでは? 意外なポテンシャルに気付き、さらに魅力的な解法に見えてきた。
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        def find_next_bottom(from_index):
            index = from_index
            while index < len(prices) - 1 and prices[index] >= prices[index + 1]:
                index += 1
            return index
        
        def find_next_top(from_index):
            index = from_index
            while index < len(prices) - 1 and prices[index] <= prices[index + 1]:
                index += 1
            return index
        
        max_profit = 0
        index = 0
        while index < len(prices) - 1:
            bottom_index = find_next_bottom(index)
            top_index = find_next_top(bottom_index)
            max_profit += prices[top_index] - prices[bottom_index]
            index = top_index + 1
        return max_profit
```

# Step3
 - 標高曲線のイメージが持てて直感的で、上の+αの問いに対する解にもなる、解法3に愛着を感じたので、これで再現性の確認。
 - 4分で実装。whileの中の処理が時系列順で直感的なの、好き。
 - max_profit += abs(prices[top_index] - prices[bottom_index]) はどう?と一瞬思ったが、これは気づくべきバグに気付けなくなるおそれがあるので、ダメだなと感じる。
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        def find_next_bottom(from_index):
            index = from_index
            while index < len(prices) - 1 and prices[index] >= prices[index + 1]:
                index += 1
            return index

        def find_next_top(from_index):
            index = from_index
            while index < len(prices) - 1 and prices[index] <= prices[index + 1]:
                index += 1
            return index
        
        max_profit = 0
        index = 0
        while index < len(prices) - 1:
            bottom_index = find_next_bottom(index)
            top_index = find_next_top(bottom_index)
            max_profit += prices[top_index] - prices[bottom_index]
            index = top_index + 1
        return max_profit
```
