# Step1
 - なんかバブルソートっぽい動かし方だけど、ソートアルゴリズムをコード書けるほどわかっていない。
   - この辺り見たり、GPTに質問したりしてある程度理解を得る。qiitaの方がスピードがゆっくりで見やすかった。
 - https://www.toptal.com/developers/sorting-algorithms
 - https://qiita.com/r-ngtm/items/f4fa55c77459f63a5228
 - 2つ選択肢が浮かんできました : 
   - 0 でないものを前に持ってくると考えると Selection ソートっぽい
   - 0 を後ろに持ち上げると考えると Bubble ソートっぽい
## 解法1: Selectionソートをイメージした解法:AC
 - 時間計算量:O(n)
```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        non_zero_putting_index = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[non_zero_putting_index], nums[i] = nums[i], nums[non_zero_putting_index]
                non_zero_putting_index += 1
```

## 解法2: Bubbleソートをイメージした解法:AC
 - 時間計算量:O(n^2)かな
 - 解法1の方が、シンプルで速いので解法1の方が良いな。
 - でも、アルゴリズムの挙動は、まさに move zeros という感じがする。この点良いですね。
```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        for sort_count in range(len(nums)):
            is_swapped = False
            for index in range(len(nums) - 1 - sort_count):
                if nums[index] == 0:
                    nums[index + 1], nums[index] = nums[index], nums[index + 1]
                    is_swapped = True
            if not is_swapped:
                break
```

# Step2
 - https://github.com/hayashi-ay/leetcode/pull/58/files
   - 解法1ほぼ一緒ですね。
   - この問題に限らず、hayashiさんのコードに自分のやりたいことが大体書いてあるので、自然と真っ先に確認させていただいている。
 - https://github.com/fhiyo/leetcode/pull/54#discussion_r1729801172
   - 「Generator を使って変なコードを書いてみました。」
   - 知らないコードだ...(某シンジくん) 
   - そもそも Generator が何なのか知らない。
 - https://zenn.dev/nakurei/articles/understanding-python-generators
   - Generatorは、next()で呼ばれるたびに、値を1個ずつ生成してくれるのか。
   - if は設定できる条件フィルターらしい
   - := はウォルラスオペレーターと呼ばれるもので式の中で変数に代入しながらその値を返すことができる代物らしい。
   - https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions
   - https://qiita.com/Naoya_pro/items/85c4508acea106055bcc
      - :=   <- あ、見た目がセイウチ(walrus)なのかw かわいい。
 - try / except を使っている理由は、ジェネレータ eq0 や neq0 の要素がなくなったときに StopIteration 例外が発生するため、それをキャッチしてループを終了させるためなのか。
## 解法3:ジェネレータ:AC
 - 書いてみた感想:
   - next() を呼ぶたびに次の要素を取得しながらポインタが進むのが便利だなあと感じた。良いですね。
```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        equal_0 = (i for i, x in enumerate(nums) if x == 0)
        non_equal_0 = (i for i, x in enumerate(nums) if x != 0)
        try:
            while True:
                index_0 = next(equal_0)
                while (index_non_0 := next(non_equal_0)) < index_0:
                    pass
                nums[index_0], nums[index_non_0] = nums[index_non_0], nums[index_0] 
        except:
            pass
```

 - 変数名について:
   - https://github.com/Mike0121/LeetCode/pull/24#discussion_r1631275337
   - https://github.com/Mike0121/LeetCode/pull/24#discussion_r1631226214
       - zero_index はたしかに分かりづらいですね。
       - 目的考えるとそこに非ゼロの数字を置くので、長いんですけど Step1 で書いた non_zero_putting_index は意外といい感じかも。
           - お目当ての品物(非ゼロの数字)を台の上に横並びで並べたくて、次の品物を置くための位置(non_zero_putting_index)、というイメージです。
       - 大事な情報は前に来た方が多分良いので、index_to_put_non_zero とかでも良いかもと感じたが、to 使うと辞書とかリストとかに見えてしまってダメかも。(私としてはto不定詞のつもりでしたが...)
   - https://github.com/Ryotaro25/leetcode_first60/pull/59/files#diff-35e5256de8a62e950744e302f4217674916a16c65c6367ef86095ef798bd3879R44-R47
       - 「自分はnon_zero_indexにしました。」
       - 近い命名の人見つけました。
       - まあでも、non_zero の数は複数あると思うので、non_zero_putting_index みたいに、"次に nom_zero を置きたい"的な意味付けも必要なのではと感じる。

 - https://github.com/fhiyo/leetcode/pull/54/files#diff-2f8b85074aa38861aa9dd6fbe0c5f1b540a06f8618d7552b4ffd05da21f795d3R7-R8
   - これ、シンプルですね。非ゼロとゼロの扱いを別々に分離できている
   - https://ja.wikipedia.org/wiki/In-place%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0
       - 「in-placeアルゴリズムとは、計算機科学においてデータ構造の変換を行うにあたって、追加の記憶領域をほとんど使わずに行うアルゴリズムを意味する。」
       - あ、でも問題文的に、in-place とでやれと言ってるので、他の配列を用意しようという発想にそもそも至らなかったかも。
## 解法4:非ゼロとゼロで分離して2回ループ:AC
 - https://github.com/shining-ai/leetcode/pull/54/files#diff-326ca2ce90ef5e7bf7e21c2676a184474a21c4d3d213d13c81e3fc5675c23267R4-R16
   - これすごく良い...!! 非ゼロとゼロの扱いを別々に分離できているだけでなく、in-placeな処理も満たしている。
   - 2回forやるのがちょっと非効率ですが、このデメリットを打ち消してお釣りが来るくらい直感的で、個人的ベスト解法だと感じる。
```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        non_zero_putting_index = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                continue
            nums[non_zero_putting_index] = nums[i]
            non_zero_putting_index += 1
        for i in range(non_zero_putting_index, len(nums)):
            nums[i] = 0
```

# Step3
 - どれでやろうかな。
 - 解法4が個人的ベスト解法なので確定。
 - あと、Selection ソートと Bubble ソートの考え方に慣れたいので、解法1, 2もやりましょう。
## 解法4:非ゼロとゼロで分離して2回ループ:AC
 - 分離による直感性が本当にとても良い。しっくり来すぎてスラスラ書けますねこれ。
```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        non_zero_putting_index = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                continue
            nums[non_zero_putting_index] = nums[i]
            non_zero_putting_index += 1
        for i in range(non_zero_putting_index, len(nums)):
            nums[i] = 0
```

## 解法1: Selectionソートをイメージした解法:AC
 - 解法4の方が流石に直感的ですかね。解法4と近いですが、1ループで済むもの。
 - 先頭に0が詰まっている状況を視覚的にイメージすると、直感的かも。(先頭に非ゼロが詰まっている時は、何も変化がないのでこれはこれでOK。)
```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        non_zero_putting_index = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                continue
            nums[non_zero_putting_index], nums[i] = nums[i], nums[non_zero_putting_index]
            non_zero_putting_index += 1
```

## 解法2: Bubbleソートをイメージした解法:AC
 - 今回の解法の中だと実装が重く、押さえておくべきポイントも割と多いが、直感的なのは解法4にも負けていないかもしれない。問題文そのままのことをしているので...
 - ほんとに泡が浮き上がるみたいで面白いですね。
 - でも、無駄な操作が結構多いかも。ここ気になりますね。ずっと同じ0を見て1個ずつアップシフトさせるの無駄だと思うので。
```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        for sort_count in range(len(nums)):
            is_swapped = False
            for index in range(len(nums) - 1 - sort_count):
                if nums[index] != 0:
                    continue
                nums[index], nums[index + 1] = nums[index + 1], nums[index]
                is_swapped = True
            if not is_swapped:
                break
```
 - Step3 では、全部早期continueで書いたけど、こっちの方が良いですね。ネストが浅いと嬉しいと感じるようになりました。
