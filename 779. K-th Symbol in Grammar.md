# Step1
 - よく分からないので実験しよう。てか、どんなテータ構造で処理すべきなんだこれ。リスト？文字列？二分木？
 - k のオーダーはだいたい、 O(2^30) = O((2^10)^3) ≒ O(1000^3) = O(10^9) なので、出来上がるバイナリ列を全て舐めて見ていくと計算が確実に間に合わなそう。どうすんだこれ、でも制約がヒントになることもあるので、使える情報かも。
 - 手元で図を書いて実験。なんか二分木が自然で良い気がする。(深さ5くらいまで書いた時点で思いました。)
 - (n,k)の組み合わせごとに、ノードが与えられる。
 - kの偶奇が大事そう?? 子ノード(n, k)を考えると、kが奇数の時、その親ノードと同じ値になる。kが偶数の時、その親ノードから反転した値になる。
   - https://atmarkit.itmedia.co.jp/ait/articles/2310/31/news035.html
   - https://docs.python.org/ja/3.13/reference/expressions.html#boolean-operations
       - 反転は not 使うと簡単にできそう。(追記)ただ、not はbool値を返すのでintに変換が必要そう。
 - 親のkは、(k + 1) // 2 で求められそう。
 - あと、根ノードからボトムアップあるいはBFSっぽく全部列挙してくとノード数が発散して処理間に合わなそうだから、トップダウンで欲しい(n,k)地点ノードから逆算して葉から根に向かう探索パス1本だけで求めた方が良さそう。
 - 探索パスとしては、DFSっぽい挙動のトップダウンという感じ? 今回は、再帰の子分が親ノードなのか、いつもの感覚と逆だ。
 - 上記のように整理したら、自分でスムーズに実装できた。下記の点を修正するとAC。初見の時はナンダコレハ...?状態だったのでうれしすぎる。
   - return で返す値は、int()でくくってあげることが必要。(notの作用により、1を返すべきテストケースでTrueが返った。)
## 解法1:トップダウン再帰:AC
 - イメージは二分木と言いつつ、node構造を使ってないので、全然別の方法でも解けるのかもしれない。
 - ボトムアップは、多分不要なものも舐めて見てしまうので忌避感がある。
 - 時間・空間計算量:O(n)?
```py
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        def search_kth_in_n_rows(n: int, k: int):
            if n == 1:
                return 0
            
            if k % 2:
                return search_kth_in_n_rows(n-1, (k+1) // 2)
            else:
                return not search_kth_in_n_rows(n-1, (k+1) // 2)
        return int(search_kth_in_n_rows(n, k))
```

# Step2
 - 他の解法、思いつかない。解法の幅を持ちたい。PR見る。
## 解法1:トップダウン再帰(関数なしver.):AC
 - https://github.com/hayashi-ay/leetcode/pull/46/files
   - (これはこの問題に限らず、最近自覚し始めた感覚ですが、二分探索の最後の問題然り、最近この人とコードが似るようになってきている気がする。コーディングでの私の信条はシンプルさと直感性ですが、同じバイブスを感じ、よく参考にさせていただいている。良い影響を受けているのは間違いないので多分良い傾向なのでしょう。)
   - あ、Step1のコードは関数(search_kth_in_n_rows)でおく意味ないじゃん。修正する。
   - (n, k)が同じ顔で2回出てくることに若干違和感あった(n_, k_とかおいた方が良いか？とかも考えていた)ので、このモヤモヤが解消されるし、シンプルだし、こっちの書き方の方が良いかなあ。
   - でも、int(not self.~~~)って見づらい? -> 最終的に Step3 で、1 - self.kthGrammar() の方が良いと感じました。
   - あとreturnが2箇所に分かれてるのもわかりづらいかも。手放しでこちらが良いと言えるわけではないかも。
 - n-1 よりも n - 1 の方が良いというコメントが以前あったが、こういうのはDPや再帰などでコードの中に頻繁に出てくる。頻繁に出てくるものは、なるべくコンパクトに書きたいという気持ちがある。このコードではそんなに多くないが、他のコードとの整合性を考慮した時に、コンパクトな書き方を貫くべきかもと感じる。(スタイルに一貫性があった方が良いと一応リーダブルコードには書いてありました。)
```py
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0
        
        if k % 2:
            return int(self.kthGrammar(n-1, (k+1) // 2))
        else:
            return int(not self.kthGrammar(n-1, (k+1) // 2))
```

 - https://github.com/fhiyo/leetcode/pull/47/files
   - 「ある行は一つ前の行をコピーしてから反転させたものをくっつけた形になっている。」うわほんとだ。マクロ視点ではこんな法則があったのか。
       - (逆に自分の解法は、親ノードと子ノード間の、ミクロな視点の法則を使っていたのか。)
   - コピーしてくっつけるので、ブロックの大きさは、2の階乗で大きくなる。
   - 2の階乗の長さで k を含まないギリギリ直前まで大きくしたブロック A と、その直後に続く同じ長さのブロック B は k を含むということですね。
   - さらに、Bのブロックを反転すると、Aのブロックのバイナリ列に一致するので、 k - power を求めることで、ブロックA内の「対応する位置」に再帰的にたどり着く仕組みになってるのか。
   - これを 再帰的に繰り返せば、最終的に k=1 に到達して答えが確定するということですね。
## 解法2:反転2ブロック(A, B)の利用(n遷移なし):AC
 - k方向(横)だけ考えれば良いのが良いかも。n方向の移動がない。
 - ただ、fhiyoさんのコメントにもあるように、poweredを計算するのが手間か。
```py
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if k == 1:
            return 0

        powered = 1
        while powered * 2 < k:
            powered *= 2
        return int(not self.kthGrammar(n, k - powered))
```

## 解法2':反転2ブロック(A, B)の利用(n遷移あり):AC
 - これは、二分木構造の図のイメージが活きる。
 - 深さ n-1 から n に遷移する時には、バイナリ列が A から A + B (BはAの反転列) になることを使っている。
 - 解法2より、再帰のイメージがいい感じにイメージできるので好き。
 - イメージ図 :
```
 0
 0 1
 0 1 10
 0 1 10 1001
 0 1 10 1001 10010110
```
```
 n-1 |   A
  n  | A + B(<-Aの反転)
```
 - assertは　"assert 条件式, 条件式がFalseの場合に出力するメッセージ"で使えば良さそう。
   - https://docs.python.org/ja/3.10/reference/simple_stmts.html#the-assert-statement
       - ここか？自信ない。
   - https://qiita.com/nannoki/items/15004992b6bb5637a9cd
       - こっちの方がわかりやすかった。
 - 実装のポイント :
   - half_num_elementsの計算には n => 2 が必要
   - 深さ n では、2^(n-1)個のノードがあり、その半分(Aブロック)の個数(長さ)は、2^(n-2)になる
   - 再帰のif分岐は等価なイメージなので、if/elseで書きたい。
 - 二分木構造上でもイメージできて、すごく直感的で好きな解法だった。これは非常に良いですね。二分木というか A, B ブロックのイメージで書ける。
```
 n-1 |   A
  n  | A + B(<-Aの反転)
```
```py
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if k == 1:
            return 0
        assert n >= 2
        half_num_elements = 2 ** (n-2)
        if k > half_num_elements:
            return int(not self.kthGrammar(n-1, k - half_num_elements))
        else:
            return int(self.kthGrammar(n-1, k))
```

# Step3
 - 良いと感じる解法1, 2'で再現性の確認。
 - 本当は、Step2で直すべきだったが、int(not...って書くの嫌になってしまった。1 - self.kthGrammar()の方が良いな。
## 解法1:トップダウン再帰(関数なしver.):AC
 - 最終的に、2分で実装。
 - 実装のポイント :
   - kの偶奇
       - kが奇数の時 : 親と同じ値
       - kが偶数の時 : 親から反転した値
   - 子ノード(n, k)の親ノードは(n-1, (k+1) // 2)の位置のノードになる。
```py
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0
        
        if k % 2:
            return self.kthGrammar(n-1, (k+1) // 2)
        else:
            return 1 - self.kthGrammar(n-1, (k+1) // 2)
```

## 解法2':反転2ブロック(A, B)の利用(n遷移あり):AC
 - こっちの方が解法1より、好きかも。
 - 解法1のミクロな視点より、解法2'のようにマクロの視点でA, Bブロックが見えている方が、なんか見晴らしが良い感じがする。
```
 n-1 |   A
  n  | A + B(<-Aの反転)
```
```py
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if k == 1:
            return 0
        assert n >= 2
        half_num_elements = 2 ** (n-2)
        if k > half_num_elements:
            return 1 - self.kthGrammar(n-1, k - half_num_elements)
        else:
            return self.kthGrammar(n-1, k)
        
```
