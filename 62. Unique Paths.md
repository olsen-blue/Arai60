# Step1
- DPですね。nCrでも解けそう。まあまずはDP。
- 基本的なナップザックDPとかでよくある遷移を意識して書いた。
## 解法1:2次元テーブルのDP:Accepted
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        num_of_paths = [[0] * n for _ in range(m)]
        for c in range(n):
            num_of_paths[0][c] = 1
        for r in range(1, m):
            for c in range(n):
                if c == 0:
                    num_of_paths[r][c] = num_of_paths[r-1][c]
                else:
                    num_of_paths[r][c] = num_of_paths[r-1][c] + num_of_paths[r][c-1]
        return num_of_paths[-1][-1]
```

## 解法2:1次元テーブルのDP:Accepted
- 直前の行の結果のみを用いているので、１行分のリストでも実装できる。直観的ではなくなるが、メモリの節約にはなる。空間計算量が 1/m になる？
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        num_of_paths = [0] * n
        num_of_paths[0] = 1
        for _ in range(m):
            for c in range(n):
                if c == 0:
                    continue
                num_of_paths[c] += num_of_paths[c-1]
        return num_of_paths[-1]
```

## 解法3:nCr組み合わせ:Accepted
- 愚直に階乗を関数化して、それを使う。
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        def factorial(k: int) -> int:
            if k == 0:
                return 1
            return k * factorial(k-1)
        combination = factorial(m + n - 2) // (factorial(m-1) * factorial(n-1))
        return combination
```

# Step2
- PR見て気になるものを読んでみる。
- https://github.com/hroc135/leetcode/pull/31/files#r1898180689
   - この視点はなかった。テストケースは一般的な当たり障りのないものの方が良いのではと思ってしまっていたが、引っかかりやすいのは逆にエッジケースの方であって、こんな感じで機械的に生成してみれば良いのだというのは、新視点だった。なるほど。
- https://github.com/TORUS0818/leetcode/pull/35/files
- https://github.com/Ryotaro25/leetcode_first60/pull/39/files
   - 今回は行方向と列方向が、(それが持つ意味としては)対称的な構造なので、壁際全て1で初期化しても問題ないのか。
   - ナップザックDP意識しすぎているということに気づく。あれは行方向と列方向の意味が変わってくるので、例えば一行目だけ初期化、ということになるんだなあと理解。
- 壁際全て1で初期化
## 解法1:2次元テーブルのDP:Accepted
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        num_of_paths = [[0] * n for _ in range(m)]
        for c in range(n):
            num_of_paths[0][c] = 1
        for r in range(m):
            num_of_paths[r][0] = 1

        for r in range(1, m):
            for c in range(1, n):                
                num_of_paths[r][c] = num_of_paths[r-1][c] + num_of_paths[r][c-1]
        return num_of_paths[-1][-1]
```

## 解法2:1次元テーブルのDP:Accepted
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        num_of_paths = [0] * n
        num_of_paths[0] = 1
        for _ in range(m):
            for c in range(1, n):
                num_of_paths[c] += num_of_paths[c-1]
        return num_of_paths[-1]
```

- https://github.com/TORUS0818/leetcode/pull/35/files#r1836492458
   - 浅いコピーの話は初見。とりあえずは深いコピーにするので良いのでしょうか。。。
   - とりあえず今回はリスト内包表記で書けば浅いコピーにならずに想定した2次元テーブルが用意できそう。
- https://github.com/python/cpython/blob/17d5b9df10f53ae3c09c8b22f27d25d9e83b4b7e/Modules/mathmodule.c#L3805
   - コンビネーションはmathモジュールがあるらしい。数値計算にはあまり惹かれず。理由はないですが個人的に、動きのあるアリゴリズムとかの方が好きです。

## 解法3':nCr組み合わせ:Accepted
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        return comb(m + n - 2, m - 1)
```


- 再帰の解法意外とあるのでやってみるか。
## 解法4:再帰:Accepted
- cacheなしだとTLE
```python
class Solution:
    @cache
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 1 or n == 1:
            return 1
        return self.uniquePaths(m-1, n) + self.uniquePaths(m, n-1)
```

# Step3
- 最もしっくりくる解法1で再現性確認。forの中にifがない方がネストが浅くて良いですね。
## 解法1:2次元テーブルのDP:Accepted
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        num_paths = [[0] * n for _ in range(m)]
        for r in range(m):
            num_paths[r][0] = 1
        for c in range(n):
            num_paths[0][c] = 1
        
        for r in range(1, m):
            for c in range(1, n):
                num_paths[r][c] = num_paths[r-1][c] + num_paths[r][c-1]
        return num_paths[-1][-1]
```
