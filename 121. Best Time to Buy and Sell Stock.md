# Step1
 - 買う日->売る日を決めて、利益を最大化したい。
 - 全体ではなく、各日で獲得できる最大値の結果を記録していき、最後にその中で1番良いものを選べば良い。
 - https://leetcode.com/problems/maximum-subarray/description/
   - 過去の最小値を管理すれば良さそうなので、これと似てる?
 - Accepted。5分くらいで比較的スムーズに書けた。利益ない時は0返すの忘れていたので修正をした。
## 解法1:ボトムアップDP:AC
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        INITIAL_VALUE = - math.inf
        max_profits = [INITIAL_VALUE] * len(prices)
        min_price = prices[0]
        for i in range(1, len(prices)):
            max_profits[i] = prices[i] - min_price
            min_price = min(min_price, prices[i])
        if max(max_profits) <= 0:
            return 0
        return max(max_profits)
```

 - 他の解法。シンプルな2重ループくらいしか思い付かず。
## 解法2:2重ループ:TLE
 - 1 <= prices.length <= 10^5 なのでそりゃそう。
 - Pythonは、O(10^7)くらいまで計算可能という感覚で良いのでしたっけ? 調べましたがドキュメント等に明確な閾値は書いてなかった...のでGPTに聞いた。
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = - math.inf
        for i in range(len(prices) - 1):
            for j in range(i + 1, len(prices)):
                max_profit = max(max_profit, prices[j] - prices[i])
        if max_profit <= 0:
            return 0
        return max_profit
```

# Step2
 - PR見る。
 - https://github.com/hroc135/leetcode/pull/35/files
 - https://github.com/goto-untrapped/Arai60/pull/58/files
   - ん？題意的に、その日のうちに買う&売るはできないので、最小価格の採用をするのは現時点から見て過去でなければならず、つまり最大値の更新の後でなければならないのでは...?
       - 正の利益が出る場合はこれでも問題なさそう?
       - 利益が0以下になる場合は、その日のうちに買う&売るという操作の結果0になっているので、結果としてはACになりそう? でも本当は上で書いたみたいにマイナスの利益が出力されるべき?
       - https://github.com/TORUS0818/leetcode/pull/39/files#r1874242784
           - 同じ指摘があった。やっぱりそうですよね。
 - https://github.com/goto-untrapped/Arai60/pull/58/files
   - 逆方向にループにすれば、最小値ではなく最大値管理になるのか。なるほど。
   - 個人的には、ストーリーの時系列は忠実に守って直感的に書きたいと感じる。あえてそうする理由がない気がする。
       - https://github.com/fhiyo/leetcode/pull/38/files#r1667641801
           - やっぱそうですよね。
 - https://discord.com/channels/1084280443945353267/1192728121644945439/1218818241636339722
   - この考え方に近いかも?
   - 私は融合変換というよりか、forループしながら n 人それぞれ最高の結果を記録していき、最後にその中での1番を選ぶ、というイメージかも。
 - https://github.com/goto-untrapped/Arai60/pull/58/files#r1772314652
   - 完全に同じ考え方の人いた。同意します。
 - 上記のように他のコメントに同意できるようになっていることに気づいた。考えることをなるべく一致させるというのが目的だったはずなので、これは良い傾向かも?
 - https://github.com/TORUS0818/leetcode/pull/39/files
   - 関数型っぽい感覚ってこういうことか。
   - y = f(x)の最大値が欲しくて、説明変数をpricesのindexにして、左側でmin、右側でmaxを求めたら、indexの位置ごとに違う結果になるので、その中で最高のものを採用すれば良いということですね。これは完全に違う視点からの解法なので、ぜひやりましょう。
 - https://docs.python.org/3/library/functions.html#zip
   - zipという子は初めまして。要素を1つずつ取り出して、統合してタプルにするんですね。
## 解法2:関数型の考え方:
 - 実装が重かったが、違う視点の解法で面白かった。
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_prices_from_left = [prices[0]] * len(prices)
        for i in range(1, len(prices)):
            if min_prices_from_left[i - 1] > prices[i]:
                min_prices_from_left[i] = prices[i]
            else:
                min_prices_from_left[i] = min_prices_from_left[i - 1]

        max_prices_from_right = [prices[-1]] * len(prices)
        for i in range(len(prices) - 2, -1, -1):
            if prices[i] > max_prices_from_right[i + 1]:
                max_prices_from_right[i] = prices[i]
            else:
                max_prices_from_right[i] = max_prices_from_right[i + 1]
        
        max_profit = 0
        for min_price, max_price in zip(min_prices_from_left, max_prices_from_right):
            max_profit = max(max_profit, max_price - min_price)
        return max_profit
```

# Step3
## 解法1:ボトムアップDP:AC
 - 最もしっくりきている解法で再現性の確認。
 - math.infはマジックナンバーにギリならないと思っているので、そう書く。
 - 2分くらいでスムーズに実装できた。
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profits = [- math.inf] * len(prices)
        min_price = prices[0]
        for i in range(1, len(prices)):
            max_profits[i] = prices[i] - min_price
            min_price = min(min_price, prices[i])
        
        if max(max_profits) <= 0:
            return 0
        return max(max_profits)
```
