# Step1
 - nの正負で場合分けする。
 - テストデータのみ通るが、submitすると RecursionError: maximum recursion depth exceeded while calling a Python object になってしまう。
 - 再帰の限界になる原因としては、そもそも n が大きすぎるのか。子分に渡す回数が多すぎる。
 - 2^31 = 2*(2^10)^3 = 2*(1024)^3 ≒ O(10^9) 
   - C++でギリいけるか怪しいというぐらいなので、10^7 ~ 10^8 くらいが限界の遅いPythonでは無理がある。
## 解法1:再帰:Runtime Error
```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n > 0:
            return x * self.myPow(x, n - 1)
        if n < 0:
            return 1/x * self.myPow(x, n + 1)
```
 - わからん。解法見る。
 - https://github.com/hayashi-ay/leetcode/pull/41/files
   - 子分に渡すときに n を 1/2 にしてあげれば、子分に渡す回数が減らせるはず。なるほど〜
   - https://drken1215.hatenablog.com/entry/2024/05/14/005025
       - ちょっと違うけど、2の階乗で分割するイメージとしては、これとか近い考え方なのでは。
       - 話逸れるが、0以上の任意整数が2の階乗の総和で表せることを利用している、のかな。(0 or 1のビット列を考えるとこの点明らかに理解できそう。)
## 解法1:再帰:AC
# - 上記の半分にするというヒントだけもらって実装は見ずに書いてみる。AC。
# - うむ。ネストが深いな。
```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n > 0:
            if n % 2 == 0:
                return self.myPow(x, n // 2) ** 2
            else:
                return x * self.myPow(x, (n-1) // 2) ** 2
        if n < 0:
            if n % 2 == 0:
                return self.myPow(x, n // 2) ** 2
            else:
                return 1/x * self.myPow(x, (n+1) // 2) ** 2
```

# Step2
 - https://github.com/hayashi-ay/leetcode/pull/41/files
   - もう一回お手本見てみる。
   - https://github.com/hayashi-ay/leetcode/pull/41/files#r1515413566
       - あー、n がマイナスの時は、こう書く方法もあるのか。なるほど良いかも。
       - if n % 2: でも良いのか。確かにコンパクト。
           - いやでも、偶/奇 と F/T をぱっと出された時に、これらが直感的に一致しているかというと、疑問が残る。
           - 0/1 という値を仲介して、概念として、たまたま繋がっているように見えるだけなのでは。 
           - まあ、n % 2 が 0/1 をなのを考えれば「確かに一致しますね」と思えるかもだが、こういう思考が発生すること自体が認知不可になり得る気がするので、n % 2 == 1 で良くないかと言う気持ちになった。
           - あ、偶奇ではなく、even/odd という表現であれば、納得できそう。
               - 何もなく平坦なイメージ(0) vs 何か違和感などが存在して尖ってるイメージ(1)。(英語ありがとう)
 - https://github.com/hayashi-ay/leetcode/pull/41/files#r1514489206
   - 符号の変換、やっぱこれで良さそう。
## 解法1:再帰:AC
 - n がマイナスの時を if でをまとめる、
```
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1.0 / x
            n = -n

        if n % 2:
            return x * self.myPow(x, (n-1) // 2) ** 2
        else:
            return self.myPow(x, n // 2) ** 2
```

## 解法2:whileループ(切り出し):AC
 - https://github.com/hayashi-ay/leetcode/pull/41/files#r1514105730
   - whileループは思いつかなかった。書こう。
 - https://github.com/hayashi-ay/leetcode/pull/41/files#r1515564458
   - そうなんですよね。トップダウン再帰の、欲しいものを先に宣言できる点が私も気に入ってます。
   - 普段、whileは比較的苦手め。(何をしているのかが再帰の方が追いやすいことが多い気がするため。)
 - https://github.com/fhiyo/leetcode/pull/46/files#r1684470369
   - 「同じ処理を書くならループと再帰のどちらが認知負荷が低いかアンケートを取ったところ、ループのほうが認知負荷が低いと答えた人のほうが多かったです。」
   - whileもっと書いといた方が良さそう...
 - https://drken1215.hatenablog.com/entry/2024/05/14/005025
   - これのイメージで、まず自分で直感的に感じる、whileループの解法で書いみた。AC。
   - デカい n を指数関数的に増加する2の階乗値 factorial_2 で削っていく直感的なイメージが好き(でもこれを伝えるにはコメントがいるかも)。残りがあっても回収できるところも良い。
 - 本当はresultの方もfactorialにしたいが、上記と被るなぁ。
```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1.0 / x
            n = -n

        factorial_2 = 1
        result = 1
        while factorial_2 <= n:
            result *= (x ** factorial_2)
            n -= factorial_2  # n を 2の階乗値で分割していく
            factorial_2 *= 2
        if n > 0:
            result *= (x ** n)

        return result
```

 - https://github.com/hayashi-ay/leetcode/pull/41/files#r1515412661
   - 一方で、このコードが読めなかった。う〜ん。あんまり直感的でないかも。変化するnに対して n%2 の意味が直感的でないから?
 - https://github.com/hayashi-ay/leetcode/pull/41/files#r1515417145
   - これは読めた...! こっちの方が読みやすいですね。
   - 指数 n をビット表現して、ビットシフトしながら、xの階乗値を2乗していくのか。解法2よりこっちの方がコンパクトだが、解法2の方がわかりやすい。
   - https://docs.python.org/3/reference/expressions.html#operator-precedence
       - 好みかもですが、ビットで扱うなら、if n % 2: ではなく、if n & 1: の方が良い気がする。(10進法の数ではなくて、ビットでやってるぞ〜ということが伝わりそうなので)
   - これも好みですが、n >> 1 してから、x を2乗した方が、「次の桁に行くから、2乗操作します。」という流れになって、自然言語的にスムーズで直感的だと感じた。
   - https://qiita.com/7shi/items/41d262ca11ea16d85abc
       - この辺にも目を通す。print(bin(5))ってやると、'0b101'が出力されるのか。'0b'はおそらくビット値であることを示す接頭辞みたいなものでしょう。
           - https://docs.python.org/ja/3/reference/lexical_analysis.html#integer-literals
               - この辺だろうか。なんか違う...?
       - https://docs.python.org/ja/3/library/functions.html#bin
           - bin()関数って、いつ使うんだろう...
           - GPT : 「bin() は主に デバッグや可視化のために使う のが一般的です。」 
           - なるほど。とりあえず今回やりたい「n の 2^0の位が1かどうかの確認」は、if n & 1:で良さそう。

## 解法2':whileループ(ビット処理):AC
 - 3^13 = 3^(8 + 4 + 2*0 + 1) = 3^8 * 3^4 * 1 * 3^1
 - すごいシンプルになって嬉しいが、解法2の方がわかりやすい。
 - https://github.com/hayashi-ay/leetcode/pull/41/files#r1514116166
   - 変数名むずいが、poweredか。べき乗の「べき」は power らしい。冪乗がなされたという意味で powered か。
```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1.0 / x
            n = -n

        powered = 1
        cumulated = x
        while n > 0:
            if n & 1:
                powered *= cumulated
            n >>= 1
            cumulated *= cumulated
        return powered
```

 - その他のPRを見ていく。
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/38/files#r1711522299
   - 本当はビクビクするべきだったのですね(汗)　この辺何もわかっていなかったということがわかりました。
 - https://github.com/Ryotaro25/leetcode_first60/pull/48/files#r1882191228
   - 少なくとも、これをすべきなのはわかるかも。
       - 1/3 みたいな時に、小数になるのを明示した方が良さそう。
   - return 1　とか　result = 1 も、1 ではなく 1.0 って書いた方が良いのかどうかが、分からなかった。(PR見た感じ、どちらの人もいそうだった。)
 - https://github.com/nittoco/leetcode/pull/17/files
 - https://docs.python.org/ja/3/library/functions.html#pow
   - powのドキュメントがあるらしい。読んでみる。
   - モジュラー逆数って何？
       - 上の例だと、「38 * x ≡ 1 (mod 97)」を満たす、xを求めるらしい。何に使うんだ？
       - GPT「モジュラー逆数は、特に数論や暗号学の分野で非常に重要です。主な用途としては、RSA暗号や線形合同式の解法、デジタル署名、組み合わせの計算などがあります。逆数をモジュラー算術で計算することで、非常に効率的にさまざまな数値問題を解くことができます。」
       - なるほど分からん。でも暗号って厨二病感あって面白そう(^^) CSの中でもセキュリティにはなんとなく興味がある。
 - https://github.com/nittoco/leetcode/pull/17/files
 - https://github.com/python/cpython/blob/d5ba4fc9bc9b2d9eff2a90893e8d500e0c367237/Objects/longobject.c#L4849
   - powのCPythonの実装があるらしい。おお〜
   - nittocoさんの解説わかりやすい。本当は自力で読みたい。
   - バイナリ指数法というのが使われているらしいがよく分からなかった。なぜ先頭から見ていくのか...?
  
# Step3
 - 再現性の確認。
## 解法1:再帰:AC
 - 個人的には最もスムーズに書ける。
 - n < 0 の処理は、関数呼ぶのではなく、こうするのが好き。
 - 最終的に2分で実装。
```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1.0 / x
            n = -n
        
        if n % 2:
            return x * self.myPow(x, (n-1) // 2) ** 2
        else:
            return self.myPow(x, n // 2) ** 2
```

## 解法2:whileループ(切り出し):AC
 - whileなら、正直これが1番直感的にかける。
 - デカい n を指数関数的に増加する2の階乗値 bi で削っていく直感的なイメージ
 - 本当は、nは固定値なので小さくしない方が良さそう。
 - 2分くらいで実装
```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1.0 / x
            n = -n
        
        factorial_result = 1
        bi = 1
        while bi <= n:
            factorial_result *= (x ** bi)
            n -= bi
            bi *= 2
        if n > 0:
            factorial_result *= (x ** n)

        return factorial_result
```


## 解法2':whileループ(ビット処理):AC
 - 上の方が直感的だ。
 - 3^13 = 3^(8 + 4 + 2*0 + 1) = 3^8 * 3^4 * 1 * 3^1 のイメージがないと安心して書けない。う〜ん微妙かも。
 - これを時間が経ってからも再現性高く描ける自信があまりない。図さえ描ければ書けるかも。
```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1.0 / x
            n = -n
        
        powered = 1
        cumulated = x
        while n > 0:
            if n & 1:
                powered *= cumulated
            n >>= 1
            cumulated *= cumulated
        return powered
```

- 感想
- 解法2'以外の解法で解きたい...
