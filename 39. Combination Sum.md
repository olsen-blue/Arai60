# Step1
 - 前問と近い感覚で解けそう。加算バージョンはその場で足踏みして、子分の再帰に渡す。
 - 個数無制限ナップザックDPっぽさを感じたが、個数の組み合わせと累積和を同時に考えるのがややこしすぎて混乱しそうなのでやめた。どんなデータ構造用意が良いかもピンと来なかった。(Step2で、この方向性でも解けることが判明。)
## 解法1:バックトラック再帰:AC
 - 先に加算なしバージョンの再帰を行う、pop()の意図が、共通参照されるリストのバックトラックの目的のみ、という解法。
 - 加算する場合は、同じindexで足踏みさせるイメージで子分に引き継ぐ。
 - totalのバックトラックが不要なのは、イミュータブルなオブジェクトなので個々の再帰関数ごとに分離してtotalというローカル変数として管理されるため。
 - バックトラック、今の探索深さから撤収する際のお片付け or 掃除に見えてきた。行儀のよい行動ですね。
```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        def traverse_candidates(index, total, combination):
            if index == len(candidates):
                return
            if total > target:
                return
            if total == target:
                all_combinations.append(combination.copy())
                return

            traverse_candidates(index + 1, total, combination)

            total += candidates[index]
            combination.append(candidates[index])
            traverse_candidates(index, total, combination)

            combination.pop()
        traverse_candidates(0, 0, [])
        return all_combinations
```
        
## 解法1':バックトラック再帰:AC
 - 先に加算バージョンの再帰を行う、pop()の意図がより直感的な解法。
 - 対称的で綺麗なのも好きかも。
 - あ、return書くのは枝刈りの気持ちかも。
 - コードを書く時の信条が、シンプルさと直感性なのですが、後者がより強いこちらの方が好み。
   - とはいえ、バックトラックは必要なので、解法1でも納得できることが必要という認識。
 - あ、でもこっちのバックトラックは、今の探索深さから撤収する際のお片付け or 掃除にはあまり見えない... 
   - う～ん。「選ばない場合で遷移する再帰のための処理である」という主張の方が強く見える。図らずも片付けができちゃってる感じかも。これらの２つの意味がはっきりと分離されていないというモヤモヤはありますね。
```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        def traverse_candidates(index, total, combination):
            if index == len(candidates):
                return
            if total > target:
                return
            if total == target:
                all_combinations.append(combination.copy())
                return
            total += candidates[index]
            combination.append(candidates[index])
            traverse_candidates(index, total, combination)

            total -= candidates[index]
            combination.pop()
            traverse_candidates(index + 1, total, combination)
        traverse_candidates(0, 0, [])
        return all_combinations
```

## 解法2:stackループ:AC
 - https://github.com/nittoco/leetcode/pull/19/files#r1644763510
   - 「全ての再帰関数は、同じロジックを用いたまま、ループで書き直すことができます。」
 - https://discord.com/channels/1084280443945353267/1233603535862628432/1238707903196565546
   - やっぱり、このイメージが的確で分かりやすい。
 - 以前はstackループに苦手意識があったが、上の２つの考え方のおかげで、かなり理解が進んだ感覚があり、下記のコードも非常にスムーズに再帰->stackループの書き換えが出来た。嬉しいです。ありがとうございます。
```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        stack = [(0, 0 , [])]

        while stack:
            index, total, combination = stack.pop()
            if index == len(candidates):
                continue
            if total > target:
                continue
            if total == target:
                all_combinations.append(combination)
                continue

            stack.append((index + 1, total, combination))
            stack.append((index, total + candidates[index], combination + [candidates[index]]))
        
        return all_combinations
```

# Step2
 - やりたいことやって満足したのでPR見る。
 - https://github.com/hayashi-ay/leetcode/pull/65/files
   - 読みやすい。前問を参考にさせていただいていたのでかなり近いコードになった。
 - https://github.com/Mike0121/LeetCode/pull/1/files
   - ifのネストが読みにくいと感じた。if チェックをいくつかに分離したいと感じた。
   - あと target は固定値にしたいという感情を持った。
 - https://github.com/Mike0121/LeetCode/pull/1/files
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/57/files#r1741307179
   - 計算量がわからない。(indexの足踏みするので... )
   - 「最悪空間計算量は、O(target/min(candidates))でしょうか？」
       - これはなんとなくわかる気がする...
   - 「選択肢がcandidate数分(N)あり、最大の木の深さがtarget/min(candidates)のため、最大で計算は、根ノード分を考慮しN^(target/min(candidates) + 1)繰り返されるイメージです。」
       - なるほど。最悪時間計算量は確かにこんな感じで良さそう。
   - https://discord.com/channels/1084280443945353267/1233295449985650688/1242103186009886862
       - だいぶ難しい数学の話みたい...
 - https://github.com/Mike0121/LeetCode/pull/1/files#r1577899538
   - 確かに一般にパラメータの数は少ない方がいいですね。
   - https://github.com/olsen-blue/Arai60/pull/52/files#diff-ddd8c09ee41837c8d5bde978403f850a0b08217fb8ec8eac6d0f2ae10e369d04R89
       - でも、今回も上記と同じ感情なんですよね。
 - https://github.com/Mike0121/LeetCode/pull/1/files#r1577902430
   - これはとてもわかります。二分探索とかでも、真っ先に if nums[middle]...まで書いちゃいますね。書いてから右側の...を考えています。
 - https://github.com/Mike0121/LeetCode/pull/1/files#r1577986497
   - これ、dpテーブルのインデックス書くときに、忌避感があり、あまり守れていない。
   - 守れていない理由としては、インデックスが大量にいろんなところに出現しがちなので、大量に発生するものはコンパクトに書きたいという気持ちです。
   - (個人的な好みな気がする...変であればやめた方が良さそう。)
 - https://github.com/nittoco/leetcode/pull/25/files
   - 2重のwhileループ。私は書ける気がしなかった。
       - Step1のように再帰関数->stackループで書くように、まずはしてみようかな。これがしっくりきているので。
   - あ、でもStep3のコードは私のとほぼ一致していますね。気が合いますね。

## 解法3:個数無制限ナップザックDPみたいなDP:AC
 - https://github.com/fhiyo/leetcode/pull/52#issuecomment-2248269934
   - お、DPで解けるらしい。やっぱり個数無制限ナップザックDPっぽく解けるのだろうか？
   - 読んでみると、データ構造がちょっと複雑だけど、まさに個数無制限ナップザックDPっぽい感じだった...！　
   - 数値ではなく、リストのリストをdpテーブルの値として管理する例を初めて見ました。なるほど〜!
```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        sum_combinations = [[] for _ in range(target + 1)]
        sum_combinations[0].append([])
        for candidate in candidates:  # 縦: 使用アイテム
            for sum_value in range(candidate, target + 1):  # 横: sumの値
                for combination in sum_combinations[sum_value - candidate]:  # 遷移元のリスト(値)をループ取り出し
                    sum_combinations[sum_value].append(combination + [candidate])
        return sum_combinations[target]
```

# Step3
 - 再現性の確認。
 - バックトラック練習したいので、解法1の順序のバックトラック処理でやる。スタックも慣れたいので解法2もやる。
## 解法1'':バックトラック再帰:AC
 - total は、どうで代入で新しいオブジェクトが生成されるので、引数に直接代入の式を書いちゃっていいかも。
   - index + 1　は自然に出来ているので、同じ感覚で total も扱えば良いだけじゃん。
   - スッキリするし .append() と .pop() で加算バージョンの再帰呼び出しをサンドイッチで挟めるのも、良いですね。
   - 必要最小限の重要な処理に絞ることで、バックトラック周りの処理の流れが追いやすいと感じました。
       - 空行なしでも、見やすい気がする。良いですね。
 - この修正のおかげで、解法1、解法1'よりも良くなった感覚があります。嬉しい。
```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        def traverse_candidates(index, total, combination):
            if index == len(candidates):
                return
            if total > target:
                return
            if total == target:
                all_combinations.append(combination.copy())
                return
            traverse_candidates(index + 1, total, combination)
            combination.append(candidates[index])
            traverse_candidates(index , total + candidates[index], combination)
            combination.pop()
        traverse_candidates(0, 0, [])
        return all_combinations
```

## 解法2:stackループ:AC
 - https://github.com/nittoco/leetcode/pull/19/files#r1644763510
   - 「全ての再帰関数は、同じロジックを用いたまま、ループで書き直すことができます。」
 - https://discord.com/channels/1084280443945353267/1233603535862628432/1238707903196565546
   - やっぱり、このイメージが的確で分かりやすい。
```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        stack = [(0, 0, [])]
        while stack:
            index, total, combination = stack.pop()
            if index == len(candidates):
                continue
            if total > target:
                continue
            if total == target:
                all_combinations.append(combination)
                continue
            stack.append((index + 1, total, combination))
            stack.append((index, total + candidates[index], combination + [candidates[index]]))
        return all_combinations
```
