# Step1
 - 電車の中で問題見ながら思いついた2ポインタ、WA。テストケースのみAC。あれ？
 - s="aaaaaaa", wordDict=["aaaa","aaa"]という入力の時、WA。貪欲方っぽくにやるのがダメそう。
## 解法1:2ポインタ:WA
```py
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        from_index = 0
        to_index = 1
        while to_index <= len(s):
            subarray_s = s[from_index : to_index]
            if subarray_s in wordDict:
                if to_index == len(s):
                    return True
                from_index = to_index
                to_index = from_index + 1
            else:
                to_index += 1
        return False
```
 - DPの項だし、DPならいけるのか？
 - sの末尾の方からトップダウンが直感的。House Robberを思い出す。
 - まず、ワガママお姫様の宣言がある。それを直属の家臣が受け取る。それから縦割り組織的に指示が浸透していく。
 - 次の家臣への渡し方、少し複雑。wordDictのうちのwordのどれ使うかで、分かれる。wordの数だけ、次の直下の家臣がいる。
 - 一般的に、インデックスの範囲は、開始点を含み・終了点は含まないのが一般的らしいので、そう書いてみる。
 - <= 0 ではなく == 0 の方が良くないか？ 0より小さくならなそうなので。
 - 45/47 でWAになってしまう。なぜだかわからなかったので、o3-miniに聞いてみる。
## 解法2:トップダウンDP:WA
 - is~~と書くと、bool値であることが明示できる気がして、英文法ガバガバですが、この明示性を優先しました。
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        @cache
        def is_can_segmented(tail_index: int)-> bool:
            if tail_index <= 0:
                return True
            for word in wordDict:
                if word == s[tail_index - len(word) : tail_index]:
                    return is_can_segmented(tail_index - len(word))
            return False
        return is_can_segmented(len(s))
```
 - 「このコードは、再帰関数の中で「最初にマッチした単語」で即座に再帰呼び出しの結果を返してしまっています。つまり、ある位置で複数の単語が後ろの部分文字列にマッチする可能性がある場合、最初に見つかった単語の選択肢だけを試し、もしその選択肢が失敗した場合でも他の候補を試しません。そのため、本来なら正しい分割が可能であっても、誤った分割ルートを選んでしまい、最終的に WA（Wrong Answer）となります。」
 - 「深さ優先探索（DFS）の観点から見ると、現在の実装はある探索パスでマッチした単語があった場合に、すぐにその再帰呼び出しの結果を返してしまい、もしそのパスが最終的に失敗しても他の可能な選択肢を試さずに探索を打ち切ってしまうという問題があります。具体的には、ある位置で複数の単語が候補となる場合、たとえば「aaa」と「aaaa」など、最初に見つかった候補で先に進んでしまうと、その先のパスが正しくなくても他の分割方法を試すことがなくなり、全体として誤った結果（WA）になる可能性があります。」
 - なるほど! DFSの現在の探索パスで、分割できないケースのパスを探索しているとすると、他のパスを探索せずに、その分割できないパスで突き進んでしまい結果をすぐに返してしまうのが原因のようだった。
 - ワガママお姫様から指示が出た時は、直属の家臣のうち少なくとも1人が、Trueを返せれば良いということですね。一人の家臣の返り値をすぐに採用してしまっているのが問題なのか。
 - DFSの猪突猛進感のある探索が好きだったのですが、こういう副作用もあるということがわかり、理解が深まって良かったです。
## 解法2:トップダウンDP:AC
 - @cacheなしの計算量は？ 
 - https://github.com/hayashi-ay/leetcode/pull/61/files
   - 「Top Down DP. `n = len(wordDict), m = len(wordDict[i]), k = len(s)`とするとTime ComplexityはO(kmn)になる。状態数がkでcan_splitの中の計算量がO(mn)。」
   - これは @cache がない時のものなのかある時のものなのか分からなかった。
   - sの走査でO(k)、ある地点から採用するwordループでO(n)、採用したwordの長さ文先に進むからO(m)、全て合わせてO(kmn)ってこと？
   - 採用したwordの長さ文先に進むからO(m)がかなり怪しい。
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        @cache
        def is_can_segmented(tail_index: int)-> bool:
            if tail_index == 0:
                return True
            for word in wordDict:
                if word == s[tail_index - len(word) : tail_index]:
                    if is_can_segmented(tail_index - len(word)) == True: # 普段ならこんな風に書かないが今回は必要
                        return True 
            return False
        return is_can_segmented(len(s))
```

 - ボトムアップでもできるだろうと思ったが、直感的でない気がする。
 - (トップダウンは、まず、sが与えられる。それを wordDict 使って削りながら分解できるか？という自然言語的にもすんなりくる説明。)
 - ボトムアップわからんので、諦めて o3-mini に聞いてみた。
 - "is_can_segmented[0] = True " (空文字は常に分割可能とする) が直感に反するので、好きじゃないです。(ないものを分割するってどういうことだ。)
   - あ、コード書いてて思いましたが、Trueにするのって番兵置いてるってことかな？
 - (逆に、トップダウンの基底条件は、tail_indexが0に到達、つまり全て分割できた!ということで、こっちの方が直感的で好きです。)
## 解法3:ボトムアップDP:AC
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        words = set(wordDict)
        is_can_segmented = [False] * (len(s) + 1)  # is_can_segmented[i] : [0, i)の範囲が分割可能かどうか
        is_can_segmented[0] = True
        for i in range(1, len(s) + 1):
            for j in range(i):
                if is_can_segmented[j] and s[j:i] in words:
                    is_can_segmented[i] = True
        return is_can_segmented[len(s)]
```
 - 書いてみたが、今注目している i 地点が、Trueになるかどうかは、それより前の j 地点の結果に、差分として wordDict の word を作用させて、引き継いでいる。
 - 作用させるものが、普段は数値を加算するとかだけど、今回は word になっているのがちょっと特殊なだけで、たしかに、動的計画法ですね。
 - 初手の印象よりは、意外と直感的かも?という気持ちになった。
 - 番兵。ないものを分割するというのがやっぱりしっくりこないですね。
   - https://github.com/quinn-sasha/leetcode/pull/16#discussion_r1976395196
   - https://github.com/olsen-blue/Arai60/pull/5/files#r1901275473
   - あ〜これらと同じ感覚かも。
 - とはいえ、ボトムアップは全体的には直感に反するので忌避感がある。
 - 現状の最推し解法は、解法2のトップダウンDP。
 - https://github.com/olsen-blue/Arai60/pull/35
   - ここでも感じたが、トップダウンは"デカいものを分解"、ボトムアップは"ゼロからの構築"のイメージがある。

# Step2
 - やりたいことやったのでPR見る
 - https://github.com/TORUS0818/leetcode/pull/41/files
 - https://docs.python.org/3/library/stdtypes.html#str.startswith
   - str.startswith()という子がいるらしい。使えそう。
   - ボトムアップ解法の2重ループを1ループにできそう。i, j わかりづらいので。
   - https://github.com/hayashi-ay/leetcode/pull/61/files
       - この辺も参考になりそう。
 - https://github.com/nittoco/leetcode/pull/42/files
   - 「各indexで分割できるか調べる時、wordDictでループを回した方がわかりやすかったかも」
   - ちなみに僕は、for文は、1個ずつ全て取り出すというよりも、1個取り出して固定というイメージの方が考えやすくなることが多い気がします。(脳のメモリを考えた時に、そりゃ当然なのですが...)
   - 2変数関数f(x, y)の文字固定するみたいなイメージかもです。多数のパラメータ動かすと意味不明になるので自然に身についた思考かもしれない。
 - https://github.com/hayashi-ay/leetcode/pull/61#discussion_r1536822342
   - これはいいや。
## 解法3:ボトムアップDP:AC
 - 2重ループは見づらいし、indexの意味づけも面倒くさそうだが、1ループになって良かった。
 - break入れて他の選択肢を試さずに切り上げると、38 / 47だけ通って、WAになった。多分、DFSの探索パス早期切り上げと同じ仕組みでWAになってる(?)
 - ボトムアップは、やっぱ先頭からやるのが構築感があってなんか良い。
 - でもやっぱり、is_can_segmentedに注釈入れる必要があったり、is_can_segmented[0] = True が直感的ではないので、やっぱりトップダウン派です。
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        is_can_segmented = [False] * (len(s) + 1) # [0, i)の範囲が分割可能かどうか
        is_can_segmented[0] = True
        for from_index in range(len(s)):
            if not is_can_segmented[from_index]:
                continue
            for word in wordDict:
                if s.startswith(word, from_index):
                    is_can_segmented[from_index + len(word)] = True
                    # break
        return is_can_segmented[len(s)]
```

## 解法2:トップダウンDP:AC
 - これ、先頭からやっても良くないか？スライスではなく、str.startswith()使えそうなのでやりたい。
 - スライス使うのインデックスがズレないか心配で緊張するので、こっちの方が良い。
 - https://github.com/sakupan102/arai60-practice/pull/40/files#r1632342479
 - https://github.com/SuperHotDogCat/coding-interview/pull/23/files#r1619222086
   - スライスはコピーが生成されちゃうので、メモリの面でも str.startswith() 使う方が良さげ。
 - if not s.startswith(word, from_index):にして、早期continueしてネスト浅くしても良いんですが、これは"範囲外"のnotと違って、わかりづらいのでなんか not は使いたくなかったです。
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        @cache
        def is_can_segmented(from_index: int)-> bool:
            if from_index == len(s):
                return True
            for word in wordDict:
                if s.startswith(word, from_index):
                    if is_can_segmented(from_index + len(word)) == True:
                        return True 
            return False
        return is_can_segmented(0)
```

# Step3
 - 解法2と解法3で、再現性確認。
## 解法3:ボトムアップDP:AC
 - 早期returnにより、from_indexより前が分割できてるのか?チェック / from_indexより先にlen(word)だけ行ったところの処理をする、と注目ポイント(from_index)の前後の処理を別々に考えられるようになるのがすごく良いと感じた。
 - でも最後まで、is_can_segmentedの諸々(注釈が必要であること、初期化の意味が直感的でないこと、要素数の考慮)が好きになれなかった。
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        is_can_segmented = [False] * (len(s) + 1) # [0, i)が分割可能
        is_can_segmented[0] = True
        for from_index in range(len(s)):
            if not is_can_segmented[from_index]:
                continue
            for word in wordDict:
                if s.startswith(word, from_index):
                    is_can_segmented[from_index + len(word)] = True
        return is_can_segmented[-1]
```

## 解法2:トップダウンDP:AC
 - 何回も書いていると、「is_can_segmented(from_index + len(word))」の関数呼び出しが、ワガママお嬢様が直属の家臣に、wordを渡しながら命令している情景が思い浮かんできた。愛着を感じる。
 - return Falseは、ワガママお嬢様の命令を、wordを受け取った直下の家臣が、誰も達成できなかったケースなんだなあと考えると直感的だった。
 - 細かいが、s.startswith(word, from_index) は、自然言語的に自然な関数呼び出し方で良いと感じた。
   - 「sっていう文字列が、wordから始まってるかな？ちなみに、from_indexからの場合ね〜」という感じ。
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        @cache
        def is_can_segmented(from_index) -> bool:
            if from_index == len(s):
                return True
            for word in wordDict:
                if s.startswith(word, from_index):
                    if is_can_segmented(from_index + len(word)) == True:
                        return True
            return False
        return is_can_segmented(0)
```
