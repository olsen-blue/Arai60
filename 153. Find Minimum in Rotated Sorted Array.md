# Step1
 - sorted使うだけでなんか解けてしまったが、何も頭を使っていない。
## 解法1:sorted(nums):AC
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        sorted_nums = sorted(nums)
        return sorted_nums[0]
```
 - 他の解法は？
 - ヒント：ここは二分探索の項
 - https://github.com/hayashi-ay/leetcode/pull/45/files
   - 思いつかなかったので解法見てみる。
   - リストが単調増加なので、最小値(回転前の元々のリストの先頭の数、始点に当たる位置)がどこにあるかは、nums[middle]とnums[-1]の大小関係を見ればよい。 
 - こうやって数学的表現したが、直感的でない気がする。標高の高さのようにもっと良い図的なイメージが頭の中に欲しい。
 - ざっくりの直感的な理解としては、numsを標高として見たときに、「右向きで山登りをしている人がおり、崖を越える前なのか越えた後なのかを調べることでその人の位置から見て左右のどちらかに最小値があるということがわかるので、これにより探索区間を絞って引き継ぐ」ということですかね。
 - 詳細に整理してみる :
   - 昨日までの引き継ぎによると、どこかに最小値が存在しているらしい、探索対象区間[left, right]に対して、今日のmiddleの調査結果を加えて明日に向けて引き継ぎをする。
   - middle = (left + right) // 2 が崖を越えた後か？越える前か？を今日調査する
       - 崖越えた後なら、middleは最小値になりうるし、middle - 1 以降の左側にも最小値が存在し得るので、[left, middle]を探索範囲にして引き継ぐ。
       - 崖越える前なら、 middleは最小値にならないが、middle + 1 以降の右側に最小値が存在し得るので、[middle + 1, right] にして引き継ぐ。
   - 最小値が存在し得る区間を絞っていき、探索範囲に1つだけものが残ったら終了する。(left == rightのとき) 結果的に nums[left]が最小値になる。
   - 初期値としては、[0, len(nums)-1]になる。まだ未探索の状態で、この範囲に最小値が存在しうる。
   - middleの制約条件としては、[left, right - 1]の範囲でmiddleを選べば、探索範囲を小さくすることができる。
       - (追記)下の方の Q1 の内容と関連するが、[0, 1]の状態で、middleを切り上げで計算すると、範囲が小さくならないのでmiddleは切り捨てで求める必要がある。
 - https://github.com/hroc135/leetcode/pull/40/files#r1959934686
   - 崖越えた後がTrue、越える前がFalseで考えている。ほぼ同じ?
 - 引き継ぎをする操作は、崖の前or後のイメージがあるとスムーズに書ける。
## 解法2:二分探索(再帰関数):AC
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        def find_min(left :int, right: int) -> int:
            if left == right:
                return nums[left]
            middle = (left + right) // 2
            if nums[middle] <= nums[right]:
                return find_min(left, middle)
            else:
                return find_min(middle + 1, right)
        return find_min(0, len(nums) - 1)
```

## 解法3:二分探索(while):AC
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            middle = (left + right) // 2
            if nums[middle] <= nums[right]:
                right = middle
            else:
                left = middle + 1
        return nums[left]
```
## 解法3:二分探索(非再帰関数ほぼwhile):AC
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        def find_min(left :int, right: int) -> int:
            while left < right:
                middle = (left + right) // 2
                if nums[middle] <= nums[right]:
                    right = middle
                else:
                    left = middle + 1
            return nums[left]
        return find_min(0, len(nums) - 1)
```

# Step2
 - PR見てみる
 - https://github.com/hroc135/leetcode/pull/40/files
 - 色々な入力への考慮がされている。
   - 「numsが空 -> nums[0]を返そうとしてindex out of range。呼び出し側で弾きたい」
       - 今まで、ここで今書いているプログラムの中で異常入力を弾くしかないのではと思い込んでいたが、このプログラムを呼ぶ側で弾くということも実際の開発現場ではあるのか...
       - 外側で弾けるならならそっちの方がありがたいですね。
   - 「重複要素あり」: これは、実際に開発をしていたらありそうなシチュエーションだと感じた。
       - 最初の要件とは異なる形で、ある日何らかの事情で狭義単調増加でないような、重複するnumsが入力されてきたらどうしよう。
       - 機械的に考えられるエッジケース、例えば、[1, 0, 1, 1, 1]の場合は0を発見できるが、[1, 1, 1, 0, 1]の場合は0を発見できない。
           - 崖を越えるかどうかのイメージのアルゴリズムが通用しない。これはもう全然違う問題なのでは...? 解くなら sorted した後に先頭の要素取得すれば良さそう?
 - https://github.com/Ryotaro25/leetcode_first60/pull/46#discussion_r1869993674
 - odaさんの追加クエスチョンがあるらしい。こういうことが面接で聞かれるのでしょうか??
   - Q1:「2で割る処理がありますがこれは切り捨てでも切り上げでも構わないのでしょうか。」
       - left = 0, right = 1 の時には、middle = 1となるが、right = 1なので、引き継ぎをしても探索区間が小さくならない。つまり終了条件に至らず無限ループを起こす。
       -  (参考)下記で整理したbisect_leftのアルゴリズムは、middleの位置まで探索打ち切り区間(left-1 or right)が伸びてくる。なのでmiddleを、[left, right - 1]のどこかで選べば良い。middleがrightの位置にある時は、探索区間を小さくすることができなさそう。
           - https://github.com/olsen-blue/Arai60/blob/41171886bb6299943cdcdf8e92e08bdc2833580f/349.%20Intersection%20of%20Two%20Arrays.md#step5%E5%89%8D%E6%97%A5%E3%81%BE%E3%81%A7%E3%81%AE%E4%BF%9D%E8%A8%BC%E5%86%85%E5%AE%B9%E6%9C%AC%E6%97%A5%E3%81%AE%E8%AA%BF%E6%9F%BB%E5%86%85%E5%AE%B9%E7%B5%82%E4%BA%86%E6%9D%A1%E4%BB%B6middle%E3%81%AE%E5%88%B6%E7%B4%84%E5%88%9D%E6%9C%9F%E5%80%A4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E6%96%87%E5%AD%97%E3%81%AB%E8%B5%B7%E3%81%93%E3%81%99
           - つまり、bisect_leftも middle = (left + middle) // 2　という切り下げにして、middleがrightに一致しないようにする必要がありそう？
   - Q2: 「nums[middle] <= nums[right] とありますが、これは < でもいいですか。」
       - 今回のコードで見てみると、numsに重複なし(狭義単調増加)なら良いのではと思いました。
       - というか、今回の問題設定的には重複がないなら = になることはないので <= でなはなく < の方が自然で良いかもと感じた。(※ 結局、下の方で逆の考え方になりました。)
   - Q3: 「nums[right] は、nums.back()(<- Pythonならnums[-1]ですかね) でもいいですか。」
       - middle < right <= -1(末尾) という並びでインデックスが配置されている。
       - middleが崖を超えた後ならどうなるか? : nums[middle] < nums[right] <= nums[-1]  
       - middleが崖を超える前ならどうなるか? : nums[right] <= nums[-1] < nums[middle]
           - 以上より、崖を越える前か後かの判定をするのには、nums[-1]でも問題ないが、探索打ち切ったものをまだ使うのがなんか嫌かもしれないので、nums[right]にしたいかも。
           - いや、でもnums[-1]というずっと同じ基準で崖チェックができるので、nums[-1]でも全然いい気がする。チェックの基準となる閾値が不変というのはなんか安心感がある。
               - https://github.com/hroc135/leetcode/pull/40/files#r1959934686
                   - この不変性からくる安心感は、こちらの気持ちと同じでしょうか。
                   - あ、なるほど。nums[-1]使うのであれば、崖の前が F で、崖の後が T なのは引き継ぎ重ねても不変、ということを意識する必要が、ありそう。
                   - nums[-1]を境にT/Fに分断されて、初めから最後までずっと固定される。
               - https://github.com/olsen-blue/Arai60/pull/25#discussion_r1951047075
                   - 別の問題ですが、この問題で targetSum を(減らしていくのではなく)固定値にしたかった時の感情と近いかも。
   - Q4: 「right の初期値は nums.size() でもいいですか。」
       - 今回、最小値の存在する範囲は、numsの全範囲で、[0, len(nums) - 1]という区間の設定にしている。これでやるなら、len(nums)にすると範囲外でダメ。
       - https://github.com/hroc135/leetcode/pull/40/files
           - 「初期値をnums.size()にするのなら区間を半開区間として、かつ比較をnums.back()で行うとできそう」
           - なるほど。区間の持ち方は[left, right)には一応できるか。
           - でもこれだと、nums[right]が範囲外アクセスになり得るので、nums[-1]を使和なければならないということか。
           - う〜ん。これでもできるかもだが、敢えてこれでやる理由がよくわからなかった。不要な縛りを入れている感覚。
 - https://github.com/hroc135/leetcode/pull/40/files#r1959934686
 - https://github.com/seal-azarashi/leetcode/pull/39/files#r1849419449
   - さらにお題が出ている。なんだこれは。でも深く理解したい。
   - 16通りからNGになるものを除いていく。
   - まず、left == right という終了条件にしているので、切り上げだと、left + 1 = right(ex. left=0, right=1)のとき無限ループするので、切り上げ8通りが NG。切り下げの8通りが残る。
   - 次に、rightの初期値len(nums)にすると、nums[right]は範囲外でエラーになるのでダメ。残り8通りから、これに該当する組み合わせ2つを除くと、6通りになる。
   - 最後に、(切り下げかつ、) < かつ、nums[-1]かつ、rightの初期値len(nums)の組み合わせは、left=0, middle=1, right=2などの状況で、nums[middle]==nums[-1]になって、if nums[middle] < nums[-1]: が満たせずに、崖を越える前の処理、left = middle + 1がなされるが、leftが範囲外(2のインデックス位置)になってしまうので、これもNG(最後の1個)。
 - 残った5通りが動くコード。まとめると下記。
   - (切り下げ, <=, nums[right], len(nums) - 1)
   - (切り下げ, <, nums[right], len(nums) - 1)
   - (切り下げ, <=, nums[-1], len(nums) - 1) ＊
   - (切り下げ, <, nums[-1], len(nums) - 1)
   - (切り下げ, <=, nums[-1], len(nums))
 - 4要素に対する、全体的な感想まとめ: ＊印の組み合わせが、一番良いかも。
   - 最後に2要素残った時に無限ループし得るので、切り上げではなく、切り捨てが安全そうなのでこちらを採用したい。(というかそうしないと動かなそう...)
       - 崖がない時(Tしかない時)についても、切り下げであれば、1番左端が最終的に残りそうなのも、良い。
   - <=, < は、強いて言うなら、崖を越えた後の領域は、右端の比較対象(nums[right] or nums[-1])も含むので、一応 <= にすると安心かも。
       - 切り下げにするのであれば、一致することはなさそうなのでどっちでも良いが、敢えて < にするのはソワソワする。<= の方が懐が広くて安心な感じがある。
   - 崖チェックの基準の閾値は一定の方が良いので、nums[right] ではなく nums[-1] がいい。この不変性からくる安心感がある。
       - 崖の前が F で、崖の後が T なのは、nums[-1]の値により分断されて決まっていて、これが引き継ぎ重ねても不変ということを意識するとさらに安心できる。
       - https://github.com/olsen-blue/Arai60/pull/25#discussion_r1951047075
       - 不変性からくる安心感としては、これと近い感情。
   - rightの初期値は、numsの末尾を指し示してこれを含むというのがシンプルかつ直感的なので、len(nums) - 1が良い。
       - 一方、len(nums)ですが、問題を解く前から感じていたこととして、まず指し示しているインデックスを含まないということが直感的でなく、かなり忌避感がある。
       - それと、今回だと、len(nums)初期値だと、必ずnums[right]ではなくnums[-1]を使わなければならなくなる制限もある。
       - あと、上で最後に弾いたNG(1つ)みたいな、よく考慮しないと弾けないようなNGを含み得る副作用もありそう...
       - 上記の理由から、len(nums)は、なるべく避けたい。使うとしてもかなり慎重にならなければならなそう。実際、上の有効組み合わせ5個のうちの1つだけしかない...
 - あと、全体的に、エラーの考慮をするべきケースは、初期状態もしくは、最後に2要素残った瞬間なのかもと感じた。

## 解法2:二分探索(再帰関数):AC
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        def find_min(left: int, right: int) -> int:
            if left == right:
                return nums[left]
            middle = (left + right) // 2
            if nums[middle] <= nums[-1]:
                return find_min(left, middle)
            else:
                return find_min(middle + 1, right)
        return find_min(0, len(nums) - 1)
```

## 解法3:二分探索(非再帰関数ほぼwhile):AC
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        def find_min(left: int, right: int) -> int:
            while left < right:
                middle = (left + right) // 2
                if nums[middle] <= nums[-1]:
                    right = middle
                else:
                    left = middle + 1
            return nums[left]
        return find_min(0, len(nums) - 1)
```
 - Step2書いてみた感想
   - 変えたのはnums[-1]への修正。崖判断の閾値がnums[-1]で一定にする方が良いと感じた。
   - 崖の前がF、崖の後がTで固定というのもイメージとしてあると尚良さそう。

# Step3
## 解法2:二分探索(再帰関数):AC
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        def find_min(left: int, right: int) -> int:
            if left == right:
                return nums[left]
            middle = (left + right) // 2
            if nums[middle] <= nums[-1]:
                return find_min(left, middle)
            else:
                return find_min(middle + 1, right)
        return find_min(0, len(nums) - 1)
```
        
## 解法3:二分探索(非再帰関数ほぼwhile):AC
 - 終了条件を陽に明示できる解法2の方が好きかも。ここで while not(left == right):と書くのはAC出るけどなんか違う気がする。
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        def find_min(left: int, right: int) -> int:
            while left < right:
                middle = (left + right) // 2
                if nums[middle] <= nums[-1]:
                    right = middle
                else:
                    left = middle + 1
            return nums[left]
        return find_min(0, len(nums) - 1)
```
