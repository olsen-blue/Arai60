# Step1
- まずは、DFSで良さそう。
## 解法１：DFS：AC
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        node = root
        if not node:
            return 0
        return 1 + max(self.maxDepth(node.left), self.maxDepth(node.right))
```

## 解法２：BFS：AC
- 自分で書けた。根つき木をイメージしたBFS。
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        depth = 0
        nodes_depth = [root]
        while nodes_depth:
            depth += 1
            nodes_next_depth = []
            for node in nodes_depth:
                if node.left:
                    nodes_next_depth.append(node.left)
                if node.right:
                    nodes_next_depth.append(node.right)
            nodes_depth = nodes_next_depth
        return depth 
```

# Step2
- PR見てみる。概ね同じような解法。
- 階層BFSについては２つリスト用意するのが良いと個人的に同意できた。１つのリスト管理＋スライス、は怖い。
- https://github.com/tarinaihitori/leetcode/pull/21/files#r1859073373

## 解法１：DFS：AC
- Step1のまま。
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        node = root
        if not node:
            return 0
        return 1 + max(self.maxDepth(node.left), self.maxDepth(node.right))
```

## 解法２：BFS：AC
- 「node_in_depth」という変数名に修正。
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        nodes_in_depth = [root]
        depth = 0
        while nodes_in_depth:
            depth += 1
            nodes_in_next_depth = []
            for node in nodes_in_depth:
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            nodes_in_depth = nodes_in_next_depth
        return depth
```

## Step3
- 再現性の確認。
## 解法１：DFS：AC
- 30秒くらいで実装。
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        node = root
        if not node:
            return 0
        return 1 + max(self.maxDepth(node.left), self.maxDepth(node.right))
```
## 解法２：BFS：AC
- 2分で実装。
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        depth = 0
        nodes_in_depth = [root]
        while nodes_in_depth:
            depth += 1
            nodes_in_next_depth = []
            for node in nodes_in_depth:
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            nodes_in_depth = nodes_in_next_depth
        return depth
```
