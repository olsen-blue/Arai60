# Step1
- 「102. Binary Tree Level Order Traversal」をアレンジすれば、よさそう。これ、BFS以外で解けるのだろうか...
- for node in (現在の深さのnodeのリスト):　のように、逆順になるような工夫が必要だと感じる。
- すぐには思いつかなかったので、調べる。スライス操作 or .reverse()メソッドを使うのが手段としてはありそう。
- 「Zigzag」なので、順取り出し・逆順取り出し、を交互に切り替える必要があるとわかる。
- 切り替えは、「スライス：ステップ数値（1 or -1）に「-1」をかける」、「.reverse()：bool値で管理して実行するタイミングを交互に切り替える」のいずれかが良さそう。
- 後者は if を使うことになりそうで、コードが複雑になりそうなので、前者の数値に(-1)をかける方で良いのではと感じる。
## 解法１：根つき構造BFS:WA
- forの取り出しは反転するものの、node.left追加⇒node.right追加の順番が固定なのが、WAの原因、と感じる。
```python
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        nodes_values = []
        nodes_in_depth = [root]
        depth = 1
        direction = 1
        while nodes_in_depth:
            nodes_values_in_depth = []
            nodes_in_next_depth = []
            for node in nodes_in_depth[::direction]:
                nodes_values_in_depth.append(node.val)
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            nodes_values.append(nodes_values_in_depth)
            nodes_in_depth = nodes_in_next_depth
            depth += 1
            direction *= -1
        return nodes_values
```
## 解法１：根つき構造BFS：AC
- nodes_values への”値”追加時に反転させればよいのではと感じて、修正。無事AC。
- "ノード"の格納順は、いじらないほうが、シンプルで良いという感覚。
```python
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        nodes_values = []
        nodes_in_depth = [root]
        depth = 1
        direction = 1
        while nodes_in_depth:
            nodes_values_in_depth = []
            nodes_in_next_depth = []
            for node in nodes_in_depth:
                nodes_values_in_depth.append(node.val)
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            nodes_values.append(nodes_values_in_depth[::direction])
            nodes_in_depth = nodes_in_next_depth
            depth += 1
            direction *= -1
        return nodes_values
```

# Step2
- depthの値によって、reverse()を実行するかどうか切り替える方法。これは素直かつスマートで非常に惹かれる。おそらく読み手にとっても直感的なのではと感じる。
   - https://github.com/hroc135/leetcode/pull/26/files
   - depthをちゃんと生かしつつ、directionという変数を減らせて一石二鳥だと感じる。（結局Step1で検討した.reverse()に回帰してしまった。）
   - .reverse()は値を返さず、元のリストに破壊的変更を加える、ということには注意。
- 入れる時にだけひっくり返す、という感覚でOKそうで、安心。
- https://github.com/goto-untrapped/Arai60/pull/51#discussion_r1749461242
- DFSで解く解法もあったが、個人的に直感的ではないのでやめておく。
```python
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        nodes_values = []
        nodes_in_depth = [root]
        depth = 1
        while nodes_in_depth:
            nodes_values_in_depth = []
            nodes_in_next_depth = []
            for node in nodes_in_depth:
                nodes_values_in_depth.append(node.val)
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            if depth % 2 == 0:
                nodes_values_in_depth.reverse()
            nodes_values.append(nodes_values_in_depth)
            nodes_in_depth = nodes_in_next_depth
            depth += 1
        return nodes_values
```

## Step3
- 再現性の確認。4分半ほどで実装。
- Step1のスライスの解法よりも、Step2以降のように depth の偶奇で場合分けする方法のほうが、直感的で特に違和感を感じることなくスムーズに書くことができた。
- スライスの解法は、それまでの根つき木構造のBFSの思考の脈絡をぶったぎって、何か別の思考をさせられているような感覚が、若干あった気がする。
- とはいえ、様々な解法に触れられたのは「こういうのは良くて、こういうのは良くないかもな」という経験が得られるし、良かったと感じる。
- だいぶ脱線しますが、イチローの名言で好きなのが「遠回りをすることが一番の近道」「無駄なことをしないと合理的になれない」といったものなのですが、一見無価値なこともやってみる価値はあるよなと感じています。下記のodaさんのコメントは以前見つけたものですが、仰る通りだと感じます。（誤った解釈をしていたら、すみません。）
- https://discord.com/channels/1084280443945353267/1206101582861697046/1208473290881110117

```python
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        nodes_in_depth = [root]
        depth = 1
        nodes_values = []
        while nodes_in_depth:
            nodes_in_next_depth = []
            nodes_values_in_depth = []
            for node in nodes_in_depth:
                nodes_values_in_depth.append(node.val)
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            if depth % 2 == 0:
                nodes_values_in_depth.reverse()
            nodes_values.append(nodes_values_in_depth)
            depth += 1
            nodes_in_depth = nodes_in_next_depth
        return nodes_values
```
