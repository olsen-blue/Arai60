# Step1
 - 前問に似てるが障害物があるので、初期化や遷移に工夫が必要。
 - 壁際の初期化は、障害物がある直前まで、1を入れていけば良さそう？
 - 注目しているグリッド座標に障害物がないときだけ、上と左からの足し合わせ遷移を行う感じ？
 - 障害物がある時は何もしないでスキップ。スキップするということはグリッドは0で初期化したいなぁ。
 - 遷移元の位置に障害物があるかどうかを if で条件分岐するのは大変そうなので、やりたくない。注目しているグリッド座標が障害物かどうかで if 分岐したい。
 - 実装してみる。一応通りました。嬉しい。
## 解法1:2次元の動的計画法(先にエッジ初期化)
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        num_rows = len(obstacleGrid)
        num_cols = len(obstacleGrid[0])
        num_of_paths = [[0] * num_cols for _ in range(num_rows)]
        for r in range(num_rows):
            if obstacleGrid[r][0] == 1:
                break
            num_of_paths[r][0] = 1
        for c in range(num_cols):
            if obstacleGrid[0][c] == 1:
                break
            num_of_paths[0][c] = 1
        
        for r in range(1, num_rows):
            for c in range(1, num_cols):
                if obstacleGrid[r][c] == 1:
                    continue
                num_of_paths[r][c] = num_of_paths[r - 1][c] + num_of_paths[r][c - 1]
        return num_of_paths[-1][-1]
```
 - 壁際のエッジの扱いは、２重for文の中で考えると面倒なので、こうやってさっさと別扱いで初期化できるなら、その方が良さそうということに気づく。
# Step2
 - セルフツッコミ。
 - あ、1がマジックナンバーなので、「OBSTACLE = 1」とした方が良いな。
 - r, c ではなく、row, colで書くべきというコメントがあるかもしれない。インデックスは、複数箇所に出現するし、シンプルに短く書きたいので、私は r, c 推しです。
 - PRに目を通して気になるものを読んでみる。
 - https://github.com/philip82148/leetcode-arai60/pull/10/files
   - あらいけない。入力が空リストとかだった時の考慮ができてなさそう。[]か[[]]のときは早期returnしたい。前問でも考えるべきだったかもしれない...
       - obstacleGrid = [] : len(obstacleGrid)が0, len(obstacleGrid[0])がエラー。
       - obstacleGrid = [[]] : len(obstacleGrid)が1, len(obstacleGrid[0])が0になる。
           - この、1行0列 とかいう状態、極めて直感に反するので気持ちが悪い(あるのかないのかはっきりしてちょうだいという感情)、これは是非とも早期returnしたい。
       - これらは見つけ次第、return 0 すれば良さそう。
   - 一行分 or 一列分 のエッジケースは脳内でシミュレーションしたが、初期化の処理でうまく扱えていそう。
       - 「for r in range(1, 1):」のfor文は、エラーにならずきちんと(実行が)スキップされるらしい。図らずも救われていた...汗
 - 他の解法に関する感情 :
   - 再帰で解いているものもあった。う〜ん、二次元平面の具体的なイメージがあり、これを利用するのが自然なので、あまり乗り気になれない。
   - 1次元DPもあった。obstacleがあるかどうかを２次元で見ているので、テーブルだけ1次元にするの、なんか嫌。
 - あえて、障害物ありの時は、初期化に加えて、num_of_paths[r][c] = 0 って明示的にしても良い気がした。くどいでしょうか。
 - https://github.com/hayashi-ay/leetcode/blob/99583536e1b149d0db2da4985b87a2828f379e8d/63.%20Unique%20Paths%20II.md
   - ほぼ同じコードを見つけた。やっぱ「OBSTACLE = 1」が良いですよね。
   - hayashi-ay さんのコード、必要最低限・シンプルな感じの傾向で好きがちです。(私もそう書きたいと思っているため。)
 - https://github.com/hayashi-ay/leetcode/pull/44/files#r1517508640
    - あえて、2重for文の中だけで、初期化を含めて完結させる変形は、トライしても良いかもしれない。 Step2でこれをやろう。
## 解法1:2次元の動的計画法(先にエッジ初期化)
 - まず、Step1のものを修正。
 - 「OBSTACLE = 1」、[]と[[]]の時の早期returnを追加、num_of_paths[r][c] = 0 を明示する。
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if not obstacleGrid or not obstacleGrid[0]: # [] or [[]] の時早期return
            return 0
        OBSTACLE = 1
        num_rows = len(obstacleGrid)
        num_cols = len(obstacleGrid[0])
        num_of_paths = [[0] * num_cols for _ in range(num_rows)]
        for r in range(num_rows):
            if obstacleGrid[r][0] == OBSTACLE:
                break
            num_of_paths[r][0] = 1
        for c in range(num_cols):
            if obstacleGrid[0][c] == OBSTACLE:
                break
            num_of_paths[0][c] = 1
        
        for r in range(1, num_rows):
            for c in range(1, num_cols):
                if obstacleGrid[r][c] == OBSTACLE:
                    num_of_paths[r][c] = 0
                    continue
                num_of_paths[r][c] = num_of_paths[r - 1][c] + num_of_paths[r][c - 1]
        return num_of_paths[-1][-1]
```

## 解法2:2次元の動的計画法(先にエッジ初期化をしないでみる)
 - 一気に大変になった。緊急度の高いものから早期returnする必要がありそうだが、ここの順序に気を配るのに神経を使った...汗
 - 人間が一度に考えられることには限りがあるので、なるべく分けた方が良いということを実感。関数化することと同じ考え方ですね...
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if not obstacleGrid or not obstacleGrid[0]: # [] or [[]] の時早期return
            return 0
        OBSTACLE = 1
        num_rows = len(obstacleGrid)
        num_cols = len(obstacleGrid[0])
        num_of_paths = [[0] * num_cols for _ in range(num_rows)]
        for r in range(num_rows):
            for c in range(num_cols):
                if obstacleGrid[r][c] == OBSTACLE:
                    num_of_paths[r][c] = 0
                    continue
                if r == 0 and c == 0:
                    num_of_paths[r][c] = 1
                    continue
                if r == 0:
                    num_of_paths[r][c] = num_of_paths[r][c - 1]
                    continue
                if c == 0:
                    num_of_paths[r][c] = num_of_paths[r - 1][c]
                    continue
                num_of_paths[r][c] = num_of_paths[r - 1][c] + num_of_paths[r][c - 1]
        return num_of_paths[-1][-1]
```
# Step3
 - しっくりきた解法1で再現性の確認。
## 解法1:2次元の動的計画法(先にエッジ初期化)
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if not obstacleGrid or not obstacleGrid[0]:
            return 0
        OBSTACLE = 1
        num_rows = len(obstacleGrid)
        num_cols = len(obstacleGrid[0])
        num_of_paths = [[0] * num_cols for _ in range(num_rows)]
        for r in range(num_rows):
            if obstacleGrid[r][0] == OBSTACLE:
                break
            num_of_paths[r][0] = 1
        for c in range(num_cols):
            if obstacleGrid[0][c] == OBSTACLE:
                break
            num_of_paths[0][c] = 1

        for r in range(1, num_rows):
            for c in range(1, num_cols):
                if obstacleGrid[r][c] == OBSTACLE:
                    num_of_paths[r][c] = 0
                    continue
                num_of_paths[r][c] = num_of_paths[r - 1][c] + num_of_paths[r][c - 1]
        return num_of_paths[-1][-1]
```
