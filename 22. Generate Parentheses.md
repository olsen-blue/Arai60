# Step1
 - バックトラックを理解するためにサーバーを漁りまくったときにmikeさんのコードを読んでいたので大体のロジックは理解していた。
 - そもそも well-formed って、なんだろう。開きカッコと閉じカッコが順序正しく並んでいるということかな。
 - 構築中の combination の状況をどうモニタリングするかが大事。前問はシンプルにリストと和で管理していたが...
 - 構築時に()のどちらを使うかで子分への渡し方が分かれるのか。
 - ()それぞれの個数を見ればよいのかも。
   - 引き継ぎにおいては、)の数は(の数を超えてはいけないように管理されていることが保証されている。
## 解法1:バックトラック:AC
 - 閉じカッコを追加して再帰するときは if チェックが必要なのが前問までとは違う点だが、他はほぼ同じ考え方。
   - 子分の再帰呼び出しの時に、()のどちらかを追加しない選択肢がないので、バックトラックがそれぞれで必ず必要というのもちょっと違いますね。
 - https://docs.python.org/ja/3/library/stdtypes.html#bytearray.join
   - "".join(iterable) は、iterable (リスト・タプル・文字列など) の要素を "" (空文字) で連結するメソッド
   - https://ejje.weblio.jp/content/join
       - join に連結という意味があるの知らなかった。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        all_combinations = []
        combination = []
        def generate_combinations(num_open, num_close):
            if num_open > n or num_close > n:
                return
            if num_open == n and num_close == n:
                all_combinations.append("".join(combination.copy()))
                return
            combination.append('(')
            generate_combinations(num_open + 1, num_close)
            combination.pop()
            if num_open > num_close:
                combination.append(')')
                generate_combinations(num_open, num_close + 1)
                combination.pop()
        generate_combinations(0, 0)
        return all_combinations
```
            
## 解法1':バックトラック:AC
 - 構築中の combination(リスト)を文字列にするとどうなるか？ということが気になったので試す。
   - （二分探索のときに、面白そうな変形や他の考慮を試すと理解が深められて嬉しい結果になる傾向があるかも、という気付きがありました。） 
 - 文字列はイミュータブルなオブジェクトなので、各再帰関数呼びだしごとに代入処理等をすると、再帰関数内の(ローカル)変数名は、代入処理によって生成された新しいオブジェクトにバインドされる。（関数呼び出し後・代入処理前にバインドされていた元のオブジェクトからは切り離される）
 - つまり、再帰関数ごとのローカル変数にバインドされるオブジェクトとして新規に生成されて別々・独立で管理されるので、バックトラックが不要になり、再帰関数の引数に与えるのが良い。
 - ただ、新規生成分の無駄なメモリを使うことになってしまう。 
 - 総論チックになりますが、バックトラックの問題にいくつか取り組むと、ミュータブル・イミュータブル、名前空間あたりの話題に対する理解が深められた気がする。個人的には収穫がたくさんありました。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        all_combinations = []
        def generate_combinations(combination: str, num_open: int, num_close: int):
            if num_open > n or num_close > n:
                return
            if num_open == n and num_close == n:
                all_combinations.append(combination)
                return
            generate_combinations(combination + '(', num_open + 1, num_close)
            if num_open > num_close:
                generate_combinations(combination + ')', num_open, num_close + 1)
        generate_combinations("", 0, 0)
        return all_combinations
```

## 解法2:stackループ:AC    
 - 前問に引き続き下記の考え方で再帰をスタックのループに直して書いてみる。すんなり再帰をループに直せるようになってきた。
   - https://github.com/nittoco/leetcode/pull/19/files#r1644763510
       - 「全ての再帰関数は、同じロジックを用いたまま、ループで書き直すことができます。」
   - https://discord.com/channels/1084280443945353267/1233603535862628432/1238707903196565546
       - やっぱり、このイメージが的確で分かりやすい。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        all_combinations = []
        stack = [([] ,0, 0)]
        while stack:
            combination, num_open, num_close = stack.pop()
            if num_open > n or num_close > n:
                continue
            if num_open == n and num_close == n:
                all_combinations.append("".join(combination))
                continue
            stack.append((combination + ["("], num_open + 1, num_close))
            if num_open > num_close:
                stack.append((combination + [")"], num_open, num_close + 1))
        return all_combinations
```

# Step2
 - やりたいことはやって満足したのでPR見る。
 - https://github.com/hayashi-ay/leetcode/pull/70/files#diff-f09bc4caa2343f04592a1bdcc48b3303c4f95bfa6f334c126dc596850115384eR146
   - 枝刈りって言葉では聞いていたけど、無駄な探索パスを打ち切る処理なんですね。これはやった方が良いな。
## 解法1:バックトラック:AC
 - 枝刈りすると、基底条件の if チェクが一つ減った。良いですね。
 - 結果オーライですが、子分への受け渡しも if で粒が揃って見た目も綺麗になったかも。
 - https://github.com/hayashi-ay/leetcode/pull/70/files#diff-f09bc4caa2343f04592a1bdcc48b3303c4f95bfa6f334c126dc596850115384eR168
   - これと同じ感じになった。気が合いますね。
   - https://docs.python.org/3/library/stdtypes.html#bytes.join
       - "".join()が文字列オブジェクトを返すので、combination.copy()じゃなくても良いのか。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        all_combinations = []
        combination = []
        def generate_combinations(num_open, num_close):
            if num_open == n and num_close == n:
                all_combinations.append("".join(combination))
                return

            if num_open < n:
                combination.append('(')
                generate_combinations(num_open + 1, num_close)
                combination.pop()
            if num_open > num_close:
                combination.append(')')
                generate_combinations(num_open, num_close + 1)
                combination.pop()

        generate_combinations(0, 0)
        return all_combinations
```

## 解法2:stackループ:AC    
 - 同様に枝刈りするように修正。
 - https://github.com/nittoco/leetcode/pull/43/files#diff-62778545fff90ce16cc1a78dbaa218572d82b170888eb22c32a759604105a14bR149-R162
   - 完全に同じだ。良いのでは。
 - https://github.com/quinn-sasha/leetcode/pull/18#discussion_r1997562362
   - 次の状態に引き継ぐときに無駄な(追加などの)操作をしない、というのは一般的に重要なことなのかもと感じた。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        all_combinations = []
        stack = [([] ,0, 0)]
        while stack:
            combination, num_open, num_close = stack.pop()
            if num_open == n and num_close == n:
                all_combinations.append("".join(combination))
                continue
            if num_open < n:
                stack.append((combination + ["("], num_open + 1, num_close))
            if num_open > num_close:
                stack.append((combination + [")"], num_open, num_close + 1))
        return all_combinations
```

 - https://github.com/shining-ai/leetcode/blob/main/arai60/50-53_Greedy_Backtracking/53_22_Generate%20Parentheses/rework.py
   - ()の残りの数で考えている。
   - https://github.com/saagchicken/coding_practice/pull/10/files#r1995442298
       - う〜ん。私は実体のあるものベースで考えたいんですよね。不在ではなく実在で考えるのが素直だと思っています。
 - https://github.com/Ryotaro25/leetcode_first60/pull/58/files#diff-7e65a6bdb14090b6a92aabfc5da91111608fa7405573c396d8ebe5d002c64c10R43-R45
   - 私はyieldあんまり好きじゃないですね。generateParenthesisをタスクを任せる部下として見たときに、成果物は五月雨式の都度報告ではなく、まとめてリストで一度に出してくれと思うので。
   - https://zenn.dev/nakurei/articles/understanding-python-generators
       - でも、利点はありそう。
 - https://github.com/Ryotaro25/leetcode_first60/pull/58/files#diff-7e65a6bdb14090b6a92aabfc5da91111608fa7405573c396d8ebe5d002c64c10R53
   - カタラン数、名前だけ聞いたことある。もう忘れました。(SWEの常識には入らなそう)
   - https://github.com/Yoshiki-Iwasa/Arai60/pull/58/files#diff-7a1b3800d88a2f6769d053ad1ce50e2e5cd823e93c303f712b9c9dd7ebfc7811R26-R28
   - https://stchopin.hatenablog.com/entry/2023/06/18/201048
       - 多分受験数学で、この組み合わせ経路の図は見たことあるかも。これわかりやすいですね。
 - https://github.com/nittoco/leetcode/pull/43/files#r1913427084
   - オーソドックスなものが好きなので、とりあえず解いた解法で良さそうで安心。
 - https://github.com/frinfo702/software-engineering-association/pull/10/files#diff-a9c0aa94f36eef7dfb64df91e43bd055bb2b12c7edfa05487a30ab471f1488f2R10
   - 基底条件の if 条件が本当にこれで良いのかは、内部の実装をよく読む必要がありそう。この点、認知負荷が高いと感じる。 ()別々でカウントする方が良いと感じる。

## 解法3:仕事の引き継ぎ(バックトラック):AC
 - https://discord.com/channels/1084280443945353267/1218823830743547914/1231546400714788864
 - 開き+閉じ*(0~追加可能最大数)を親分が追加して、子分に渡す再帰。
   - なるほど。どう書くのかパッとわからなかったのでGPTに聞く。
   - ( を先に1個だけ追加して、) を追加するパターンを全て網羅して、子分に渡す。
   - 子分が受け取った引き継ぎに対して、( を先に1個だけ追加するのはなぜ？ ( を追加するパターンはないのか？ということが気になった。
   - あ、これは子分の親分と同じ深さにいる、forループで網羅される親分の兄弟がした仕事において、追加可能な最大数までの全てのケースを網羅して ) を追加するという仕事がなされるので、(ちょっと遠いところだが、他の枝の再帰呼び出しにおいて)十分に考慮されていますね。
 - 言葉だけだど限界あるので下記のイメージ図に整理して理解。(図が描けるようになってきた。）
### 子分は初手 "(" 追加してOKであることを理解するためのイメージ図:
```
    親親分 
      ├─ 親分1:  ")" を0個追加
      |   ├─ 子分1-1 : 【質問】「あれれ、私は初手 ")" 追加のケースは考慮しなくていいの？」
      |   └─ 子分1-2 : 【質問】「あれれ、私は初手 ")" 追加のケースは考慮しなくていいの？)」
      |
      ├─ 親分2: ")" をいくつか追加
      |   ├─ 子分2-1 : 【質問】「あれれ、私は初手 ")" 追加のケースは考慮しなくていいの？」
      |   └─ 子分2-2 : 【質問】「あれれ、私は初手 ")" 追加のケースは考慮しなくていいの？」
      |
      └─ 親分3: ")" を最大数まで追加 -> 【＊回答＊】:「私が最大数 ")" を追加してるので大丈夫!!」
          ├─ 子分3-1 : 【コメント】「私は安心して "(" 追加できますわ。」
          └─ 子分3-2 : 【コメント】「私は安心して "(" 追加できますわ。」
```
 - なので、子分は安心して、まず1個 ( を追加して大丈夫。
 - 書いてみる。バックトラックの練習のためにあえてリストで書いたが、バックトラックの処理が複雑で手こずった。
 - 詰まって修正した点:
   - ")" * num_adding_close　は、1要素の文字列としてappendされるので、pop()は1回だけで良い。
   - forの中の .pop() は、")" * num_adding_close を除去するバックトラックで、for抜けた後の .pop() は最初に追加した "(" の除去。どっちも必要。
     - バックトラックで append() 書いたら、即 .pop() を(同じ階層で)書くべきだと感じた。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        all_combinations = []
        combination = []
        def generate_combinations(num_open, num_close):
            if num_open == n and num_close == n:
                all_combinations.append("".join(combination))
                return
            if num_open < n:
                combination.append("(")
                next_num_open = num_open + 1
                max_num_adding_close = next_num_open - num_close
                for num_adding_close in range(max_num_adding_close + 1):
                    combination.append(")" * num_adding_close)
                    next_num_close = num_close + num_adding_close    
                    generate_combinations(next_num_open, next_num_close)          
                    combination.pop()
                combination.pop()
        generate_combinations(0, 0)
        return all_combinations
```
            
## 解法3':仕事の引き継ぎ(バックトラックなし):AC
 - バックトラック意外と大変だったので、combination: str にして、バックトラック不要のバージョンを書いてみる。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        all_combinations = []
        def generate_combinations(combination: str, num_open: int, num_close: int):
            if num_open == n and num_close == n:
                all_combinations.append("".join(combination))
                return
            if num_open < n:
                next_num_open = num_open + 1
                added_open_combination = combination + "("
                max_num_adding_close = next_num_open - num_close
                for num_adding_close in range(max_num_adding_close + 1):
                    next_combination = added_open_combination + ")" * num_adding_close
                    next_num_close = num_close + num_adding_close    
                    generate_combinations(next_combination, next_num_open, next_num_close)          
        generate_combinations("", 0, 0)
        return all_combinations
```
 - ここまで書いてみての感想:
   - 解法3, 3'の引き継ぎの解法、最初はなんじゃコレという感じだったが、書いてみるとかなり良い気がする。
       - 仕事の内容が、直感的なのが好き。行けるとこまで ")" を追加するケースを網羅したい、という人間的な意志・感情みたいなものを感じるのがすごく良いですね。
   - 一方で、解法1,2は、1個だけ "(" or ")" を追加するので、まあ、これでもうまくいくんでしょうが、やっている作業の粒が細かすぎてで、ちょっと味気ない感じがする。
       - 感覚としては、例えば、映画のほんの一瞬の数秒だけ切り取ったもの見せられても、多分何も面白くないのと同じかも。

# Step3
 - 解法1, 解法3で再現性の確認。3より3'の方がバックトラックの練習になりそう。
## 解法1:バックトラック:AC
 - 3分半で実装。やっぱりちょっと味気ないですね。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        result = []
        combination = []
        def generate_combinations(num_open, num_close):
            if num_open == n and num_close == n:
                result.append("".join(combination))
                return
            if num_open < n:
                combination.append("(")
                generate_combinations(num_open + 1, num_close)
                combination.pop()
            if num_open > num_close:
                combination.append(")")
                generate_combinations(num_open, num_close + 1)
                combination.pop()
        generate_combinations(0, 0)
        return result
```

## 解法3:仕事の引き継ぎ(バックトラック):AC
 - 実装重めですが、直感的でやっぱり良いですね。行けるとこまで ")" を追加するケースを網羅したい、という人間的な意志・感情みたいなものを感じるのがすごく良いです
 - .append() 書いたら、どうせ後で .pop() が必要なので、即すぐ下に(同じ階層で) .pop() って書いた方が良いな。
   - 諸々書き終えてから最後に.pop()追記しようとするのがそもそも良くない。そりゃ忘れるわ。
 - 見た目的に、ネストが深くなるのが嫌なので、if num_open < n: の枝刈りより、if num_open > n: の早期returnの方が好きかも。(無駄なことしているのは承知の上)
 - 最終的に5分で実装。
```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        result = []
        combination = []
        def generate_combinations(num_open, num_close):
            if num_open > n:
                return
            if num_open == n and num_close == n:
                result.append("".join(combination))
                return
            combination.append("(")
            next_num_open = num_open + 1
            max_num_adding_close = next_num_open - num_close
            for num_adding_close in range(max_num_adding_close + 1):
                combination.append(")" * num_adding_close)
                next_num_close = num_close + num_adding_close
                generate_combinations(next_num_open, next_num_close)
                combination.pop()
            combination.pop()
        generate_combinations(0, 0)
        return result
```
