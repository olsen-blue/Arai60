# Step1
 - 競プロとかでよくある、最適解(最大値・最小値)を二分探索で求めるやつですかね。
   - https://atcoder.jp/contests/abc023/tasks/abc023_d
 - これは数直線上での最小値つまり、FF...FFTT...TTの境界を求める問題ですね。(最大値であればTT...TTFF...FFの境界を求める問題になりますね。)
   - 「最小値」という意味では1つ欲しいものがある状態とも言えるのだけれども、探索中に引き当てたとして、それが最小値かどうか探索中には判断ができず、全ての探索を終えた時に最小値であることがようやく保証されるので、境界の問題ですね。
   - (target=xみたいに与えられているときは探索中でも欲しいものであることがわかるので、境界を求めるのではなく欲しいもの１つ見つける二分探索、ということでしょうか。)
 - キャパ x で運べるなら最適解は x 以下、キャパ x で運べないなら最適解は x より大きい。という引継ぎを行っていく。
   - キャパ x で運べるかどうか判断する関数が必要。
   - https://leetcode.com/problems/maximum-subarray/description/
       - 今回の、weightを舐めていく処理は、この問題を思い出して書いた。
 - capacityとして取りうる値の範囲を[left, right)として、middleの位置のチェックによって、middleの位置まで、探索打ち切り区間の先頭 F or T(left-1 or right)が伸びてくる。
 - 初期範囲の値は、[0, len())とする。探索打ち切り区間の先頭(-1, len())は、探索区間の外、つまりまだ何も探索していない状態。
 - 終了条件は、探索区間の消失(打ち切り区間の衝突)のタイミング、つまり left == right のとき
 - middle = (left + right) // 2 は、[left, right -1]のどこかで選べば、探索区間が必ず小さくなる。切り下げが必要。
 - まずは自力で書いてみたが、WA。そして、下記2点の修正をして、AC。嬉しい。
   - num_needed_daysの初期値が0になっていたので1に修正。どんなにキャパに余裕があっても最低1日はかかるので、初期値は1にすることが必要。
   - 単一の重さweightがcapacityを超えているかどうかのifチェックの考慮がされていなかった。この修正も行う。
 - 解は整数なので、初期値範囲の上限は math.inf よりも sys.maxsize が良いのではと感じた。
## 解法1:二分探索(再帰関数):AC
```py
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        def is_loadable_capacity(capacity: int) -> bool:
            prefix_load = 0
            num_needed_days = 1 # 0 -> 1に修正
            for weight in weights:
                if weight > capacity:  # 単一の重さweightのifチェックを追加
                    return False
                prefix_load += weight
                if prefix_load > capacity:
                    prefix_load = weight
                    num_needed_days += 1
            if num_needed_days <= days:
                return True
            else:
                return False
        def find_min_capacity(low: int, high: int) -> int:
            if low == high:
                return low
            middle = (low + high) // 2
            if is_loadable_capacity(middle):
                return find_min_capacity(low, middle)
            else:
                return find_min_capacity(middle + 1, high)
        return find_min_capacity(0, sys.maxsize + 1)
```


## 解法1:二分探索(再帰関数):AC
 - 書いたコードを見返してみる。初期範囲デカすぎでは。
 - 探索の初期範囲を、[max(weights), sum(weights)+1)に絞ると、単一の重さweightがcapacityを超えていないかどうかのifチェックが不要になった。
```py
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        def is_loadable_capacity(capacity: int) -> bool:
            prefix_load = 0
            num_needed_days = 1
            for weight in weights:
                prefix_load += weight
                if prefix_load > capacity:
                    prefix_load = weight
                    num_needed_days += 1
            if num_needed_days <= days:
                return True
            else:
                return False

        def find_min_capacity(low: int, high: int) -> int:
            if low == high:
                return low
            middle = (low + high) // 2
            if is_loadable_capacity(middle):
                return find_min_capacity(low, middle)
            else:
                return find_min_capacity(middle + 1, high)
        return find_min_capacity(max(weights), sum(weights) + 1)
```

## 解法1':二分探索(whileループ):AC
 - 再帰関数ではなく、whileループでも良い。
 - そういえば、時間計算量は、O(len(weights) * log(sum(weights)))でしょうか。
```py
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        def is_loadable_capacity(capacity: int) -> bool:
            prefix_load = 0
            num_needed_days = 1
            for weight in weights:
                prefix_load += weight
                if prefix_load > capacity:
                    prefix_load = weight
                    num_needed_days += 1
            if num_needed_days <= days:
                return True
            else:
                return False

        def find_min_capacity(low: int, high: int) -> int:
            while low < high:
                middle = (low + high) // 2
                if is_loadable_capacity(middle):
                    high = middle
                else:
                    low = middle + 1
            return low
        return find_min_capacity(max(weights), sum(weights) + 1)
```

# Step2
 - PR見る。
 - あれ？ high の初期値が sum(weights) + 1 の人がいない...私の考え方が間違っていたのでしょうか...(いやでも境界求める二分探索と考える方がスムーズなのでは?)
   - https://github.com/Yoshiki-Iwasa/Arai60/pull/37/files
       - あ、いました。とりあえず安心。
 - https://github.com/hayashi-ay/leetcode/pull/55/files
   - 図らずもロジックも変数名も似ているコードになっている。なんか嬉しい。
   - return needed_days <= days でやれば、もっとコンパクトに書けますね。これはStep1のコードを修正しましょう。
   - ただ、highの初期値(sum(weights))でやられているようだった。私は、今回の問題は、highの初期値はsum(weights)+1にして、境界を求める問題に落とし込むのが好き。
 - https://github.com/hayashi-ay/leetcode/pull/55/files
 - https://github.com/hroc135/leetcode/pull/42/files
   - 「capacityに対して何日必要かを返してそれがdays以下かどうかを呼び出し元で確認する方法もある。」
       - これでも解けそうだが、daysの情報と、capacityの情報が1つのメイン処理の中に混在するのが好きではない。
       - 個人的にはメイン処理の中では、capacityの数直線[left, right)のことだけ考える方がシンプルで好き。
       - daysは、capacityのチェックの判断材料にしか過ぎないので、is_loadable_capacity()の中だけで話を完結させたい。
 - https://github.com/fhiyo/leetcode/pull/45/files#r1682832649
   - days_required いいな。
   - https://github.com/goto-untrapped/Arai60/pull/41/files#r1685438797
       - 別に、needed_days とかでも良いか。好みでしょう。
 - https://github.com/fhiyo/leetcode/pull/45/files
   - あ、bisect_left 使えるのか。
   - なるほど。FF...FFTT...TT つまり 00...0011...11 の先頭の1求めるので、たしかに使えますね。
   - https://github.com/olsen-blue/Arai60/blob/05f634b61d0878da6a042891a436ad5f6cb84518/33.%20Search%20in%20Rotated%20Sorted%20Array.md#%E8%A7%A3%E6%B3%952key%E3%82%92%E5%B7%A5%E5%A4%AB%E3%81%97%E3%81%9Fbisect_leftcmp%E9%96%A2%E6%95%B0%E3%81%AA%E3%81%97verac-1
       - この時の解法2と同じ感じだ。タプルだったこの時よりシンプル。
 - https://github.com/fhiyo/leetcode/pull/45/files#r1682470839
   - rangeについて : 
       - これまで、rangeに対しては、for文で使える便利なやつというぐらいの認識しかなかった。
       - 範囲だけを保持しているオブジェクトなので、空間計算量がO(1)なのか。
       - (!個人的な重要ポイント!)基本的に、rangeオブジェクトは、リストと同じように使えるが、範囲だけ保持していて、値を求められた時に都度計算するやつ、って感じかな。
       - for i in range(0, n): は、0~n-1の数値をO(1)で計算して求めていて、リストのようにすでに存在している値を取得しているわけではないらしい。
       - (逆に、for num in nums:みたいなのは、リストnumsの値を取得していて計算はしているわけではないということですね。)

## 解法2:bisect_left:AC
 - https://docs.python.org/3/library/bisect.html#bisect.bisect_left
 - bisect_left への色々な引数の与え方を試してみる
   - bisect_left(range(sum(weights) + 1), True, lo=max(weights), key=is_loadable_capacity)
       - 下記で色々見たが、こう書くのが一番自然かもしれない。
       - 返す値は lo からの相対インデックスではなく、range(sum(weights) + 1)でセットした時の値、つまり探索範囲内の実際の capacity の値になる。
   - bisect_left(range(sys.maxsize), True, lo=max(weights), hi=sum(weights) + 1, key=is_loadable_capacity)
       - この書き方でも、lo / hi ともに使えて対称的で良いのではないかと感じたが、sys.maxsize使ってるので、rangeオブジェクトの空間計算量がO(1)ということが周知されていない状態だと忌避感を感じる人が出そう。私もさっき知ったばかり。
       - https://docs.python.org/3/library/bisect.html#bisect.bisect_left
           - hiの与え方はlen()なので、sum(weights) + 1 にした。
   - bisect_left(range(max(weights), sum(weights) + 1), True, key=is_loadable_capacity)
       - 最初見た時は、引数が少なくてシンプルで良いかもと思ったが、部分的な区間の中の、相対的なindexを返してしまうので、+ max(weights)が必要になった。わかりづらくて嫌かも。
       - 例えば、rangeが[3, 4, 5, 6]の時、bisect_leftで 4 の挿入位置を探すとすると、4 ではなく 1(<- rangeの中での相対的なインデックス)を返してしまうということらしい。
   - bisect_left(range(math.inf), True, lo=max(weights), hi=sum(weights), key=is_loadable_capacity)
       - エラーになって、そもそも動きませんでした。
       - https://docs.python.org/3/library/stdtypes.html#range
       - https://docs.python.org/3/library/math.html#math.inf
           - rangeコンストラクタへの引数は、整数でなければならないので、float型のmath.infはNG。
           - math.infでやると、TypeError: 'float' object cannot be interpreted as an integer になる。
```py
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        def is_loadable_capacity(capacity: int) -> bool:
            prefix_load = 0
            days_required = 1
            for weight in weights:
                prefix_load += weight
                if prefix_load > capacity:
                    prefix_load = weight
                    days_required += 1
            return days_required <= days

        return bisect.bisect_left(range(sum(weights) + 1), True, lo=max(weights), key=is_loadable_capacity)  # <-　OK
        # return bisect.bisect_left(range(sys.maxsize), True, lo=max(weights), hi=sum(weights) + 1, key=is_loadable_capacity)  # <-　これでもOK
        # return max(weights) + bisect.bisect_left(range(max(weights), sum(weights) + 1), True, key=is_loadable_capacity) # <-　これでも一応OKだけどわかりづらくて嫌。
        # return bisect.bisect_left(range(math.inf), True, lo=max(weights), hi=sum(weights), key=is_loadable_capacity)  #  <- これはNG(math.infはfloatなのでrangeの範囲として使えないのでエラーになる)
```

 - https://github.com/sakupan102/arai60-practice/pull/45/files#r1657553136
   - 抜けていた。(エッジケースへ嗅覚を発揮することが苦手で全然できていない気がする。どうすれば...)
   - https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0#heading=h.jdtk9v35bca4
   - https://github.com/hroc135/leetcode/pull/31/files#r1898180689
       - この辺りじっくり読んでおこう。
   - 今回の問題に話を戻すと、days=0だと、is_loadable_capacity()に何入れてもFalseになる。えっと、rightの初期値(sum(weights) + 1)が答えになってしまう。範囲外ですね。例外を投げましょう。

## 解法1':二分探索(whileループ):AC
 - 解法1'の修正。
   - is_loadable_capacity()の出力部分をコンパクトにする、days_required、days<=0の時の例外を投げる、という修正3点を行う。
```py
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        if days <= 0:
            raise ValueError("days must be greater than 0")

        def is_loadable_capacity(capacity: int) -> bool:
            prefix_load = 0
            days_required = 1
            for weight in weights:
                prefix_load += weight
                if prefix_load > capacity:
                    prefix_load = weight
                    days_required += 1
            return  days_required <= days

        def find_min_capacity(low: int, high: int) -> int:
            while low < high:
                middle = (low + high) // 2
                if is_loadable_capacity(middle):
                    high = middle
                else:
                    low = middle + 1
            return low
        return find_min_capacity(max(weights), sum(weights) + 1)
```

# Step3
 - 再現性の確認。
## 解法1':二分探索(whileループ):AC
 - left / rightで書き慣れていて、low / high だと手が勝手に left / right で書いてしまいがち。
   - low / right とかも書いてしまう。right と high のスペルが似てるせいかも。
   - 普段からもう少し low / high の方を積極的に使うべきかもしれない。
 - 最終的に3分半くらいで実装。
```py
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        if days <= 0:
            raise ValueError("days must be greater than 0")

        def is_loadable_capacity(capacity: int):
            days_required = 1
            prefix_load = 0
            for weight in weights:
                prefix_load += weight
                if prefix_load > capacity:
                    prefix_load = weight
                    days_required += 1
            return days_required <= days
        
        def find_min_capacity(low: int, high: int):
            while low < high:
                middle = (low + high) // 2
                if is_loadable_capacity(middle):
                    high = middle
                else:
                    low = middle + 1
            return low
        return find_min_capacity(max(weights), sum(weights) + 1)
```

## 解法2:bisect_left:AC
 - bisect_leftをやる時は、F..FT..Tのイメージが必要だと感じた。各自のF/Tをkeyで出力してあげる。最初のTの位置を見つける。
 - https://github.com/olsen-blue/Arai60/pull/42#discussion_r1993171368
   - bisect_leftと同じということは、やっぱり今回は境界を求める問題ということで良かったのでは、と改めて感じる。
 - lowは探索の開始位置を指定するだけで、出力値はloからの相対インデックスではなく、最初にrangeで設定した値で変わらない。
```py
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        if days <= 0:
            raise ValueError("days must be greater than 0")

        def is_loadable_capacity(capacity: int):
            prefix_load = 0
            days_required = 1
            for weight in weights:
                prefix_load += weight
                if prefix_load > capacity:
                    prefix_load = weight
                    days_required += 1
            return days_required <= days
        
        return bisect_left(range(sum(weights) + 1), True, lo=max(weights), key=is_loadable_capacity)

```
