# Step1
## 解法1:選択(Selection)ソートみたいなポインタ:AC
 - sに注目ポインタ置いて、tをforでループしていき一致したらポインタを前進させる。なんか、選択(Selection)ソートみたいな頭の使い方ですね。
 - ポインタがlen(s)になれば True、それ以外は False。
 - エッジケースの考慮や、if s_pointer_index == len(s):をネストさせるなどの修正に少し時間を要したが、10分ほどで実装。
```py
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if s == "":
            return True
        s_pointer_index = 0
        for char in t:
            if char == s[s_pointer_index]:
                s_pointer_index += 1
            if s_pointer_index == len(s):
                return True
        return False
```

## 解法2:仕事の引き継ぎトップダウン再帰DP:AC
 - バックトラックの時に書いた、numsを舐めるように動く traverse 関数のイメージそのままで書いてみた。
   - 「without disturbing the relative positions」　なので一方向に traverse していくのが直感的だと感じる。
 - やっぱり、子分に丸投げするトップダウン再帰が好きですね。
```py
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        def traverse_s_t(index_s, index_t) -> bool:
            if index_s == len(s):
                return True
            if index_t == len(t):
                return False

            if s[index_s] == t[index_t]:
                return traverse_s_t(index_s + 1, index_t + 1)
            else:
                return traverse_s_t(index_s, index_t + 1)
        return traverse_s_t(0, 0)
```

# Step2
 - PR見る。
 - https://github.com/hayashi-ay/leetcode/pull/64/files
 - https://github.com/hayashi-ay/leetcode/pull/64/files#diff-0fa674be955a983fbef3f0f1952784256410e7cd97ff5fa05b6d6b5cfa09d3c0R53
   - 2ポインタにして、whileでもいいですね。対称性があると思います。
   - 個人的には、ターゲットが s で、手持ちの手札が t というイメージなので、ループで書くなら、s に注目するポインタをおいて、forで t の要素をループして取り出すのが自然言語のイメージだと自然だと感じる。なので、今回は敢えて非対称性があった方がしっくりくるかもと感じた。
   - https://github.com/Ryotaro25/leetcode_first60/pull/62/files#diff-341824511a98af50417d7a72053c3a3966bbb499250ce9b0c024b4b53006a17aR70
       - 「s, t はどっちがどっちか分からないので避けたいですね。」
       - やっぱり、非対称性があった方が良いのでは感じる。
 - https://github.com/Ryotaro25/leetcode_first60/pull/62/files#diff-341824511a98af50417d7a72053c3a3966bbb499250ce9b0c024b4b53006a17aR22
   - 同じ感想です。

## 解法3:無限ループ:AC
 - https://github.com/nittoco/leetcode/pull/16/files#diff-4213dd9e9bb2e47ed3241ed4250c36f5193149962dd86c6163c7d6b52b8b2668R71-R82
   - お、無限ループだが、自分が書いた解法2と構造がかなり近い。
   - https://github.com/nittoco/leetcode/pull/19/files#r1644763510
       - 「全ての再帰関数は、同じロジックを用いたまま、ループで書き直すことができます。」
       - これを思い出した。やっぱり、再帰が書けるならループでも書けるんですね。書いてみましょう。
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/62/files#diff-e791ee6de1405ea8b9a39688aba429a08271228a394e40fd01307838a566a994R32
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/62/files#r1747476331
   - while True: の無限ループは、終わりが明示的でない気がして、忌避感があったが、無限ループはそこそこよく使うらしいのでもうちょっと慣れていきたい。
 - 書いてみたけど、意外としっくりくるかも。食わず嫌いしていた気がする。
```py
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        index_s = 0
        index_t = 0
        while True:
            if index_s == len(s):
                return True
            if index_t == len(t):
                return False
            if s[index_s] == t[index_t]:
                index_s += 1
                index_t += 1
            else:
                index_t += 1
```

 - https://github.com/fhiyo/leetcode/pull/55/files#diff-a6c7d5ff748fd033529b0b0a550ed2aa570e18edc3e2c61da5094aec0e23a91eR45-R46
   - 辞書&二分探索の解法、なるほど面白いですね。これは思いつかず...
   - そもそも、文字列が与えられているのに二分探索が使えるのか、ということに驚いた。

# Step3
 - 再現性の確認。
## 解法1:選択(Selection)ソートみたいなポインタ:AC
 - s_pointer_index の命名は、腹痛が痛いみたいなことになってないだろうか。まあでも、sに注目しているということは誇張して、Step2で考えたように、非対称性を確保したいかも。
```py
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if not s:
            return True
        s_pointer_index = 0
        for char in t:
            if char == s[s_pointer_index]:
                s_pointer_index += 1
            if s_pointer_index == len(s):
                return True
        return False
```

## 解法2:仕事の引き継ぎトップダウン再帰DP:AC
 - 終了条件と、メインのif/else処理は性質が異なるので、切れ目が欲しいと思って、空行を追加した。
```py
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        def traverse_s_t(index_s, index_t) -> bool:
            if index_s == len(s):
                return True
            if index_t == len(t):
                return False
            
            if s[index_s] == t[index_t]:
                return traverse_s_t(index_s + 1, index_t + 1)
            else:
                return traverse_s_t(index_s, index_t + 1)
        return traverse_s_t(0, 0)
```

## 解法3:無限ループ:AC
 - せっかくなので、while無限ループも。
 - https://github.com/nittoco/leetcode/pull/19/files#r1644763510
   - 「全ての再帰関数は、同じロジックを用いたまま、ループで書き直すことができます。」
 - 子分への引き継ぎがいつ・どこなのかがはっきりわかる解法2の方が好みですね。
 - https://github.com/olsen-blue/Arai60/pull/53/files#diff-f084bff8e4dbd771bf8a202d43b499bc30bffb7c10d4c5ccd2102f021910fd19R86-R87
   - これは、whileループだけど、stack.append() をしているのが引き継ぎ感あってよかったなあと感じた。
```py
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        index_s = 0
        index_t = 0
        while 1:
            if index_s == len(s):
                return True
            if index_t == len(t):
                return False
            
            if s[index_s] == t[index_t]:
                index_s += 1
                index_t += 1
            else:
                index_t += 1
```
