# Step1
- 累積和では？と思った。また、num.length的に、２重ループ(10^8オーダーくらい)は間に合うのかどうかかなり怪しい。1回のループで行けないだろうか。
- まず、一番シンプルそうな、スライスを使う解法に、（間に合わなそうだが）トライ。
## 解法１：スライス（実質３重ループ）：TLE（83 / 93 testcases passed）
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        num_of_subarrays = 0
        len_nums = len(nums)
        for i in range(0, len_nums):
            for j in range(i, len_nums):
                total = sum(nums[i:j+1])
                if total == k:
                    num_of_subarrays += 1
        return num_of_subarrays
```

## 解法２：累積和：TLE（83 / 93 testcases passed）

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        len_nums = len(nums)
        cumulative_sum_list = [0] * (len_nums + 1)
        cumulative_sum_list[0] = 0

        num_of_subarrays = 0
        for i in range(1, len_nums + 1):
            cumulative_sum_list[i] += cumulative_sum_list[i-1] + nums[i-1]  #累積和は1-indexed
        for i in range(1, len_nums + 1):
            for j in range(0, i):
                if k == cumulative_sum_list[i] - cumulative_sum_list[j]:
                    num_of_subarrays += 1
        return num_of_subarrays
```

- やっぱり、これは１パスじゃないとダメだなと感じ。１パスにトライ。
- 手元の計算用紙でいろんなパターンを書いて実験。
- ある num までの累積和を考える。それ以前に計算しておいた累積和との差が k であれば、カウントが必要。
- numsの要素がすべて正の時は、累積和はnumを先に進めるほどに単調増加する。つまり差がkとなる、それ以前の累積和は１つしかない。
- しかし、numsの要素は整数なので、0や負の数もある。そういうときは、num までの累積和と、差がkとなる、それ以前の累積和は１つ以上存在し得る。その個数をすべてカウントしたい。
- あるnumまで累積和を計算したとして、それ以前の「累積和の値＆個数」が知りたい。これを辞書で管理するということ？
- あ、「1. Two Sum」の辞書管理の解法と同じ考え方だな、とわかる。
- 考える数字が、あるインデックスの要素の値ではなく、あるインデックスまでの累積和になっただけで、相方を辞書から探してくるムーヴは共通で同じ、と考えると非常にシンプルになる気がする。
- 累積和の差を取らないケースもありそうだが、これは値0の番兵が１人いることを考慮すれば良さそう。

## 解法３：辞書：AC
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        cumulative_sum = 0
        num_of_subarrays = 0
        cumulative_sum_to_frequency = defaultdict(int)
        cumulative_sum_to_frequency[0] += 1 #番兵
        for num in nums:
            cumulative_sum += num
            before_cumulative_sum = cumulative_sum - k
            if cumulative_sum_to_frequency[before_cumulative_sum] > 0:  #このifはなくても動くが、書いた方が加算処理が必要なタイミングが明示的でよいのではと感じ書いてみた。
                num_of_subarrays += cumulative_sum_to_frequency[before_cumulative_sum]
            cumulative_sum_to_frequency[cumulative_sum] += 1
        return num_of_subarrays
```

# Step2
- PRやドキュメントを見てみる。実行時間の制限からか、どれも似たようなロジックに収束している印象。
- odaさんの、鉄道＆標高差、の例えが非常にしっくりときた。マイナス値・番兵の考慮も自然にできる。
- 累積和を使いそうだという直感に加え、頭の中にこの絵のイメージがあれば、コードを書く時にも心強いと感じました。他の累積和の問題にもイメージ適用できそうですね。
- https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0#heading=h.bp0g0ai41eln
- https://discord.com/channels/1084280443945353267/1233603535862628432/1252239510624931921

- 「num_of_subarrays」の変数名は、変えた方が良さそう。長いけど「num_subarrays_equal_to_k」とかでしょうか。
- https://github.com/katataku/leetcode/pull/15/files#r1903866669

- 鉄道＆標高差のイメージを持ちつつ、よりわかりやすくする。
- 「if」を書くか書かないかで、かなり迷いました。defautdictにデフォルトで「0」が入っている事実が了解されているならば、なくても良いと感じました。
- 基本的にシンプルな方が好きなので、ifなしで書いてみる。

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        cumulative_sum = 0
        num_subarrays_equal_to_k = 0
        cumulative_sum_to_frequency = defaultdict(int)
        cumulative_sum_to_frequency[0] = 1  #加算ではなく、1をセット、の方がイメージに合致している気がした。
        for num in nums:
            cumulative_sum += num
            k_smaller_cumulative_sum = cumulative_sum - k   #k_smallerとして、より明示的に修正
            num_subarrays_equal_to_k += cumulative_sum_to_frequency[k_smaller_cumulative_sum]
            cumulative_sum_to_frequency[cumulative_sum] += 1
        return num_subarrays_equal_to_k
```

# Step3
- 再現性の確認。3分ほどでAC。Step2から変化していない認識。
- （！質問！）細かい話ですが、Submit後に表示される実行時間の分布を見ると、離散的に特定の実行時間にピークが生じているのが不思議でした。何かの定数倍のようなものが影響しているでしょうか？
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        cumulative_sum = 0
        num_subarrays_equal_to_k = 0
        cumulative_sum_to_frequency = defaultdict(int)
        cumulative_sum_to_frequency[0] = 1
        for num in nums:
            cumulative_sum += num
            k_smaller_cumulative_sum = cumulative_sum - k
            num_subarrays_equal_to_k += cumulative_sum_to_frequency[k_smaller_cumulative_sum]
            cumulative_sum_to_frequency[cumulative_sum] += 1
        return num_subarrays_equal_to_k
```
