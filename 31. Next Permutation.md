# Step1
 - わからん。解法見ても最初分からなかったがGPTを質問攻めにして理解した。
 - https://github.com/hayashi-ay/leetcode/pull/67/files#diff-ee8de8f68c4ae03917be0fa643c8defc8592e248688aed43937777d663dbfccdR116
   - 最初に参考にした解法。
 - 数値を入れ替えて辞書順で後にするということがどういうことなのかの理解が大事かもと感じた。
 - 自然言語としての整理:
   - 棒グラフのイメージがしっくりきた。高い棒グラフを前方にある低い棒グラフを入れ替えると辞書順で後にする、という処理になる。
   - 後ろから逆向きに arr を見たときに上り坂の範囲は、そもそも辞書順で後にする処理ができないので、初めて下り坂になる部分を見つける。
   - 下り坂の部分により大きな値を入れると、辞書順で後にできる。その値は可能な限り小さい方がよく、末尾～現時点までで見てきた数の中から交換相手を選んで交換する。
       - (追記)交換相手は、末尾から見ていって最初にnums[left]を超える値でOK
   - 交換後、すでに辞書順で後になってるが、「辞書順で直後」の状態を目指すために、極限まで貪欲に近づける形で、left + 1 ~ 末尾を昇順にソートして仕上げをする。
 - 自然言語で整理して割とボリューミーな感じになり、コードも実装重めなの納得の内容だった。うまく関数化していけば書けそう。関数名は長くなりそうだ。
 - 昇順処理の関数 reverse_in_range で昇順にできるのは、left + 1 ~ 末尾の領域が降順になっているから。
## 解法1:3つの関数:WA
 - 良さげな解法の名前がわからない。何か特別なアリゴリズムを使ってる訳ではないので。
```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        def find_first_decreasing_num_index_from_right():
            for i in range(len(nums) - 2, -1, -1):
                if nums[i] < nums[i + 1]:
                    return i
            return -1

        def find_min_num_index_greater_than(begin, standard_value):
            min_num_value = nums[begin]
            min_num_index = begin
            for i in range(begin + 1, len(nums)):
                if standard_value < nums[i] < min_num_value:
                    min_num_value = nums[i]
                    min_num_index = i
            return min_num_index

        def reverse_in_range(left, right):
            while left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
        
        left = find_first_decreasing_num_index_from_right()
        if left == -1:
            nums.reverse()
            return
        right = find_min_num_index_greater_than(left + 1, nums[left])
        nums[left], nums[right] = nums[right], nums[left]
        reverse_in_range(left + 1, len(nums) - 1)
```

 - あれれ、上でWAになる。なぜだろう。nums = [2,3,1,3,3]とかで通らない。
 - < min_num_value を <= min_num_value にするとAC。
 - まず前提として、最後の昇順仕上げ処理の操作の直前の時点で、left + 1以降右側の領域が降順になっている必要がある(*)。
 - 交換元の数字(left)は交換先の数字(right)より小さいので、交換先の数字の候補として同じ数値が並んでいる場合は、(*)を保証するために、より後ろの方の候補と交換しなければならない。だから <= min_num_value が必要ということか、なるほど。
## 解法1':3つの関数:AC
 - https://github.com/hayashi-ay/leetcode/pull/67/files#diff-ee8de8f68c4ae03917be0fa643c8defc8592e248688aed43937777d663dbfccdR162
   - あ、そもそも right の見つけ方は末尾から見ていって、始めて nums[left] より大きくなるものを見つければ良さそう。(left + 1 〜 末尾が左から見た時に降順(右から見ると昇順)になっているので)
 - 基準値という意味で、standard_value にしていたが、冗長なので target でいいと感じた。
 - 修正して下記コードでAC。
```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        def find_first_decreasing_num_index_from_right():
            for i in range(len(nums) - 2, -1, -1):
                if nums[i] < nums[i + 1]:
                    return i
            return -1

        def find_min_num_index_greater_than(target, begin):
            for i in range(len(nums) - 1, -1, -1):
                if nums[i] > target:
                    return i
            return -1

        def reverse_in_range(left, right):
            while left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
        
        left = find_first_decreasing_num_index_from_right()
        if left == -1:
            nums.reverse()
            return
        right = find_min_num_index_greater_than(nums[left], left + 1)
        nums[left], nums[right] = nums[right], nums[left]
        reverse_in_range(left + 1, len(nums) - 1)
```

# Step2
 - PR見ていく。
 - https://github.com/Mike0121/LeetCode/pull/15/files#diff-18fcbdba94ed89573b586772a3747e1e4f3a5625a98e6782d2bfca4a3fd46027R44
   - 「left, rightは、pivot, swapの方がわかりやすいかもしれない。」
   - 確かにこっちの方が良さげ。(この問題、処理が多くて変数名や関数名の命名が難しいですね。)
 - https://github.com/usatie/leetcode/pull/2/files#diff-6df63844477a509737ffe87b2dcf17e6b85aaae820bbffe395d625625549a4ddR6
   - pivot という命名良さげですね。
 - https://github.com/Mike0121/LeetCode/pull/15/files#r1605725357
   - 「leftがfind_pos_desc_in_reversed()で見つけた値であることを知っていないと、leftより左の位置を返したり最悪 (arr[left]がリストの最大値なら) マイナスに突入してIndexErrorになる可能性もあるなと思いました。」
       - https://github.com/hayashi-ay/leetcode/pull/67/files#diff-ee8de8f68c4ae03917be0fa643c8defc8592e248688aed43937777d663dbfccdR166
       - https://github.com/Yoshiki-Iwasa/Arai60/pull/63/files#diff-6c12a1b63b001ce4ae54707ec47b0b9ca3b7e8881837e25ee0c29254f8202827R27
         - ここで、エラー投げてたのはこれらのエラーに対応するためだったのかも。
         - GPT「 raise Exception("unreachable") は、論理的にその部分に到達してはならないと開発者が確信していることを示すためのガードです。」
         - unreachable 立ち入り禁止！みたいなノリの意味なのね。他でも使えそう。

## 解法2:2重ループ:AC
 - https://github.com/Mike0121/LeetCode/pull/15/files#diff-18fcbdba94ed89573b586772a3747e1e4f3a5625a98e6782d2bfca4a3fd46027R83
 - https://github.com/fhiyo/leetcode/pull/56/files#diff-b3acad5bdbe668fe91a5e77ce0767a93ade655219d05322a3666b9f6b10907eeR59
   - 2重ループでできるのか。
 - https://docs.python.org/3/library/array.html#array.array.reverse
   - nums.reverse() は入力破壊で元のリストを並び替える。sort()と一緒。値は返さない。
 - https://docs.python.org/3/library/functions.html#reversed
   - reversed() は入力非破壊でイテレータを返す。sorted()と似ている。
 - https://docs.python.org/ja/3.13/tutorial/introduction.html#:~:text=%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9%E3%81%AB%E3%81%AF%E3%80%81%E4%BB%A3%E5%85%A5%E3%82%82%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9%E3%81%AE%E4%BB%A3%E5%85%A5%E3%81%A7%E3%80%81%E3%83%AA%E3%82%B9%E3%83%88%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%97%E3%81%9F%E3%82%8A%E3%80%81%E5%85%A8%E3%81%A6%E3%82%92%E5%89%8A%E9%99%A4%E3%81%97%E3%81%9F%E3%82%8A%E3%82%82%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%3A
   - nums[pivot_index + 1:] = reversed(nums[pivot_index + 1:]) のコードは、スライス代入(右辺にはリストなどのイテラブルオブジェクトのみ指定できる))というものをしている。便利だな。
 - あれ、reversed() 使うのって、in-placeではないのでは...？(汗)
```py
class Solution:
    def nextPermutation(self, nums: list[int]) -> None:
        for pivot_index in range(len(nums) - 2, -1, -1):
            for swap_index in range(len(nums) - 1, pivot_index, -1):
                if nums[pivot_index] >= nums[swap_index]:
                    continue
                nums[pivot_index], nums[swap_index] = nums[swap_index], nums[pivot_index]
                nums[pivot_index + 1:] = reversed(nums[pivot_index + 1:])
                return
        nums.reverse()
```

## 解法1':3つの関数:AC
 - pivot_index, swap_indexという変数名。
 - raise Exception("unreachable here")　という例外処理も追記。
```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        def find_first_decreasing_num_index_from_right():
            for i in range(len(nums) - 2, -1, -1):
                if nums[i] < nums[i + 1]:
                    return i
            return -1

        def find_min_num_index_greater_than(target, begin):
            for i in range(len(nums) - 1, -1, -1):
                if nums[i] > target:
                    return i
            raise Exception("unreachable here")

        def reverse_in_range(left, right):
            while left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
        
        pivot_index = find_first_decreasing_num_index_from_right()
        if pivot_index == -1:
            nums.reverse()
            return
        swap_index = find_min_num_index_greater_than(nums[pivot_index], pivot_index + 1)
        nums[pivot_index], nums[swap_index] = nums[swap_index], nums[pivot_index]
        reverse_in_range(pivot_index + 1, len(nums) - 1)
```

# Step3
 - 再現性の確認。
## 解法1':3つの関数:AC
 - 関数の命名の修正をする:
 - https://github.com/hayashi-ay/leetcode/pull/67/files#diff-ee8de8f68c4ae03917be0fa643c8defc8592e248688aed43937777d663dbfccdR156-R162
 - https://docs.python.org/ja/3/library/stdtypes.html#str.rfind
   - 右側から検索して位置を返す rfind というメソッドがある。この命名方法を拝借しよう。
```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        def rfind_first_decreasing():
            for i in range(len(nums) - 2, -1, -1):
                if nums[i] < nums[i+1]:
                    return i
            return -1

        def rfind_greater_than(target):
            for i in range(len(nums) - 1, -1, -1):
                if nums[i] > target:
                    return i
            raise Exception("unreachable here")

        def reverse_in_range(left, right):
            while left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1

        pivot_index = rfind_first_decreasing()
        if pivot_index == -1:
            nums.reverse()
            return 
        swap_index = rfind_greater_than(nums[pivot_index])
        nums[pivot_index], nums[swap_index] = nums[swap_index], nums[pivot_index]
        reverse_in_range(pivot_index + 1, len(nums) - 1)
```
        
## 解法2:2重ループ:AC
 - in-place出ない気がしてこの点微妙だが、こちらもやっておく。実装軽くて良い。
```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        for pivot in range(len(nums) - 2, -1, -1):
            for swap in range(len(nums) - 1, pivot, -1):
                if nums[pivot] >= nums[swap]:
                    continue
                nums[pivot], nums[swap] = nums[swap], nums[pivot]
                nums[pivot + 1:] = reversed(nums[pivot + 1:])
                return
        nums.reverse() 
```
