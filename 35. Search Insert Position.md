# Step1
 - bisect_left使う？
 - https://docs.python.org/3/library/bisect.html#bisect.bisect_left
 - https://github.com/python/cpython/blob/cfbdce72083fca791947cbb18114115c90738d99/Lib/bisect.py#L74
   - だいたい想像通り。keyで挿入位置を決める際の値の変換ができるのか。
 - keyは具体的には、こう使うらしい。
```py
 data = [1, 2, 3, 4, 5]
 target = 10
 index = bisect.bisect_left(data, target, key=lambda x: x**2)  # key を使い、各要素の 2 乗の値で比較
 print(index)  # 3  (4 の位置)
```
## 解法1:bisect_left:AC
```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        insert_index = bisect_left(nums, target)
        return insert_index
```

 - 面接とかだと、中身実装してと言われそう。
 - odaさん直伝?の引き継ぎ型の二分探索でも書く。
   - 探索区間(left ~ right)と探索打ち切り区間の両方の考慮が重要。
       - 今回は、左の探索打ち切り区間がtarget未満で、右の打ち切り区間はtarget以上と設定する。
   - middleの調査結果をもとに、明日の担当者へ引き継ぐ。
       - middleの位置まで打ち切り区間が伸びるので、探索範囲は必ず1小さくなる。
   - 探索打ち切り区間が接して、探索区間が消失したら終了。(left - 1 + 1 == rightの時)
   - 初期条件は、left = 0、right = len(nums)
## 解法2:引き継ぎ型二分探索(再帰関数):AC
 - bisect_leftの実装
 - 関数型の方は、次の担当者への引き継ぎのタイミングでreturnするので、これがわかりやすくて好き。
 - あと、関数型はトップダウンDPと同様に、まず欲しいものを叫べるのが好き。良いことしかなくないか？
```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        def find_insert_index(left: int, right: int) -> int:
            if left == right:
                return left
            middle = (left + right) // 2
            if nums[middle] >= target:
                return find_insert_index(left, middle)
            else:
                return find_insert_index(middle + 1, right)
        return find_insert_index(0, len(nums))
```
 
## 解法3:引き継ぎ型二分探索(whileループ):AC
 - 関数型に慣れていたが、whileの方が実装はシンプルで良いかも。
```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            middle = (left + right) // 2
            if nums[middle] >= target:
                right = middle
            else:
                left = middle + 1
        return left
```

# Step2
 - PR見る。
 - https://github.com/saagchicken/coding_practice/pull/3/files
   - あ、middleの位置にtarget発見したらもうmiddle返しちゃって良いのか。まあどっちでも良いでしょう。
   - いや？ target が連続して複数ある場合に、bisect_left っぽく挿入したかったら、見つけてすぐに返しちゃダメだ。じゃ現状のままでいいか。
 - https://github.com/TORUS0818/leetcode/pull/43/files#:~:text=pivot%E3%82%92%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0,return%20left
   - ランダムに選択しても、探索範囲が小さくなるのであれば、今日の担当者は探索範囲を狭めるという、引き継ぎ上意味のある仕事をしたことになりますね。
   - まあでも、問題文にO(log n)で解けと書いてあるので、中点を使う方が良いのではと思います。
 - 閉区間 or 開区間、whileループ or 再帰、という解法がある感じでしょうか。
   - 今回は区間を考えるので、端の実体がある閉区間でやるのが好きですね。
   - whileか再帰関数ですが、引き継ぎオナシャス！というアクションがわかりやすいので、再帰関数の方が好き。(再帰スタックに注意だが)
 - https://github.com/hayashi-ay/leetcode/pull/40/files
   - https://github.com/hayashi-ay/leetcode/pull/40/files#diff-912c29ce0f491ca88b1474ced97db89f2d33a36a34cd0f516f5b523e400af176R43:~:text=python%E3%81%A7%E3%81%AF%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%95%E3%83%AD%E3%83%BC%E3%82%92%E8%80%83%E6%85%AE%E3%81%97%E3%81%AA%E3%81%8F%E3%81%A6%E8%89%AF%E3%81%84%E3%81%8C%E3%80%81%E8%80%83%E6%85%AE%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B%E8%A8%80%E8%AA%9E%E3%81%A0%E3%81%A8%20mid%20%3D%20left%20%2B%20(right%20%2D%20left)%20//%202%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B%E3%80%82
   - 「pythonではオーバーフローを考慮しなくて良いが、考慮する必要がある言語だと mid = left + (right - left) // 2のようにする。」
   - left + right の和がオーバーフローを起こしうるので、少しずつ値を大きくする工夫ということですね。なるほど。

## 解法2:引き継ぎ型二分探索(再帰関数):AC
 - 強いて修正するなら、終了条件のif文を書き換えると、探索終了区間の衝突した状態の図的描写として、分かりやすいかもしれない。いや、くどいかも。
```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        def find_insert_index(left: int, right: int) -> int:
            if left - 1 + 1 == right:
                return left
            middle = (left + right) // 2
            if nums[middle] >= target:
                return find_insert_index(left, middle)
            else:
                return find_insert_index(middle + 1, right)
        return find_insert_index(0, len(nums))

```

# Step3
 - 解法2, 3で再現性確認。
## 解法2:引き継ぎ型二分探索(関数):AC
 - 最終的に、2分くらいで実装。
 - 頭の中に、探索区間・探索打ち切り区間のイメージがあるとスムーズですね。
```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        def my_bisect_left(left: int, right: int) -> int:
            if left == right:
                return left
            middle = (left + right) // 2
            if nums[middle] >= target:
                return my_bisect_left(left, middle)
            else:
                return my_bisect_left(middle + 1, right)
        return my_bisect_left(0, len(nums))
```

## 解法3:引き継ぎ型二分探索(whileループ):AC
 - 1分半くらいで実装。
 - やっぱり、解法2の方が、終了条件を明示できるし、引き継ぎのタイミングでのreturnを行うのが、わかりやすいと感じる。
```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            middle = (left + right) // 2
            if nums[middle] >= target:
                right = middle
            else:
                left = middle + 1
        return left
```
