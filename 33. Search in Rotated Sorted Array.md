# Step1
 - これは前問とは逆に、境界を求めるのではなく、欲しいものを1つ見つけるタイプですね。なるほど。
 - 前の問題の考え方を使えばいけるのでは?
 - [left, right]の中に、存在有無が不明のtargetの位置を発見したい。存在する場合の候補の位置は[0, len(nums) - 1]なので、初期値はそのまま[0, len(nums) - 1]にする。
 - middleを求める、middleの位置にtargetがあれば、ミッション終了。見つからない場合、下記の探索をする。
 - middleが崖を越える前か後かを、まず判断する。
   - 越える前であれば後ろに、越えた後であれば前に単調増加の登り坂が存在しており、ココの範囲であればtargetが存在しているかどうかの判断が可能となる。
 - middleが崖を越える前のとき
   - [left, middle - 1]にtargetがある場合、探索範囲を[left, middle - 1]の範囲にして引き継ぐ
   - [left, middle - 1]にtargetがない場合、探索範囲を[middle + 1, right]の範囲にして引き継ぐ
 - middleが崖を越えた後のとき
   - [middle + 1, right]にtargetがある場合、探索範囲を[middle + 1, right]の範囲にして引き継ぐ
   - [middle + 1, right]にtargetがない場合、探索範囲を[left, middle - 1]の範囲にして引き継ぐ
 - 探索区間が消失(not(left <= right)が成立)したら、引き継ぎ終了して-1を返す。
 - 前問同様、回転した昇順リストの問題は、"崖越える前 or 後"の考え方が汎用的に活用できるのではと感じた。
## 解法1:引継ぎのバイナリサーチ(再帰関数):AC
 - とりあえず直感的なロジックでACになり嬉しい。
 - でも、ちょっと実装重いなあ(こなみ)。
```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_target_index(left :int, right :int) -> int:
            if not(left <= right):
                return -1
            middle = (left + right) // 2
            if nums[middle] == target:
                return middle
            if nums[middle] >= nums[right]: # middleが崖越える前
                if nums[left] <= target < nums[middle]:   #　middleより後ろの上り坂部分にtargetがあるか確認
                    return find_target_index(left, middle - 1)
                else:
                    return find_target_index(middle + 1, right)
            else:  # middleが崖越えた後　or そもそも区間内に崖ナシ
                if nums[middle] < target <= nums[right]:   #　middleより前の上り坂部分にtargetがあるか確認
                    return find_target_index(middle + 1, right)
                else:
                    return find_target_index(left, middle - 1)
        return find_target_index(0, len(nums) - 1)
```
 - (前問を解き終えて、ここから再開)
## 解法1:引継ぎのバイナリサーチ(再帰関数):AC
 - 崖チェックの基準値は nums[-1] で固定したい！
 - 一方で、上り坂部分の中の target 確認では、nums[right]で確認する必要がある。もしnums[-1]で確認すると、先代までの絞り込みの引き継ぎが台無しになる。そこはもう探索打ち切りなので、調べなくて良いところですよ。
 - なんとなく崖越えのチェックを先にしたい。
 - targetがnumsの中に存在しない場合について、要素2つの状態(left=0, right=1)からシミュレーションしてみた。(本当はもっと早くやるべき...)
   - ネストの中にelseが2つあるが、どちらかのelseで処理がなされて、最終的には、right + 1 == leftという状態になり、if not(left <= right):することで、おそらく正しくreturn -1を返せていそうだった。
 - 上り坂を利用したtargetチェックでは、if nums[middle] < target <= nums[right]: を if nums[middle + 1] <= target <= nums[right]: と書くとnumsの範囲外インデックスのエラーが出る。
   - 具体的には、nums=[1]の時のエッジケースなど。left=0, right=0, middle=0になり、middle + 1 は範囲外。
   - 再帰関数の呼び出しでは、基底条件でおかしなインデックスが弾けたりするが、リストはこの範囲外アクセスエラーがあるので注意したい。 
```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_target_index(left :int, right :int) -> int:
            if not(left <= right):
                return -1
            middle = (left + right) // 2
            if nums[middle] == target:
                return middle
            if nums[middle] <= nums[-1]: # middleが崖越えた後　or そもそも区間内に崖ナシ 
                if nums[middle] < target <= nums[right]:
                    return find_target_index(middle + 1, right)
                else:
                    return find_target_index(left, middle - 1)       
            else:  # middleが崖越える前
                if nums[left] <= target < nums[middle]:
                    return find_target_index(left, middle - 1)
                else:
                    return find_target_index(middle + 1, right)
        return find_target_index(0, len(nums) - 1)
```

## 解法1':引継ぎのバイナリサーチ(while):AC
 - これはこれで、引き継ぎの仕方がわかりやすい。
 - あと、今回の問題は、引き継ぎ時には[left, right]の範囲にある middle を必ず除外するので、middleの計算は切り上げでも、left=0, right=1, middle=1の時などに、区間が小さくすることができそう!
 - 恐る恐るmiddleの計算を切り上げで試してみた。ACだった。
```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_target_index(left :int, right :int) -> int:
            while left <= right:
                middle = (left + right + 1) // 2
                if nums[middle] == target:
                    return middle
                if nums[middle] <= nums[-1]:
                    if nums[middle] < target <= nums[right]:
                        left = middle + 1
                    else:
                        right = middle - 1
                else:
                    if nums[left] <= target < nums[middle]:
                        right = middle - 1
                    else:
                        left = middle + 1
            return - 1 
        return find_target_index(0, len(nums) - 1)
```

# Step2
 - PR見る。
 - https://github.com/saagchicken/coding_practice/pull/9/files#r1986475714
 - https://docs.python.org/3/reference/expressions.html#operator-precedence
   - 例えばビット全探索とかで、ビットのAND/ORをとる時は &/| を使い、bool値であればいつも書いている and/or で良いのか。C++とかだと区別せず &&/|| 使ってる印象だが、Pythonは使い方が分かれているのか。なるほど。
 - え、ifネストせずに、こんなシンプルに解けるのかい。まじか。
 - https://discord.com/channels/1084280443945353267/1233295449985650688/1239594872697262121
   - 図を書くとようやく理解できた。cmpで階段(-1, 0, 1)ができるが、崖の前後で差が生じるので、崖の前を-2だけ高さを下げることで、全体としてはpriority(x)の出力が昇順になって bisect_left の key関数として利用できるようになる。いや、エレガントすぎてこれは思いつかないのでは...
 - https://github.com/Yoshiki-Iwasa/Arai60/pull/36#discussion_r1712955053
   - こちらは上のコードの改良版でしょうか。かなり直感的で分かりやすい。
   - タプル(A,B)は、BよりもA優先でソートされることを利用している。
   - Aが1次序列、Bが2次序列。
   - A : 崖の前/後が F/T つまり 0/1 で表されている。この時点で、この後Bでいくら頑張っても挽回できない絶対的な格付け序列が作られてしまうイメージ。
       - 今回は、後ろの方が高い格のイメージ。(年末年始の某番組を思い出しました。)
       - (改良前のコードの、-2で差をつける処理は、これに近いことをしていたんですね。)
   - B : Aで決められた枠の中で、さらに細かい格付け序列を作るために、cmp(x, target)を利用している。
       - targetがnums内にあれば、...-1, -1, 0(targetの位置), 1, 1, ... となる。bisect_leftの返り値は、target の位置インデックスになる。
       - targetがnums内になければ、...-1, -1, 1*, 1, ...  となる。bisect_leftの返り値は、1* の位置インデックスになる。
## 解法2:keyを工夫したbisect_left:AC
 - 引き継ぎをせずにダイレクトに答えを求められるのすごすぎる...! こんなん無理やろと思っていたので感動。
 - priority(num) : nums の要素 num を入れると、 bisect_left の key として使えるような昇順タプル(A, B)を返す関数。
 - 挿入しようとしている値は、priority(target)で、比較に使う値を求める関数をkeyで指定する。
   - (numsのリストのすぐ下に、同じサイズで、key関数 priority(num) の出力値が並んでて、priority(target)の挿入位置を探しているイメージ。)
 - 自分で書いてみる。priority(x)ではなく、priority(num)の方が投入するものが分かりやすくて好み。
```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def cmp(a, b)-> int:      # a > b : 1,  a == b : 0,  a < b : -1
            return (a > b) - (a < b)
        def priority(num) -> int:
            return (num <= nums[-1], cmp(num, target))
        index = bisect_left(nums, priority(target), key=priority)
        if nums[index] != target:
            return -1
        return index
```

## 解法2':keyを工夫したbisect_left(cmp関数なしver.):AC
 - https://github.com/hroc135/leetcode/pull/41#discussion_r1970984248
 - cmp関数いらないらしい。
 - たしかに、Aで分けられた序列の中で、Bを決める時に target以上なのがどこからなのかが分かれば良いので、確かに cmp(num, target) のところは、target <= numで良さそう。
 - 自分で書いてみる。
 - 解法1の激重実装からこんなにコンパクトになってくれて嬉しい。嬉しいなぁ(こなみ)。
 - まあでも直感的で思いつきやすそうなのは解法1, 2な気がする。どちらの解法も良さがある。
```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def priority(num) -> int:
            return (num <= nums[-1], target <= num)
        index = bisect_left(nums, priority(target), key=priority)
        if nums[index] != target:
            return -1
        return index
```

 - https://github.com/hayashi-ay/leetcode/pull/49/files
   - 1stの解法が解法1と同じだった。やっぱり直感的ですよね。
   - 「pivot_indexを見つける。その後Binary Search。1stと違い2回Binary Searchをすることになる。」
       - なるほど、崖に切り替わる位置を発見して、別々にバイナリサーチするのか。特定範囲を徐々に狭めるのが、流れがスムーズで良いですね。
       - 個人的には、解法1みたいに、1回の二分探索で済む方が好きかなぁ。

# Step3
 - 解法1'と解法2'で再現性の確認。
## 解法1':引継ぎのバイナリサーチ(while):AC
 - やっぱ終了条件を明示できないのが気になるが、練習する。
 - 何度も書いてると、left = middle + 1を書いた後に、こうならないときは逆側にtargetがあるので、elseの方は、right = middle - 1と書けば良いな、と逆のことを考えれば書くのがよりスムーズになると気づいた。
 - 最終的に3分ほどで実装。
```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_target_index(left, right):
            while left <= right:
                middle = (left + right) // 2
                if nums[middle] == target:
                    return middle
                if nums[middle] <= nums[-1]:
                    if nums[middle] < target <= nums[right]:
                        left = middle + 1
                    else:
                        right = middle - 1
                else:
                    if nums[left] <= target < nums[middle]:
                        right = middle - 1
                    else:
                        left = middle + 1
            return -1
        return find_target_index(0, len(nums) - 1)
```

## 解法2':keyを工夫したbisect_left(cmp関数なしver.):AC
 - generate_priority_value関数が、(A(1st), B(2nd))序列を作るというイメージで書いた。
 - 最終的に2分くらいで実装。
```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def generate_priority_value(num):
            return (num <= nums[-1], target <= num)
        index = bisect_left(nums, generate_priority_value(target), key=generate_priority_value)
        if nums[index] != target:
            return -1
        return index
```
