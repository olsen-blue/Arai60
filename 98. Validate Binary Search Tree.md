# Step1
- 「108. Convert Sorted Array to Binary Search Tree」でも使った二分探索的な考え方で、値の制約範囲を引き継ぐ方法で解けそうだと感じる。
- 挙動的にはDFSで考えるのが素直な気がする。なぜなら根から葉に向かって１パスを考えた時に、深く葉の方向へ進むにつれて、ノードの値の制約が厳しく・狭くなっていくため。
- 関数名が良いのが思いつかずhelperにしてしまった。
- 最初書いていたが、後で不要とわかったものはコメントアウトした。（Step2では削除）
- 解法１：DFS再帰：Accepted
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        # if not root:
        #     return False
        def helper(low: int, high: int, node: Optional[TreeNode]):
            if not node:
                return True
            if not (low < node.val < high):
                return False
            # if low >= high:
            #     return False
            return helper(low, node.val, node.left) and helper(node.val, high, node.right)
        return helper(-math.inf, math.inf, root)
```

# Step2
- サーバーを漁ってPR見てみる。他の解法の選択肢も持っておきたい。
- セルフツッコミ：関数名どうする？->isValidBSTと被るのでhelperにしていた、、、
- is_valid_tree_from_range とかだろうか？
- https://github.com/TORUS0818/leetcode/pull/30/files#r1712609142
   - 非常に大きな値を表す際は、「math.inf」だけだとマジックナンバーになるので、定数として MIN_VALUE と MAX_VALUE を定義して、それを使う方が良さそう。
- https://github.com/fhiyo/leetcode/pull/41/files#r1677981453
   - inf は int ではなく float らしい。知らなかった。
   - sys.maxsize は整数だが、それより大きな値が来うる気持ち悪さがあるらしい、どっちが良いんだ．．．
- https://docs.python.org/ja/3/library/sys.html#sys.maxsize
   - sys.maxsizeのドキュメント見てみる。問題設定的には、2^31くらいが最大なので、今回は、sys.maxsize でまずいいのではと感じる。
- https://github.com/Mike0121/LeetCode/pull/8
- https://github.com/hayashi-ay/leetcode/pull/38
   - このお二方と同じ方向で、選択肢の幅を持っておきたいと感じる。幅の持ち方がしっくりきた。スタックとBFSもやってみるか。

# 解法１：DFS再帰：Accepted
- Step1を修正したもの 
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def is_valid_tree_from_range(low: int, high: int, node: Optional[TreeNode]):
            if not node:
                return True
            if not (low < node.val < high):
                return False
            return is_valid_tree_from_range(low, node.val, node.left) and is_valid_tree_from_range(node.val, high, node.right)
        MIN_VALUE = - sys.maxsize
        MAX_VALUE = sys.maxsize
        return is_valid_tree_from_range(MIN_VALUE, MAX_VALUE, root)
```
# 解法２：DFSスタック：Accepted
- https://github.com/Mike0121/LeetCode/pull/8/files
   - こちらの解法がしっくりきた。参考にして自分でも書いてみる。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        
        MIN_VALUE = - sys.maxsize
        MAX_VALUE = sys.maxsize
        nodes_stack = [(root, MIN_VALUE, MAX_VALUE)]
        while nodes_stack:
            node, low, high = nodes_stack.pop()
            if not (low < node.val < high):
                return False
            if node.left:
                nodes_stack.append((node.left, low, node.val))
            if node.right:
                nodes_stack.append((node.right, node.val, high))
        return True

```
# 解法３：BFSキュー：Accepted
- https://github.com/hayashi-ay/leetcode/pull/38/files
   - こちらの解法がしっくりくる。解法2からデータ構造を変えるだけですね。
       - データ構造を切り替えるだけで DFS と BFS を切り替えられるのは、下記でも感じたことと一致。
       - https://github.com/olsen-blue/Arai60/pull/23
   - 普通のリストではなく、dequeを使うと、キュー利用であることが明示的で良いと感じた。
- これまでは、深さごとにリストを考える根つき木構造の BFS を考えることが多かったが、今回は、単純に先頭からpopleftするだけでOKで、depth・levelごとの管理が不要そうだったので、しない。
- そもそもオーソドックスな BFS ってこういうデータ構造の持ち方だったなと思い出す。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        MIN_VALUE = - sys.maxsize
        MAX_VALUE = sys.maxsize
        nodes_queue = deque([( root, MIN_VALUE, MAX_VALUE )])
        while nodes_queue:
            node, low, high = nodes_queue.popleft()
            if not(low < node.val < high):
                return False
            if node.left:
                nodes_queue.append(( node.left, low, node.val ))
            if node.right:
                nodes_queue.append(( node.right, node.val, high ))
        return True
```
# Step3：DFS再帰：Accepted
- 最もしっくりきた、再帰で制約区間を引き継ぐ方法で最後再現性の確認。
- 「is_valid_tree_from_range」という関数名が、横に長くなりすぎて嫌になったので、is_valid にしてみる。
- いっそ helper でも良い気がしてきた。helper は読み手に情報を何も与えていないので、抵抗あり。しかし「isValidBST」で言いたいこと全て言われてしまっていて、あえて違う変数名をつけることに意味があるのか、怪しい気がする。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def is_valid(low: int, high: int, node: Optional[TreeNode]):
            if not node:
                return True
            if not(low < node.val < high):
                return False
            return is_valid(low, node.val, node.left) and is_valid(node.val, high, node.right)
        MIN_VALUE = - sys.maxsize
        MAX_VALUE = sys.maxsize
        return is_valid(MIN_VALUE, MAX_VALUE, root)
```
