# Step1
- 「108. Convert Sorted Array to Binary Search Tree」でも使った二分探索的な考え方で、値の制約範囲を引き継ぐ方法で解けそうだと感じる。
- 挙動的にはDFSで考えるのが素直な気がする。なぜなら根から葉に向かって１パスを考えた時に、深く葉の方向へ進むにつれて、ノードの値の制約が厳しく・狭くなっていくため。
- 関数名が良いのが思いつかずhelperにしてしまった。
- 最初書いていたが、後で不要とわかったものはコメントアウトした。（Step2では削除）
- 解法１：DFS再帰：Accepted
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        # if not root:
        #     return False
        def helper(low: int, high: int, node: Optional[TreeNode]):
            if not node:
                return True
            if not (low < node.val < high):
                return False
            # if low >= high:
            #     return False
            return helper(low, node.val, node.left) and helper(node.val, high, node.right)
        return helper(-math.inf, math.inf, root)
```

# Step2
- サーバーを漁ってPR見てみる。他の解法の選択肢も持っておきたい。
- セルフツッコミ：関数名どうする？->isValidBSTと被るのでhelperにしていた、、、
- is_valid_tree_from_range とかだろうか？
- https://github.com/TORUS0818/leetcode/pull/30/files#r1712609142
   - 非常に大きな値を表す際は、「math.inf」だけだとマジックナンバーになるので、定数として MIN_VALUE と MAX_VALUE を定義して、それを使う方が良さそう。
- https://github.com/fhiyo/leetcode/pull/41/files#r1677981453
   - inf は int ではなく float らしい。知らなかった。
   - sys.maxsize は整数だが、それより大きな値が来うる気持ち悪さがあるらしい、どっちが良いんだ．．．
- https://docs.python.org/ja/3/library/sys.html#sys.maxsize
   - sys.maxsizeのドキュメント見てみる。問題設定的には、2^31くらいが最大なので、今回は、sys.maxsize でまずいいのではと感じる。
- https://github.com/Mike0121/LeetCode/pull/8
- https://github.com/hayashi-ay/leetcode/pull/38
   - このお二方と同じ方向で、選択肢の幅を持っておきたいと感じる。幅の持ち方がしっくりきた。スタックとBFSもやってみるか。

# 解法１：DFS再帰：Accepted
- Step1を修正したもの 
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def is_valid_tree_from_range(low: int, high: int, node: Optional[TreeNode]):
            if not node:
                return True
            if not (low < node.val < high):
                return False
            return is_valid_tree_from_range(low, node.val, node.left) and is_valid_tree_from_range(node.val, high, node.right)
        MIN_VALUE = - sys.maxsize
        MAX_VALUE = sys.maxsize
        return is_valid_tree_from_range(MIN_VALUE, MAX_VALUE, root)
```
# 解法２：DFSスタック：Accepted
- https://github.com/Mike0121/LeetCode/pull/8/files
   - こちらの解法がしっくりきた。参考にして自分でも書いてみる。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        
        MIN_VALUE = - sys.maxsize
        MAX_VALUE = sys.maxsize
        nodes_stack = [(root, MIN_VALUE, MAX_VALUE)]
        while nodes_stack:
            node, low, high = nodes_stack.pop()
            if not (low < node.val < high):
                return False
            if node.left:
                nodes_stack.append((node.left, low, node.val))
            if node.right:
                nodes_stack.append((node.right, node.val, high))
        return True

```
# 解法３：BFSキュー：Accepted
- https://github.com/hayashi-ay/leetcode/pull/38/files
   - こちらの解法がしっくりくる。解法2からデータ構造を変えるだけですね。
       - データ構造を切り替えるだけで DFS と BFS を切り替えられるのは、下記でも感じたことと一致。
       - https://github.com/olsen-blue/Arai60/pull/23
   - 普通のリストではなく、dequeを使うと、キュー利用であることが明示的で良いと感じた。
- これまでは、深さごとにリストを考える根つき木構造の BFS を考えることが多かったが、今回は、単純に先頭からpopleftするだけでOKで、depth・levelごとの管理が不要そうだったので、しない。
- そもそもオーソドックスな BFS ってこういうデータ構造の持ち方だったなと思い出す。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        MIN_VALUE = - sys.maxsize
        MAX_VALUE = sys.maxsize
        nodes_queue = deque([( root, MIN_VALUE, MAX_VALUE )])
        while nodes_queue:
            node, low, high = nodes_queue.popleft()
            if not(low < node.val < high):
                return False
            if node.left:
                nodes_queue.append(( node.left, low, node.val ))
            if node.right:
                nodes_queue.append(( node.right, node.val, high ))
        return True
```
# Step3：DFS再帰：Accepted
- 最もしっくりきた、再帰で制約区間を引き継ぐ方法で最後再現性の確認。
- 「is_valid_tree_from_range」という関数名が、横に長くなりすぎて嫌になったので、is_valid にしてみる。
- いっそ helper でも良い気がしてきた。helper は読み手に情報を何も与えていないので、抵抗あり。しかし「isValidBST」で言いたいこと全て言われてしまっていて、あえて違う変数名をつけることに意味があるのか、怪しい気がする。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def is_valid(low: int, high: int, node: Optional[TreeNode]):
            if not node:
                return True
            if not(low < node.val < high):
                return False
            return is_valid(low, node.val, node.left) and is_valid(node.val, high, node.right)
        MIN_VALUE = - sys.maxsize
        MAX_VALUE = sys.maxsize
        return is_valid(MIN_VALUE, MAX_VALUE, root)
```

# Step4:inorderに見ていく解法
- odaさんから他の解法もあるとアドバイスいただいた。下から制約範囲を広げる方法・inorderに探索する方法があるらしい。
- inorderの解法が、かなりしっくりときたので実装してみる。下記のように、1st, 2nd, 3rdと順にみていく方法。
- 下記のように書くと、コードの見た目的な対称性がきれいだと感じて、それがなんかいいなと感じた。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        min_node_value = - math.inf
        def is_valid_BST(node):
            nonlocal min_node_value
            if not node:
                return True

            if not is_valid_BST(node.left):         # inorder 1st : 左子部分木構造のチェック
                return False
            if not (min_node_value < node.val):     # inorder 2nd : 親根ノードのチェック
                return False
            min_node_value = node.val
            if not is_valid_BST(node.right):        # inorder 3rd : 右子部分木構造のチェック
                return False
            return True                             # 1st ~ 3rd すべてクリアできた場合の出力

        return is_valid_BST(root)
```
- 下記のように、3rdの処理のifを省略して、「return is_valid_BST(node.right)」と書くこともできますが、対称性が崩れるのがなんか嫌だった。
- これだと、3rdだけ特別な意図があるように受け取られる可能性もあるかもと感じた。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        min_node_value = - math.inf
        def is_valid_BST(node):
            nonlocal min_node_value
            if not node:
                return True

            if not is_valid_BST(node.left):         # inorder 1st : 左子部分木構造のチェック
                return False
            if not (min_node_value < node.val):     # inorder 2nd : 親根ノードのチェック
                return False
            min_node_value = node.val

            return is_valid_BST(node.right)

        return is_valid_BST(root)
```
