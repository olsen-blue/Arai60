# Step1
- これは、根つき木構造のBFSがピッタリだと感じる。挙動的にこの解法しか思いつかなかった。(問題文でlevelって言ってる)
- 1問前の問題はDFSしかないという感覚だったが、この問題はBFSしかないという感覚。
- 10分くらいで書けました。
- depth要らなかったが、勢い余って書いてしまった。前に、今回と同様のBFSを使った時に、depthの更新タイミングについて修正アドバイスをいただいたので、それを意識していた。流石にStep2以降では要らないかなと感じる。使ってなくて文字通り蛇足なので...
- forループ時に、やることが２つあって紛らわしいが、この時、ノードとノードの値をしっかり区別できるように、変数名をセットした。
## 解法１：根つき木構造のBFS：AC

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        nodes_in_depth = [root]
        depth = 1
        nodes_values = []
        while nodes_in_depth:
            nodes_values_in_depth = []
            nodes_in_next_depth = []
            for node in nodes_in_depth:
                nodes_values_in_depth.append(node.val)
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            nodes_values.append(nodes_values_in_depth)
            nodes_in_depth = nodes_in_next_depth
            depth += 1
        return nodes_values
```

# Step2
- 過去に解いた方のPR見てみる。解法ロジックは問題なさそう。やっぱりBFSなのではと感じる。
- あれ、depth使ってる人いる...(困惑) 
  - https://github.com/nittoco/leetcode/pull/32/files
- たとえ使わなくても、深さdepthを更新するほうがやっていることが伝わって良いのでしょうか？
- 人によっては「変数使ってないじゃん汗」と困惑させてしまうリスクもあるのではと感じていますが。。。
- と、思っていたら運良くこれらのコメントを発見。やっぱりやっていることが伝わるほうが良いと理解。depth使います！(手のひら返し)
  - https://github.com/nittoco/leetcode/pull/32/files#r1703444181
  - https://github.com/TORUS0818/leetcode/pull/28#discussion_r1693269335
## 解法１：根つき木構造のBFS：AC：修正なし
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        nodes_in_depth = [root]
        depth = 1
        nodes_values = []
        while nodes_in_depth:
            nodes_values_in_depth = []
            nodes_in_next_depth = []
            for node in nodes_in_depth:
                nodes_values_in_depth.append(node.val)
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            nodes_values.append(nodes_values_in_depth)
            nodes_in_depth = nodes_in_next_depth
            depth += 1
        return nodes_values
```

## Step3
- 再現性の確認。4分くらいで書けました。
- 前から何度も思っていますが、変数名は、長くても何が入っているものなのか分かるようにしておくと、コードを書く時に自分が楽ができ、多分読む人にとっても分かりやすいはず、と改めて実感した。
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        nodes_in_depth = [root]
        depth = 1
        nodes_values = []
        while nodes_in_depth:
            nodes_in_next_depth = []
            node_values_in_depth = []
            for node in nodes_in_depth:
                node_values_in_depth.append(node.val)
                if node.left:
                    nodes_in_next_depth.append(node.left)
                if node.right:
                    nodes_in_next_depth.append(node.right)
            nodes_in_depth = nodes_in_next_depth
            depth += 1
            nodes_values.append(node_values_in_depth)
        return nodes_values
```
