# Step1
 - これは前解いた事がありました。どう解くんだっけ。明らかに前問を利用するのはわかる。
 - 円環構造だ。取扱注意という記憶がある。円環を扱うのは頭がこんがらがるので、一次元のリストにしなければならなかったはず。
   - https://atcoder.jp/contests/joi2015ho/tasks/joi2015ho_b
   - https://atcoder.jp/contests/joi2009ho/tasks/joi2009ho_b 
       - たしか任意の点から切れ目なくどこにでも到達できるようにするには、円周を2個分用意して、一次元に結合してやる必要があったが、今回は不要そう。
 - 2つの隣接した家(AB)をどちらも襲うことはない。それならば、AあるいはBの位置で円を切って一次元のリストにしても良いのでは。
 - メタ的に考えると、パラレルワールドが2つできるイメージで、より大きい方をmaxで採用？なんか、SFっぽいですね。
 - あ、これは、前問でも整理したように、網羅的な場合分けを適切にして、良い方を採用しましょうという同じ考え方ですね。
 - 前問は、そこに至る2つ選択肢で場合分けだったが、今回は、場合分けされた2つのパラレルワールド?
 - これ、似たような系でわざわざ DP を2回やるのか。共通部分みたいなところがあれば、効率化できるかも？
 - いや、わざわざ網羅的に場合分けしてパラレルワールドに分けてるんだから、共通のキャッシュとか処理とかデータとか、使わない方が良いのでは？
 - うん。むしろ2世界を完全に断絶させて最終結果だけそれぞれから回収する方が良くないか？情報のリークがない方が安心だという気持ちに。
 - 安全択からスタートして、うまくいけば効率化に挑戦しよう。
## 解法1:ボトムアップDPを2回やる:AC
 - 早期returnの if だけ書いてなくてエラー。これを追加後、Accepted。嬉しい。
 - len(nums)が 3 の時は円環の中から1個しか選べないので、len(nums) <= 3 の時はまとめて基底条件で良さそう(?)
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 3:
            return max(nums, default=0)

        nums_1 = nums[:len(nums) - 1]
        max_amount_1 = [0] * (len(nums) - 1)
        max_amount_1[0] = nums_1[0]
        max_amount_1[1] = max(nums_1[0], nums_1[1])
        for i in range(2, len(nums_1)):
            max_amount_1[i] = max(nums_1[i] + max_amount_1[i - 2], max_amount_1[i - 1])

        nums_2 = nums[1:]
        max_amount_2 = [0] * (len(nums) - 1)
        max_amount_2[0] = nums_2[0]
        max_amount_2[1] = max(nums_2[0], nums_2[1])
        for i in range(2, len(nums_2)):
            max_amount_2[i] = max(nums_2[i] + max_amount_2[i - 2], max_amount_2[i - 1])

        return max(max_amount_1[-1], max_amount_2[-1])
```

## 解法2:トップダウンDPを2回やる:AC
 - ボトムアップができたら、こっちも行けるのではと思い実装。
 - 2つ再帰関数用意して、@cache をそれぞれ用意してあげよう。
 - 2回 @cache って書いて良いのか？とか思ったが、たしか下記でデコレータの内部構造見たときは、@cacheの直下の関数をラップすることで、キャッシュ機能つきの関数に変換するという仕組みだったので、問題ないはず(?)
   - https://github.com/olsen-blue/Arai60/pull/30/files
 - とりあえず書きましょう。
 - ボトムアップより実装が軽かった。Accepted、嬉しい。
 - https://github.com/olsen-blue/Arai60/pull/35
   - あ、今回はワガママお嬢様の頂上決戦ということですね。しのぎを削って盛り上がってますね。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 3:
            return max(nums, default=0)

        nums_1 = nums[:len(nums) - 1]
        @cache
        def get_max_amount_1(i: int) -> int:
            if i == 0:
                return nums_1[0]
            if i == 1:
                return max(nums_1[0], nums_1[1])
            return max(nums_1[i] + get_max_amount_1(i - 2), get_max_amount_1(i - 1))

        nums_2 = nums[1:]
        @cache
        def get_max_amount_2(i: int) -> int:
            if i == 0:
                return nums_2[0]
            if i == 1:
                return max(nums_2[0], nums_2[1])
            return max(nums_2[i] + get_max_amount_2(i - 2), get_max_amount_2(i - 1))
        
        return max(get_max_amount_1(len(nums_1) - 1), get_max_amount_2(len(nums_2) - 1))
```

 - なんか上のコード、縦長だな。同じこと2回書くの冗長で好きではない。
 - https://github.com/olsen-blue/Arai60/pull/30/files#r1957966512
   - たしか、キャッシュのキーって、@cacheでラップする関数に渡される引数が違えば、これがキーになるので、違うものとして扱われるはず。
   - ならば、nums_1 と nums_2 のリストを関数の引数に渡せば、異なるキーが２つできて、パラレルワールド間でキャッシュが区別されるのでは？
   - キーとして使うということは引数はイミュータブルである必要がある。リストではなくタプルに変換が必要？
 - 細かいが、nums[:len(nums) - 1]は、nums[-1]で良さそう。
## 解法3:トップダウンDPを2回(実装を1関数で軽量化):AC
 - Accepted。コンパクトになり嬉しい。キャッシュデコレータのキーの復習にもなったので、やって良かった。
 - tupleではなくList[int]のままで引数を与えると、"TypeError: unhashable type: 'list' "のエラー出た。しかし tuple に戻すと通りました。
   - 入力がタプルであれば、def get_max_amount(i: int, nums_: List[int]) にしてもACだった...あれ？
   - あ、これはあくまでヒントであって、違う型の引数も渡せちゃうのか...実験しといて良かった。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 3:
            return max(nums, default=0)
        
        @cache
        def get_max_amount(i: int, nums_: tuple) -> int:
            if i == 0:
                return nums_[0]
            if i == 1:
                return max(nums_[0], nums_[1])
            return max(nums_[i] + get_max_amount(i - 2, tuple(nums_)), get_max_amount(i - 1, tuple(nums_)))
        
        nums_1 = nums[:-1]
        nums_2 = nums[1:]
        return max( get_max_amount(len(nums_1) - 1, tuple(nums_1)), 
                    get_max_amount(len(nums_2) - 1, tuple(nums_2)) )
```

# Step2
 - やりたいことをやり尽くしたのでPR見る。
 - 解法ロジックは、同じようなものにみなさん収束している感じだった。
 - 「robHelperをrobInLineに変更」<- in_line って良いな。直線にした事が明示的。
   - https://github.com/hroc135/leetcode/pull/34/files
 - 「一直線の家の並びを意識しているので`rob_house_in_line`に変更した。」<- 流行ってますね。
   - https://github.com/sakupan102/arai60-practice/pull/37/files
 - 計算量考えてなかった。
   - dpテーブル用いるボトムアップは、時間・空間ともに2倍になるだけ? 定数倍なので変わらないか。
   - 再帰関数のトップダウンは、@cacheの使用メモリは、パラレルワールドごとに構築しているので、同じく2倍なので定数倍? 時間計算量は同じ事2回やるのでシンプルに2倍?
 - nums_1 nums_2 ではなくより良い名前が良い。
   - nums_without_tail, nums_without_init とかでしょうか。initはPythonのコンストラクタでも使われてるし、とりあえず略語でも良いのだろうか。
 - https://github.com/TORUS0818/leetcode/pull/38/files
   - 「インデックスでやるか配列を投げるか問題」
   - どういうことか把握できなかった...が、自分の場合、気に入ってる解法3でやるなら、引数としてインデックスもタプルも必要そう?
   - インデックスだけだと分けたパラレルワールド間でリークが起きそうなのが怖いので...
       - https://discord.com/channels/1084280443945353267/1235066663150420038/1236560779671634011
       - 忌避感はありのまま書くのが良さそう。
 - https://docs.python.org/ja/3/library/functools.html#functools.cache
   - @cacheのドキュメント。「メモ化」と呼ばれるキャッシュの子らしい。キャッシュにも色々あって自分が前整理したのはLRU_Cacheだったな。
 - https://docs.python.org/ja/3/library/functools.html#functools.lru_cache
   - この辺りは実装に関わるのでとても大事そう。LRUのところに書いてあったが、これ、他のキャッシュにも該当するのでは...?
       - 「結果のキャッシュには辞書が使われるので、関数の位置引数およびキーワード引数は ハッシュ可能 でなくてはなりません。」
       - 「引数のパターンが異なる場合は、異なる呼び出しと見なされ別々のキャッシュエントリーとなります。 例えば、 f(a=1, b=2) と f(b=2, a=1) はキーワード引数の順序が異なっているので、2つの別個のキャッシュエントリーになります。」
 - https://github.com/TORUS0818/leetcode/pull/38/files
   - スレッドセーフとは?
       - https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%82%BB%E3%83%BC%E3%83%95
       - 「あるプログラムコードがスレッドセーフであるという場合、そのコードを複数のスレッドが同時並行的に実行しても問題が発生しないことを意味する。」
   - そもそもスレッドとは? -> 並列処理の時のそれぞれの処理1つのこと?(CSの知識も勉強しなければ...)
 - https://docs.python.org/ja/3/library/functools.html#functools.cache
   - 「The cache is threadsafe so that the wrapped function can be used in multiple threads. This means that the underlying data structure will remain coherent during concurrent updates.」
   - @cache をつけた関数はスレッドセーフなので、複数スレッドから同時に呼ばれても、競合などの問題を起こさずに計算できるよ、ということですかね。
   - GPTに聞いてみたが、解法3はスレッドセーフとは関係なさそう?(スレッドを呼ぶということをした事がなく、あまりイメージがつかず。)
 - 解法1と解法2は、前問の繰り返しをしているだけになっているので、キャッシュの理解に良さげな解法3を題材にしたい。
   - 一番短くてシンプルで好きなのもあります。上記踏まえて、これを解法3を修正。
## 解法3:トップダウンDPを2回(実装を1関数で軽量化):AC
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 3:
            return max(nums, default=0)
        
        @cache
        def get_max_amount_inline(i: int, nums_: List[int]) -> int:
            if i == 0:
                return nums_[0]
            if i == 1:
                return max(nums_[0], nums_[1])
            return max(nums_[i] + get_max_amount_inline(i - 2, tuple(nums_)), 
                                  get_max_amount_inline(i - 1, tuple(nums_)) )
        
        nums_without_tail = nums[:-1]
        nums_without_init = nums[1:]
        return max( get_max_amount_inline(len(nums_without_tail) - 1, tuple(nums_without_tail)), 
                    get_max_amount_inline(len(nums_without_init) - 1, tuple(nums_without_init)) )
```

# Step3
 - 再現性の確認。
## 解法3:トップダウンDPを2回(実装を1関数で軽量化):AC
 - 最終的に、4分半くらいで実装。
 - これまでボトムアップに慣れてきてしまっていた。DPといえばdpテーブル配列用意するイメージが、勝手に出来上がってしまっていた。
 - (再帰の深さには注意かもしれないが)トップダウンも悪くないと感じるようになった。先にやりたい事宣言するのが、明示的で良いと感じた。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 3:
            return max(nums, default=0)
        @cache
        def get_max_amount(i: int, nums_: tuple) -> int:
            if i == 0:
                return nums_[0]
            if i == 1:
                return max(nums_[0], nums_[1])
            return max(nums_[i] + get_max_amount(i - 2, nums_), 
                                  get_max_amount(i - 1, nums_) )
        
        nums_without_tail = nums[:-1]
        nums_without_init = nums[1:]
        return max(get_max_amount(len(nums_without_tail) - 1, tuple(nums_without_tail)), 
                   get_max_amount(len(nums_without_init) - 1, tuple(nums_without_init)) )
```
